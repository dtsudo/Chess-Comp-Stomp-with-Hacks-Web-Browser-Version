/**
 * @version 1.0.0.0
 * @compiler Bridge.NET 17.6.0
 */
Bridge.assembly("ChessCompStompWithHacks", function ($asm, globals) {
    "use strict";

    Bridge.define("DTLibrary.IDisplayCleanup", {
        $kind: "interface"
    });

    Bridge.definei("DTLibrary.IDisplayOutput$2", function (ImageEnum, FontEnum) { return {
        $kind: "interface"
    }; });

    Bridge.definei("DTLibrary.IDisplayProcessing$1", function (ImageEnum) { return {
        $kind: "interface"
    }; });

    Bridge.define("ChessCompStompWithHacks.BridgeDisplay.ICanvasWidthAndHeightInfo", {
        $kind: "nested interface"
    });

    Bridge.define("ChessCompStompWithHacks.BridgeDisplayFont", {
        fields: {
            canvasWidthAndHeightInfo: null
        },
        ctors: {
            ctor: function (canvasWidthAndHeightInfo) {
                this.$initialize();
                this.canvasWidthAndHeightInfo = canvasWidthAndHeightInfo;

                
				window.BridgeDisplayFontJavascript = ((function () {
					'use strict';
					
					var fontDictionary = {};
					
					var context = null;
					
					var fontFamilyCount = 0;
					var numberOfFontObjectsLoaded = 0;
					var numberOfFontObjects = null;					
					
					var finishedLoading = false;
					
					var loadFonts = function (fontNames) {
						var fontNamesArray = fontNames.split(',');
						
						numberOfFontObjects = fontNamesArray.length;
						
						for (var i = 0; i < fontNamesArray.length; i++) {
							var fontName = fontNamesArray[i];
							
							if (fontDictionary[fontName])
								continue;
							
							var fontFamilyName = 'DTFontFamily' + fontFamilyCount;
							fontFamilyCount++;
							
							var font = new FontFace(fontFamilyName, 'url(Data/Font/' + fontName + ')');
							
							fontDictionary[fontName] = {
								font: font,
								fontFamilyName: fontFamilyName
							};
							
							font.load().then((function (f) {
								return function () {
									document.fonts.add(f);
									numberOfFontObjectsLoaded++;
								};
							})(font));
						}
						
						finishedLoading = numberOfFontObjects === numberOfFontObjectsLoaded;
						return finishedLoading;
					};

					var getNumElementsLoaded = function () {
						return numberOfFontObjectsLoaded;
					};

					var getNumTotalElementsToLoad = function () {
						return numberOfFontObjects;
					};
						
					var drawText = function (x, y, str, fontName, javascriptFontSize, lineHeight, red, green, blue, alpha) {
						if (context === null) {
							var canvas = document.getElementById('bridgeCanvas');
							
							if (canvas === null)
								return;
							
							context = canvas.getContext('2d', { alpha: false });
						}
						
						lineHeight = parseFloat(lineHeight);
						
						context.textBaseline = 'top';
						context.fillStyle = 'rgba(' + red.toString() + ', ' + green.toString() + ', ' + blue.toString() + ', ' + (alpha / 255).toString() + ')';
						context.strokeStyle = 'rgba(' + red.toString() + ', ' + green.toString() + ', ' + blue.toString() + ', ' + (alpha / 255).toString() + ')';
						context.font = javascriptFontSize + 'px "' + fontDictionary[fontName].fontFamilyName + '"';
						
						var strArray = str.split('\n');
						var lineY = y;
						
						for (var i = 0; i < strArray.length; i++) {
							context.fillText(strArray[i], x, Math.round(lineY));
							lineY += lineHeight;
						}
					};
						
					var tryDrawText = function (x, y, str, fontName, javascriptFontSize, lineHeight, red, green, blue, alpha) {
						if (!finishedLoading)
							return;
						
						drawText(x, y, str, fontName, javascriptFontSize, lineHeight, red, green, blue, alpha);
					};
						
					return {
						loadFonts: loadFonts,
						getNumElementsLoaded: getNumElementsLoaded,
						getNumTotalElementsToLoad: getNumTotalElementsToLoad,
						drawText: drawText,
						tryDrawText: tryDrawText
					};
				})());
			
            }
        },
        methods: {
            LoadFonts: function () {
                var $t, $t1;
                var woffFontFilenames = new (System.Collections.Generic.HashSet$1(System.String)).ctor();

                $t = Bridge.getEnumerator(System.Enum.getValues(ChessCompStompWithHacksLibrary.GameFont));
                try {
                    while ($t.moveNext()) {
                        var font = Bridge.cast($t.Current, ChessCompStompWithHacksLibrary.GameFont);
                        woffFontFilenames.add(ChessCompStompWithHacksLibrary.GameFontUtil.GetFontInfo(font).WoffFontFilename);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                var woffFontFilenamesAsString = "";
                var isFirst = true;
                $t1 = Bridge.getEnumerator(woffFontFilenames);
                try {
                    while ($t1.moveNext()) {
                        var woffFontFilename = $t1.Current;
                        if (isFirst) {
                            isFirst = false;
                        } else {
                            woffFontFilenamesAsString = (woffFontFilenamesAsString || "") + ",";
                        }
                        woffFontFilenamesAsString = (woffFontFilenamesAsString || "") + (woffFontFilename || "");
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                if (Bridge.referenceEquals(woffFontFilenamesAsString, "")) {
                    return true;
                }

                return eval("window.BridgeDisplayFontJavascript.loadFonts('" + (woffFontFilenamesAsString || "") + "')");
            },
            GetNumElementsLoaded: function () {
                return window.BridgeDisplayFontJavascript.getNumElementsLoaded();
            },
            GetNumTotalElementsToLoad: function () {
                return window.BridgeDisplayFontJavascript.getNumTotalElementsToLoad();
            },
            DrawText: function (x, y, text, font, color) {
                y = (((this.canvasWidthAndHeightInfo.ChessCompStompWithHacks$BridgeDisplay$ICanvasWidthAndHeightInfo$GetCurrentCanvasHeight() - y) | 0) - 1) | 0;

                var red = color.R;
                var green = color.G;
                var blue = color.B;
                var alpha = color.Alpha;

                var fontInfo = ChessCompStompWithHacksLibrary.GameFontUtil.GetFontInfo(font);

                window.BridgeDisplayFontJavascript.drawText(x, y, text, fontInfo.WoffFontFilename, fontInfo.JavascriptFontSize, fontInfo.LineHeight, red, green, blue, alpha);
            },
            TryDrawText: function (x, y, text, font, color) {
                y = (((this.canvasWidthAndHeightInfo.ChessCompStompWithHacks$BridgeDisplay$ICanvasWidthAndHeightInfo$GetCurrentCanvasHeight() - y) | 0) - 1) | 0;

                var red = color.R;
                var green = color.G;
                var blue = color.B;
                var alpha = color.Alpha;

                var fontInfo = ChessCompStompWithHacksLibrary.GameFontUtil.GetFontInfo(font);

                window.BridgeDisplayFontJavascript.tryDrawText(x, y, text, fontInfo.WoffFontFilename, fontInfo.JavascriptFontSize, fontInfo.LineHeight, red, green, blue, alpha);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacks.BridgeDisplayImages", {
        fields: {
            canvasWidthAndHeightInfo: null,
            widthDictionary: null,
            heightDictionary: null
        },
        ctors: {
            ctor: function (canvasWidthAndHeightInfo, canvasScalingFactor) {
                this.$initialize();
                this.canvasWidthAndHeightInfo = canvasWidthAndHeightInfo;

                this.widthDictionary = new (System.Collections.Generic.Dictionary$2(ChessCompStompWithHacksLibrary.GameImage,System.Int32))();
                this.heightDictionary = new (System.Collections.Generic.Dictionary$2(ChessCompStompWithHacksLibrary.GameImage,System.Int32))();
                eval("\r\n\t\t\t\twindow.BridgeDisplayImagesJavascript = ((function () {\r\n\t\t\t\t\t'use strict';\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar imgDict = {};\r\n\t\t\t\t\tvar widthDict = {};\r\n\t\t\t\t\tvar heightDict = {};\r\n\t\t\t\t\tvar canvas = null;\r\n\t\t\t\t\tvar context = null;\r\n\t\t\t\t\tvar radianConversion = 1.0 / 128.0 * (2.0 * Math.PI / 360.0);\r\n\t\t\t\t\tvar canvasScalingFactor = " + (DTLibrary.StringUtil.ToStringCultureInvariant(canvasScalingFactor) || "") + ";\r\n\r\n\t\t\t\t\tvar numberOfImagesLoaded = 0;\r\n\t\t\t\t\tvar totalNumberOfImages = null;\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar loadImages = function (imageNames) {\r\n\t\t\t\t\t\tvar imageNamesArray = imageNames.split(',');\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar count = 0;\r\n\t\t\t\t\t\ttotalNumberOfImages = imageNamesArray.length;\t\t\t\t\t\t\r\n\r\n\t\t\t\t\t\tfor (var i = 0; i < imageNamesArray.length; i++) {\r\n\t\t\t\t\t\t\tvar imageName = imageNamesArray[i];\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif (imgDict[imageName])\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tvar imgPath = 'Data/Images/' + imageName;\r\n\t\t\t\t\t\t\tvar img = new Image();\r\n\t\t\t\t\t\t\timg.addEventListener('load', (function (a, b) {\r\n\t\t\t\t\t\t\t\treturn function () {\r\n\t\t\t\t\t\t\t\t\tnumberOfImagesLoaded++;\r\n\t\t\t\t\t\t\t\t\twidthDict[a] = b.naturalWidth;\r\n\t\t\t\t\t\t\t\t\theightDict[a] = b.naturalHeight;\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t})(imageName, img));\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\timg.src = imgPath;\r\n\t\t\t\t\t\t\timgDict[imageName] = img;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tcount++;\r\n\t\t\t\t\t\t\tif (count === 15) // arbitrary\r\n\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\treturn numberOfImagesLoaded === imageNamesArray.length;\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tvar getNumElementsLoaded = function () {\r\n\t\t\t\t\t\treturn numberOfImagesLoaded;\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tvar getNumTotalElementsToLoad = function () {\r\n\t\t\t\t\t\treturn totalNumberOfImages;\r\n\t\t\t\t\t};\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar drawImageRotatedClockwise = function (imageName, x, y, degreesScaled, scalingFactorScaled) {\r\n\t\t\t\t\t\tif (canvas === null) {\r\n\t\t\t\t\t\t\tcanvas = document.getElementById('bridgeCanvas');\r\n\t\t\t\t\t\t\tif (canvas !== null)\r\n\t\t\t\t\t\t\t\tcontext = canvas.getContext('2d', { alpha: false });\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar img = imgDict[imageName];\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (degreesScaled === 0 && scalingFactorScaled === 128) {\r\n\t\t\t\t\t\t\tcontext.drawImage(img, x, y);\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar scalingFactor = scalingFactorScaled / 128.0;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontext.translate(x, y);\r\n\t\t\t\t\t\tcontext.scale(scalingFactor, scalingFactor);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (degreesScaled !== 0) {\r\n\t\t\t\t\t\t\tcontext.translate(img.width / 2, img.height / 2);\r\n\t\t\t\t\t\t\tcontext.rotate(degreesScaled * radianConversion);\r\n\t\t\t\t\t\t\tcontext.translate(-img.width / 2, -img.height / 2);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontext.drawImage(img, 0, 0);\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontext.setTransform(canvasScalingFactor, 0, 0, canvasScalingFactor, 0, 0);\r\n\t\t\t\t\t};\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar drawImageRotatedClockwise2 = function (imageName, imageX, imageY, imageWidth, imageHeight, x, y, degreesScaled, scalingFactorScaled) {\r\n\t\t\t\t\t\tif (canvas === null) {\r\n\t\t\t\t\t\t\tcanvas = document.getElementById('bridgeCanvas');\r\n\t\t\t\t\t\t\tif (canvas !== null)\r\n\t\t\t\t\t\t\t\tcontext = canvas.getContext('2d', { alpha: false });\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar img = imgDict[imageName];\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar scalingFactor = scalingFactorScaled / 128.0;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontext.translate(x, y);\r\n\t\t\t\t\t\tcontext.scale(scalingFactor, scalingFactor);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (degreesScaled !== 0) {\r\n\t\t\t\t\t\t\tcontext.translate(imageWidth / 2, imageHeight / 2);\r\n\t\t\t\t\t\t\tcontext.rotate(degreesScaled * radianConversion);\r\n\t\t\t\t\t\t\tcontext.translate(-imageWidth / 2, -imageHeight / 2);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontext.drawImage(img, imageX, imageY, imageWidth, imageHeight, 0, 0, imageWidth, imageHeight);\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontext.setTransform(canvasScalingFactor, 0, 0, canvasScalingFactor, 0, 0);\r\n\t\t\t\t\t};\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar getWidth = function (imageName) {\r\n\t\t\t\t\t\treturn widthDict[imageName];\r\n\t\t\t\t\t};\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar getHeight = function (imageName) {\r\n\t\t\t\t\t\treturn heightDict[imageName];\r\n\t\t\t\t\t};\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tloadImages: loadImages,\r\n\t\t\t\t\t\tgetNumElementsLoaded: getNumElementsLoaded,\r\n\t\t\t\t\t\tgetNumTotalElementsToLoad: getNumTotalElementsToLoad,\r\n\t\t\t\t\t\tdrawImageRotatedClockwise: drawImageRotatedClockwise,\r\n\t\t\t\t\t\tdrawImageRotatedClockwise2: drawImageRotatedClockwise2,\r\n\t\t\t\t\t\tgetWidth: getWidth,\r\n\t\t\t\t\t\tgetHeight: getHeight\r\n\t\t\t\t\t};\r\n\t\t\t\t})());\r\n\t\t\t");
            }
        },
        methods: {
            LoadImages: function () {
                var $t;
                var imageNames = "";
                var isFirst = true;

                $t = Bridge.getEnumerator(System.Enum.getValues(ChessCompStompWithHacksLibrary.GameImage));
                try {
                    while ($t.moveNext()) {
                        var gameImage = Bridge.cast($t.Current, ChessCompStompWithHacksLibrary.GameImage);
                        if (isFirst) {
                            isFirst = false;
                        } else {
                            imageNames = (imageNames || "") + ",";
                        }
                        imageNames = (imageNames || "") + (ChessCompStompWithHacksLibrary.GameImageUtil.GetImageFilename(gameImage) || "");
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                if (Bridge.referenceEquals(imageNames, "")) {
                    return true;
                }

                var result = eval("window.BridgeDisplayImagesJavascript.loadImages('" + (imageNames || "") + "')");

                if (result) {
                    return true;
                }
                return false;
            },
            GetNumElementsLoaded: function () {
                return window.BridgeDisplayImagesJavascript.getNumElementsLoaded();
            },
            GetNumTotalElementsToLoad: function () {
                return window.BridgeDisplayImagesJavascript.getNumTotalElementsToLoad();
            },
            DrawImageRotatedClockwise: function (image, x, y, degreesScaled, scalingFactorScaled) {
                var height = this.GetHeight(image);
                var scaledHeight = (Bridge.Int.div(Bridge.Int.mul(height, scalingFactorScaled), 128)) | 0;
                y = (((this.canvasWidthAndHeightInfo.ChessCompStompWithHacks$BridgeDisplay$ICanvasWidthAndHeightInfo$GetCurrentCanvasHeight() - y) | 0) - scaledHeight) | 0;

                window.BridgeDisplayImagesJavascript.drawImageRotatedClockwise(ChessCompStompWithHacksLibrary.GameImageUtil.GetImageFilename(image), x, y, degreesScaled, scalingFactorScaled);
            },
            DrawImageRotatedClockwise$1: function (image, imageX, imageY, imageWidth, imageHeight, x, y, degreesScaled, scalingFactorScaled) {
                var height = imageHeight;
                var scaledHeight = (Bridge.Int.div(Bridge.Int.mul(height, scalingFactorScaled), 128)) | 0;
                y = (((this.canvasWidthAndHeightInfo.ChessCompStompWithHacks$BridgeDisplay$ICanvasWidthAndHeightInfo$GetCurrentCanvasHeight() - y) | 0) - scaledHeight) | 0;

                window.BridgeDisplayImagesJavascript.drawImageRotatedClockwise2(ChessCompStompWithHacksLibrary.GameImageUtil.GetImageFilename(image), imageX, imageY, imageWidth, imageHeight, x, y, degreesScaled, scalingFactorScaled);
            },
            GetWidth: function (image) {
                if (this.widthDictionary.containsKey(image)) {
                    return this.widthDictionary.get(image);
                }

                var width = this.GetWidthFromJavascript(image);
                this.widthDictionary.set(image, width);
                return width;
            },
            GetWidthFromJavascript: function (image) {
                return eval("window.BridgeDisplayImagesJavascript.getWidth('" + (ChessCompStompWithHacksLibrary.GameImageUtil.GetImageFilename(image) || "") + "')");
            },
            GetHeight: function (image) {
                if (this.heightDictionary.containsKey(image)) {
                    return this.heightDictionary.get(image);
                }

                var height = this.GetHeightFromJavascript(image);
                this.heightDictionary.set(image, height);
                return height;
            },
            GetHeightFromJavascript: function (image) {
                return eval("window.BridgeDisplayImagesJavascript.getHeight('" + (ChessCompStompWithHacksLibrary.GameImageUtil.GetImageFilename(image) || "") + "')");
            }
        }
    });

    Bridge.define("ChessCompStompWithHacks.BridgeDisplayRectangle", {
        fields: {
            canvasWidthAndHeightInfo: null
        },
        ctors: {
            ctor: function (canvasWidthAndHeightInfo) {
                this.$initialize();
                this.canvasWidthAndHeightInfo = canvasWidthAndHeightInfo;

                
				window.BridgeDisplayRectangleJavascript = ((function () {
					'use strict';
					
					var canvas = null;
					var context = null;
							
					var drawRectangle = function (x, y, width, height, red, green, blue, alpha, fill) {
								
						if (canvas === null) {
							canvas = document.getElementById('bridgeCanvas');		
							if (canvas === null)
								return;	
							context = canvas.getContext('2d', { alpha: false });
						}
						
						context.fillStyle = 'rgba(' + red.toString() + ', ' + green.toString() + ', ' + blue.toString() + ', ' + (alpha / 255).toString() + ')';
						context.strokeStyle = 'rgba(' + red.toString() + ', ' + green.toString() + ', ' + blue.toString() + ', ' + (alpha / 255).toString() + ')';
						
						if (fill)
							context.fillRect(x, y, width, height);
						else
							context.strokeRect(x, y, width, height);
					};
										
					return {
						drawRectangle: drawRectangle
					};
				})());
			
            }
        },
        methods: {
            DrawRectangle: function (x, y, width, height, color, fill) {
                y = (((this.canvasWidthAndHeightInfo.ChessCompStompWithHacks$BridgeDisplay$ICanvasWidthAndHeightInfo$GetCurrentCanvasHeight() - y) | 0) - height) | 0;

                var red = color.R;
                var green = color.G;
                var blue = color.B;
                var alpha = color.Alpha;

                window.BridgeDisplayRectangleJavascript.drawRectangle(x, y, width, height, red, green, blue, alpha, fill);
            }
        }
    });

    Bridge.define("DTLibrary.IFileIO", {
        $kind: "interface"
    });

    Bridge.define("DTLibrary.IKeyboard", {
        $kind: "interface"
    });

    Bridge.define("DTLibrary.IMouse", {
        $kind: "interface"
    });

    Bridge.define("DTLibrary.IMusicCleanup", {
        $kind: "interface"
    });

    Bridge.define("DTLibrary.IMusicProcessing", {
        $kind: "interface"
    });

    Bridge.definei("DTLibrary.IMusicOutput$1", function (MusicEnum) { return {
        $kind: "interface"
    }; });

    Bridge.definei("DTLibrary.ISoundOutput$1", function (SoundEnum) { return {
        $kind: "interface"
    }; });

    Bridge.define("ChessCompStompWithHacks.BridgeUtil", {
        statics: {
            methods: {
                IsMobileSafari: function () {
                    var isMobileSafari = eval("\r\n\t\t\t\t((function () {\r\n\t\t\t\t\tlet isDesktop = window.matchMedia('(pointer:fine)').matches;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (isDesktop)\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\r\n\t\t\t\t\tlet userAgent = window.navigator.userAgent.toLowerCase();\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (userAgent.includes('chrome'))\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tif (userAgent.includes('chromium'))\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (!userAgent.includes('safari'))\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t})())\r\n\t\t\t");

                    if (isMobileSafari) {
                        return true;
                    } else {
                        return false;
                    }
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacks.GameInitializer", {
        statics: {
            fields: {
                bridgeKeyboard: null,
                bridgeMouse: null,
                previousKeyboard: null,
                previousMouse: null,
                display: null,
                soundOutput: null,
                music: null,
                canvasWidthAndHeightInfo: null,
                canvasScalingFactor: 0,
                displayLogger: null,
                shouldRenderDisplayLogger: false,
                completedAchievements: null,
                frame: null,
                hasInitializedClearCanvasJavascript: false,
                clickUrl: null
            },
            methods: {
                InitializeDisplayTypeHandlingJavascript: function (isWebStandAlone, canvasScalingFactor, debugMode) {
                    eval("\r\n\t\t\t\twindow.BridgeDisplayTypeHandlingJavascript = ((function () {\r\n\t\t\t\t\t'use strict';\r\n\r\n\t\t\t\t\tlet debugMode = " + ((debugMode ? "true" : "false") || "") + ";\r\n\r\n\t\t\t\t\tlet displayTypeOverride = null;\r\n\t\t\t\t\tlet useUnscaledCanvas = false;\r\n\r\n\t\t\t\t\tif (debugMode) {\r\n\t\t\t\t\t\tdocument.addEventListener('keydown', function (e) {\r\n\t\t\t\t\t\t\tif (e.key === '0') {\r\n\t\t\t\t\t\t\t\tif (displayTypeOverride === null)\r\n\t\t\t\t\t\t\t\t\tdisplayTypeOverride = 'mobile';\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\tdisplayTypeOverride = (displayTypeOverride === 'mobile') ? 'desktop' : 'mobile';\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (e.key === '9') {\r\n\t\t\t\t\t\t\t\tuseUnscaledCanvas = !useUnscaledCanvas;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}, false);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet canvas = null;\r\n\t\t\t\t\tlet context = null;\r\n\t\t\t\t\tlet bodyElement = null;\r\n\r\n\t\t\t\t\tlet canvasScalingFactor = " + (DTLibrary.StringUtil.ToStringCultureInvariant(canvasScalingFactor) || "") + ";\r\n\r\n\t\t\t\t\tlet isWebStandAlone = " + ((isWebStandAlone ? "true" : "false") || "") + ";\r\n\t\t\t\t\tlet defaultWidth = canvasScalingFactor * " + (DTLibrary.StringUtil.ToStringCultureInvariant(ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH) || "") + ";\r\n\t\t\t\t\tlet defaultHeight = canvasScalingFactor * " + (DTLibrary.StringUtil.ToStringCultureInvariant(ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT) || "") + ";\r\n\r\n\t\t\t\t\tlet isDesktop = true;\r\n\t\t\t\t\tlet isMobileLandscape = false;\r\n\t\t\t\t\tlet isMobilePortrait = false;\r\n\r\n\t\t\t\t\tlet currentCanvasWidth = defaultWidth;\r\n\t\t\t\t\tlet currentCanvasHeight = defaultHeight;\r\n\r\n\t\t\t\t\tlet handleDisplayTypeChanges = function () {\r\n\r\n\t\t\t\t\t\tif (!window)\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tif (!document)\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (!bodyElement) {\r\n\t\t\t\t\t\t\tbodyElement = document.body;\r\n\t\t\t\t\t\t\tif (!bodyElement)\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (!canvas) {\r\n\t\t\t\t\t\t\tcanvas = document.getElementById('bridgeCanvas');\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif (!canvas)\r\n\t\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\t\tcontext = canvas.getContext('2d', { alpha: false });\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tlet innerWidth = window.innerWidth;\r\n\t\t\t\t\t\tlet innerHeight = window.innerHeight;\r\n\r\n\t\t\t\t\t\tif (innerWidth < 5)\r\n\t\t\t\t\t\t\tinnerWidth = 5;\r\n\t\t\t\t\t\tif (innerHeight < 5)\r\n\t\t\t\t\t\t\tinnerHeight = 5;\r\n\r\n\t\t\t\t\t\tlet isLibrem5Mobile = window.navigator.userAgent.toLowerCase().includes('aarch64')\r\n\t\t\t\t\t\t\t&& window.navigator.userAgent.toLowerCase().includes('linux')\r\n\t\t\t\t\t\t\t&& !window.navigator.userAgent.toLowerCase().includes('android')\r\n\t\t\t\t\t\t\t&& (window.screen.height / window.screen.width === 2 || window.screen.width / window.screen.height === 2);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tisDesktop = window.matchMedia('(pointer:fine)').matches\r\n\t\t\t\t\t\t\t&& !isLibrem5Mobile;\r\n\r\n\t\t\t\t\t\tif (displayTypeOverride === 'desktop')\r\n\t\t\t\t\t\t\tisDesktop = true;\r\n\t\t\t\t\t\tif (displayTypeOverride === 'mobile')\r\n\t\t\t\t\t\t\tisDesktop = false;\r\n\r\n\t\t\t\t\t\tif (isDesktop) {\r\n\t\t\t\t\t\t\tisMobileLandscape = false;\r\n\t\t\t\t\t\t\tisMobilePortrait = false;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tisMobileLandscape = innerWidth > innerHeight;\r\n\t\t\t\t\t\t\tisMobilePortrait = !isMobileLandscape;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (isDesktop && isWebStandAlone)\r\n\t\t\t\t\t\t\tbodyElement.style.margin = '8px';\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tbodyElement.style.margin = '0px';\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tlet newCanvasWidth;\r\n\t\t\t\t\t\tlet newCanvasHeight;\r\n\r\n\t\t\t\t\t\tif (isDesktop) {\r\n\t\t\t\t\t\t\tnewCanvasWidth = defaultWidth;\r\n\t\t\t\t\t\t\tnewCanvasHeight = defaultHeight;\r\n\t\t\t\t\t\t} else if (isMobileLandscape) {\r\n\t\t\t\t\t\t\tnewCanvasWidth = Math.max(defaultWidth, Math.round((innerWidth / innerHeight) * defaultHeight));\r\n\t\t\t\t\t\t\tnewCanvasHeight = defaultHeight;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tnewCanvasWidth = defaultHeight;\r\n\t\t\t\t\t\t\tnewCanvasHeight = Math.max(defaultWidth, Math.round((innerHeight / innerWidth) * defaultHeight));\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (newCanvasWidth !== canvas.width)\r\n\t\t\t\t\t\t\tcanvas.width = newCanvasWidth;\r\n\t\t\t\t\t\tif (newCanvasHeight !== canvas.height)\r\n\t\t\t\t\t\t\tcanvas.height = newCanvasHeight;\r\n\r\n\t\t\t\t\t\tcurrentCanvasWidth = canvas.width;\r\n\t\t\t\t\t\tcurrentCanvasHeight = canvas.height;\r\n\r\n\t\t\t\t\t\tcontext.setTransform(canvasScalingFactor, 0, 0, canvasScalingFactor, 0, 0);\r\n\r\n\t\t\t\t\t\tlet canvasMarginTop;\r\n\t\t\t\t\t\tif ((isDesktop && !isWebStandAlone || !isDesktop) && !useUnscaledCanvas) {\r\n\t\t\t\t\t\t\tlet canvasScalingX = innerWidth / canvas.width;\r\n\t\t\t\t\t\t\tlet canvasScalingY = innerHeight / canvas.height;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tlet canvasScaling = Math.min(canvasScalingX, canvasScalingY);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tlet newCanvasCssWidth = Math.floor(canvas.width * canvasScaling);\r\n\t\t\t\t\t\t\tlet newCanvasCssHeight = Math.floor(canvas.height * canvasScaling);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tcanvas.style.width = newCanvasCssWidth + 'px';\r\n\t\t\t\t\t\t\tcanvas.style.height = newCanvasCssHeight + 'px';\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif (innerHeight > newCanvasCssHeight) {\r\n\t\t\t\t\t\t\t\tcanvasMarginTop = Math.floor((innerHeight - newCanvasCssHeight) / 2);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcanvasMarginTop = 0;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tcanvas.style.width = Math.floor(canvas.width / canvasScalingFactor) + 'px';\r\n\t\t\t\t\t\t\tcanvas.style.height = Math.floor(canvas.height / canvasScalingFactor) + 'px';\r\n\t\t\t\t\t\t\tcanvasMarginTop = 0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcanvas.style.marginTop = canvasMarginTop + 'px';\r\n\r\n\t\t\t\t\t\tif (isDesktop && isWebStandAlone) {\r\n\t\t\t\t\t\t\tbodyElement.style.backgroundColor = '#ebebeb';\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tbodyElement.style.backgroundColor = '#c7c2bc';\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tsetInterval(handleDisplayTypeChanges, 250);\r\n\t\t\t\t\thandleDisplayTypeChanges();\r\n\r\n\t\t\t\t\tlet isDesktopDisplayType = function () {\r\n\t\t\t\t\t\treturn isDesktop;\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tlet isMobileLandscapeDisplayType = function () {\r\n\t\t\t\t\t\treturn isMobileLandscape;\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tlet isMobilePortraitDisplayType = function () {\r\n\t\t\t\t\t\treturn isMobilePortrait;\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tisDesktopDisplayType: isDesktopDisplayType,\r\n\t\t\t\t\t\tisMobileLandscapeDisplayType: isMobileLandscapeDisplayType,\r\n\t\t\t\t\t\tisMobilePortraitDisplayType: isMobilePortraitDisplayType,\r\n\t\t\t\t\t\tgetCurrentCanvasWidth: function () { return Math.floor(currentCanvasWidth / canvasScalingFactor); },\r\n\t\t\t\t\t\tgetCurrentCanvasHeight: function () { return Math.floor(currentCanvasHeight / canvasScalingFactor); }\r\n\t\t\t\t\t};\r\n\t\t\t\t})());\r\n\t\t\t");
                },
                InitializeClearCanvasJavascript: function (canvasScalingFactor) {
                    eval("\r\n\t\t\t\twindow.BridgeClearCanvasJavascript = ((function () {\r\n\t\t\t\t\t'use strict';\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar canvas = null;\r\n\t\t\t\t\tvar context = null;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\tvar clearCanvas = function () {\r\n\t\t\t\t\t\tif (canvas === null) {\r\n\t\t\t\t\t\t\tcanvas = document.getElementById('bridgeCanvas');\r\n\t\t\t\t\t\t\tif (canvas === null)\r\n\t\t\t\t\t\t\t\treturn;\t\r\n\t\t\t\t\t\t\tcontext = canvas.getContext('2d', { alpha: false });\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontext.clearRect(0, 0, canvas.width, canvas.height);\r\n\t\t\t\t\t\tlet canvasScalingFactor = " + (DTLibrary.StringUtil.ToStringCultureInvariant(canvasScalingFactor) || "") + ";\r\n\t\t\t\t\t\tcontext.setTransform(canvasScalingFactor, 0, 0, canvasScalingFactor, 0, 0);\r\n\t\t\t\t\t};\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tclearCanvas: clearCanvas\r\n\t\t\t\t\t};\r\n\t\t\t\t})());\r\n\t\t\t");
                },
                ClearCanvas: function (canvasScalingFactor) {
                    if (!ChessCompStompWithHacks.GameInitializer.hasInitializedClearCanvasJavascript) {
                        ChessCompStompWithHacks.GameInitializer.InitializeClearCanvasJavascript(canvasScalingFactor);
                        ChessCompStompWithHacks.GameInitializer.hasInitializedClearCanvasJavascript = true;
                    }

                    window.BridgeClearCanvasJavascript.clearCanvas();
                },
                ClearClickUrl: function () {
                    window.bridgeClickUrl = null;
                },
                UpdateClickUrl: function (clickUrl) {
                    eval("window.bridgeClickUrl = '" + (clickUrl || "") + "';");
                },
                AddClickUrlListener: function () {
                    
				document.addEventListener('click', function (e) {
					if (window.bridgeClickUrl !== undefined
							&& window.bridgeClickUrl !== null
							&& window.bridgeClickUrl !== '')
						window.open(window.bridgeClickUrl, '_blank');
				}, false);
			
                },
                Start: function (fps, isEmbeddedVersion, isElectronVersion, canvasScalingFactor, stopWaitingEvenIfMusicHasNotLoaded, debugMode) {
                    ChessCompStompWithHacks.GameInitializer.canvasScalingFactor = canvasScalingFactor;

                    ChessCompStompWithHacks.GameInitializer.hasInitializedClearCanvasJavascript = false;

                    ChessCompStompWithHacks.GameInitializer.shouldRenderDisplayLogger = true;

                    ChessCompStompWithHacks.GameInitializer.clickUrl = null;

                    ChessCompStompWithHacks.GameInitializer.completedAchievements = new (System.Collections.Generic.HashSet$1(System.String)).ctor();

                    ChessCompStompWithHacks.GameInitializer.ClearClickUrl();

                    ChessCompStompWithHacks.GameInitializer.AddClickUrlListener();

                    var buildType = new DTLibrary.BuildType();

                    if (isEmbeddedVersion) {
                        buildType = DTLibrary.BuildType.WebEmbedded;
                    } else {
                        if (isElectronVersion) {
                            buildType = DTLibrary.BuildType.Electron;
                        } else {
                            buildType = DTLibrary.BuildType.WebStandAlone;
                        }
                    }

                    ChessCompStompWithHacks.GameInitializer.InitializeDisplayTypeHandlingJavascript(buildType === DTLibrary.BuildType.WebStandAlone, canvasScalingFactor, debugMode);

                    ChessCompStompWithHacks.GameInitializer.canvasWidthAndHeightInfo = new ChessCompStompWithHacks.GameInitializer.CanvasWidthAndHeightInfo();

                    var logger;
                    if (debugMode) {
                        ChessCompStompWithHacks.GameInitializer.displayLogger = new DTLibrary.DisplayLogger(5, 95);
                        logger = ChessCompStompWithHacks.GameInitializer.displayLogger;
                    } else {
                        ChessCompStompWithHacks.GameInitializer.displayLogger = null;
                        logger = new DTLibrary.EmptyLogger();
                    }

                    var globalState = new ChessCompStompWithHacksLibrary.GlobalState(fps, new DTLibrary.DTRandom(), new DTLibrary.GuidGenerator("94197619109494365160"), logger, new DTLibrary.SimpleTimer(), new ChessCompStompWithHacks.BridgeFileIO(), buildType, debugMode, false, null);

                    ChessCompStompWithHacks.GameInitializer.frame = ChessCompStompWithHacksLibrary.GameInitialization.GetFirstFrame(globalState);

                    ChessCompStompWithHacks.GameInitializer.bridgeKeyboard = new ChessCompStompWithHacks.BridgeKeyboard(buildType === DTLibrary.BuildType.WebEmbedded || buildType === DTLibrary.BuildType.Electron);
                    ChessCompStompWithHacks.GameInitializer.bridgeMouse = new ChessCompStompWithHacks.BridgeMouse(canvasScalingFactor);

                    ChessCompStompWithHacks.GameInitializer.display = new ChessCompStompWithHacks.BridgeDisplay(ChessCompStompWithHacks.GameInitializer.canvasWidthAndHeightInfo, canvasScalingFactor);
                    ChessCompStompWithHacks.GameInitializer.soundOutput = new ChessCompStompWithHacks.BridgeSoundOutput(globalState.ElapsedMicrosPerFrame);
                    ChessCompStompWithHacks.GameInitializer.music = new ChessCompStompWithHacks.BridgeMusic(stopWaitingEvenIfMusicHasNotLoaded);

                    ChessCompStompWithHacks.GameInitializer.previousKeyboard = new DTLibrary.EmptyKeyboard();
                    ChessCompStompWithHacks.GameInitializer.previousMouse = new DTLibrary.EmptyMouse();

                    ChessCompStompWithHacks.GameInitializer.ClearCanvas(canvasScalingFactor);
                    ChessCompStompWithHacks.GameInitializer.frame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render(ChessCompStompWithHacks.GameInitializer.display);
                    ChessCompStompWithHacks.GameInitializer.frame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic(ChessCompStompWithHacks.GameInitializer.music);
                    if (ChessCompStompWithHacks.GameInitializer.displayLogger != null && ChessCompStompWithHacks.GameInitializer.shouldRenderDisplayLogger) {
                        ChessCompStompWithHacks.GameInitializer.displayLogger.Render(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, ChessCompStompWithHacks.GameInitializer.display, ChessCompStompWithHacksLibrary.GameFont.GameFont14Pt, DTLibrary.DTColor.Black());
                    }
                },
                ProcessExtraTime: function (milliseconds) {
                    ChessCompStompWithHacks.GameInitializer.frame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime(milliseconds);
                },
                AddAchievementToJavascriptArray: function (achievement) {
                    eval("if (!window.BridgeCompletedAchievements) window.BridgeCompletedAchievements = [];");
                    eval("window.BridgeCompletedAchievements.push('" + (achievement || "") + "');");
                },
                ComputeAndRenderNextFrame: function () {
                    var $t;
                    var currentKeyboard = new DTLibrary.CopiedKeyboard(ChessCompStompWithHacks.GameInitializer.bridgeKeyboard);
                    var currentMouse = new DTLibrary.CopiedMouse(ChessCompStompWithHacks.GameInitializer.bridgeMouse);
                    ChessCompStompWithHacks.GameInitializer.bridgeKeyboard.ProcessedInputs();
                    ChessCompStompWithHacks.GameInitializer.bridgeMouse.ProcessedInputs();

                    var displayType = new DTLibrary.DisplayType();
                    var isDesktopDisplayType = window.BridgeDisplayTypeHandlingJavascript.isDesktopDisplayType();
                    var isMobileLandscapeDisplayType = window.BridgeDisplayTypeHandlingJavascript.isMobileLandscapeDisplayType();

                    var currentCanvasWidth = window.BridgeDisplayTypeHandlingJavascript.getCurrentCanvasWidth();
                    var currentCanvasHeight = window.BridgeDisplayTypeHandlingJavascript.getCurrentCanvasHeight();

                    ChessCompStompWithHacks.GameInitializer.canvasWidthAndHeightInfo.SetCurrentCanvasWidth(currentCanvasWidth);
                    ChessCompStompWithHacks.GameInitializer.canvasWidthAndHeightInfo.SetCurrentCanvasHeight(currentCanvasHeight);

                    if (isDesktopDisplayType) {
                        displayType = DTLibrary.DisplayType.Desktop;
                    } else {
                        if (isMobileLandscapeDisplayType) {
                            displayType = DTLibrary.DisplayType.MobileLandscape;
                        } else {
                            displayType = DTLibrary.DisplayType.MobilePortrait;
                        }
                    }

                    ChessCompStompWithHacks.GameInitializer.frame = ChessCompStompWithHacks.GameInitializer.frame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType(displayType, ChessCompStompWithHacks.GameInitializer.display);

                    ChessCompStompWithHacks.GameInitializer.frame = ChessCompStompWithHacks.GameInitializer.frame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame(currentKeyboard, currentMouse, ChessCompStompWithHacks.GameInitializer.previousKeyboard, ChessCompStompWithHacks.GameInitializer.previousMouse, ChessCompStompWithHacks.GameInitializer.display, ChessCompStompWithHacks.GameInitializer.soundOutput, ChessCompStompWithHacks.GameInitializer.music);
                    ChessCompStompWithHacks.GameInitializer.frame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic();
                    ChessCompStompWithHacks.GameInitializer.soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$ProcessFrame();
                    ChessCompStompWithHacks.GameInitializer.ClearCanvas(ChessCompStompWithHacks.GameInitializer.canvasScalingFactor);
                    ChessCompStompWithHacks.GameInitializer.frame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render(ChessCompStompWithHacks.GameInitializer.display);
                    ChessCompStompWithHacks.GameInitializer.frame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic(ChessCompStompWithHacks.GameInitializer.music);

                    var newCompletedAchievements = ChessCompStompWithHacks.GameInitializer.frame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements();

                    if (newCompletedAchievements != null) {
                        $t = Bridge.getEnumerator(newCompletedAchievements);
                        try {
                            while ($t.moveNext()) {
                                var completedAchievement = $t.Current;
                                var wasAdded = ChessCompStompWithHacks.GameInitializer.completedAchievements.add(completedAchievement);

                                if (wasAdded) {
                                    ChessCompStompWithHacks.GameInitializer.AddAchievementToJavascriptArray(completedAchievement);
                                }
                            }
                        } finally {
                            if (Bridge.is($t, System.IDisposable)) {
                                $t.System$IDisposable$Dispose();
                            }
                        }
                    }

                    var newClickUrl = ChessCompStompWithHacks.GameInitializer.frame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl();

                    if (!Bridge.referenceEquals(ChessCompStompWithHacks.GameInitializer.clickUrl, newClickUrl)) {
                        ChessCompStompWithHacks.GameInitializer.clickUrl = newClickUrl;
                        if (ChessCompStompWithHacks.GameInitializer.clickUrl == null) {
                            ChessCompStompWithHacks.GameInitializer.ClearClickUrl();
                        } else {
                            ChessCompStompWithHacks.GameInitializer.UpdateClickUrl(ChessCompStompWithHacks.GameInitializer.clickUrl);
                        }
                    }

                    if (ChessCompStompWithHacks.GameInitializer.displayLogger != null && ChessCompStompWithHacks.GameInitializer.shouldRenderDisplayLogger) {
                        ChessCompStompWithHacks.GameInitializer.displayLogger.Render(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, ChessCompStompWithHacks.GameInitializer.display, ChessCompStompWithHacksLibrary.GameFont.GameFont14Pt, DTLibrary.DTColor.Black());
                    }

                    if (currentKeyboard.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.L) && !ChessCompStompWithHacks.GameInitializer.previousKeyboard.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.L)) {
                        ChessCompStompWithHacks.GameInitializer.shouldRenderDisplayLogger = !ChessCompStompWithHacks.GameInitializer.shouldRenderDisplayLogger;
                    }

                    ChessCompStompWithHacks.GameInitializer.previousKeyboard = currentKeyboard;
                    ChessCompStompWithHacks.GameInitializer.previousMouse = currentMouse;
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacks.Program", {
        main: function Main (args) {
            ChessCompStompWithHacks.Program.AddFpsDisplayJavascript();
            ChessCompStompWithHacks.Program.Initialize();
        },
        statics: {
            methods: {
                AddFpsDisplayJavascript: function () {
                    
				window.FpsDisplayJavascript = ((function () {
					'use strict';
					
					var numberOfFrames = 0;
					var hasAddedFpsLabel = false;
					var startTimeMillis = Date.now();
					var fpsNode = null;
					
					var frameComputedAndRendered = function () {
						numberOfFrames++;
					};
					
					var displayFps = function () {
						if (!hasAddedFpsLabel) {
							var fpsLabelNode = document.getElementById('fpsLabel');
							if (fpsLabelNode !== null) {
								fpsLabelNode.textContent = 'FPS: ';
								hasAddedFpsLabel = true;
							}
						}
						
						var currentTimeMillis = Date.now();
						if (currentTimeMillis - startTimeMillis > 2000) {
							var actualFps = numberOfFrames / 2;
							
							if (fpsNode === null)
								fpsNode = document.getElementById('fps');
							
							if (fpsNode !== null)
								fpsNode.textContent = actualFps.toString();
							
							numberOfFrames = 0;
							startTimeMillis = currentTimeMillis;
						}
					};
					
					return {
						frameComputedAndRendered: frameComputedAndRendered,
						displayFps: displayFps
					};
				})());
			
                },
                Initialize: function () {
                    
				((function () {
					'use strict';
					
					var isEmbeddedVersion = false;
					
					var stopWaitingEvenIfMusicHasNotLoaded = false;

					var canvasScalingFactor = 2;
										
					var isElectronVersion = !isEmbeddedVersion
						&& (window.navigator.userAgent.indexOf('Electron') >= 0 || window.navigator.userAgent.indexOf('electron') >= 0);
					
					var isLibrem5 = window.navigator.userAgent.toLowerCase().includes('aarch64')
						&& window.navigator.userAgent.toLowerCase().includes('linux')
						&& !window.navigator.userAgent.toLowerCase().includes('android');
					
					var defaultFps;
					if (isLibrem5)
						defaultFps = 20;
					else if (window.navigator.userAgent.indexOf('Gecko/') >= 0)
						defaultFps = 30;
					else
						defaultFps = 60;
					
					var urlParams = (new URL(document.location)).searchParams;
					
					var showFps = urlParams.get('showfps') !== null
						? (urlParams.get('showfps') === 'true')
						: false;
					var fps = urlParams.get('fps') !== null
						? parseInt(urlParams.get('fps'), 10)
						: defaultFps;
					var debugMode = urlParams.get('debugmode') !== null
						? (urlParams.get('debugmode') === 'true')
						: false;
					
					window.ChessCompStompWithHacks.GameInitializer.Start(fps, isEmbeddedVersion, isElectronVersion, canvasScalingFactor, stopWaitingEvenIfMusicHasNotLoaded, debugMode);
					
					var computeAndRenderNextFrame;
					
					var nextTimeToAct = Date.now() + (1000.0 / fps);
					
					var hasProcessedExtraTime = false;
					
					computeAndRenderNextFrame = function () {
						var now = Date.now();
						
						if (nextTimeToAct > now) {
							if (!hasProcessedExtraTime) {
								var extraTime = Math.round(nextTimeToAct - now);
								if (extraTime > 0)
									window.ChessCompStompWithHacks.GameInitializer.ProcessExtraTime(extraTime);
								hasProcessedExtraTime = true;
								setTimeout(computeAndRenderNextFrame, 0);
							} else {
								setTimeout(computeAndRenderNextFrame, 5);
							}
							return;
						}
						
						hasProcessedExtraTime = false;
						
						if (nextTimeToAct < now - 5.0*(1000.0 / fps))
							nextTimeToAct = now - 5.0*(1000.0 / fps);
						
						nextTimeToAct = nextTimeToAct + (1000.0 / fps);
						
						window.ChessCompStompWithHacks.GameInitializer.ComputeAndRenderNextFrame();
						window.FpsDisplayJavascript.frameComputedAndRendered();
						
						if (showFps)
							window.FpsDisplayJavascript.displayFps();
						
						setTimeout(computeAndRenderNextFrame, 0);
					};
					
					setTimeout(computeAndRenderNextFrame, 0);
				})());
			
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.AIPondering", {
        fields: {
            mapping: null,
            timer: null,
            random: null,
            logger: null,
            ponderingLogger: null,
            useDebugAI: false,
            hasFinishedPopulatingAIsToProcess: false,
            potentialPlayerMovesList: null,
            originalGameState: null,
            AIsToProcess: null,
            AIsCompleted: null,
            searchDepth: 0,
            searchTime: 0
        },
        ctors: {
            ctor: function (gameState, timer, random, logger, useDebugAI) {
                this.$initialize();
                var ponderingLogger = new ChessCompStompWithHacksEngine.AIPondering.PonderingLogger(logger);

                this.mapping = new (System.Collections.Generic.Dictionary$2(ChessCompStompWithHacksEngine.GameState,ChessCompStompWithHacksEngine.IChessAI))();
                this.timer = timer;
                this.random = random;
                this.logger = logger;
                this.ponderingLogger = ponderingLogger;
                this.useDebugAI = useDebugAI;

                this.AIsToProcess = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.IChessAI)).ctor();
                this.AIsCompleted = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.IChessAI)).ctor();
                this.searchDepth = 2;
                this.searchTime = 0;

                this.hasFinishedPopulatingAIsToProcess = false;
                this.potentialPlayerMovesList = ChessCompStompWithHacksEngine.ComputeMoves.GetMoves(gameState).Moves;
                this.originalGameState = gameState;
            }
        },
        methods: {
            GetAIForGameState: function (newGameState) {
                this.ponderingLogger.BeginLogging();

                if (this.mapping.containsKey(newGameState)) {
                    return this.mapping.get(newGameState);
                }

                return new ChessCompStompWithHacksEngine.CompositeAI(newGameState, this.timer, this.random, this.ponderingLogger, this.useDebugAI);
            },
            CalculateBestMove: function (millisecondsToThink) {
                this.searchTime = (this.searchTime + millisecondsToThink) | 0;

                if (!this.hasFinishedPopulatingAIsToProcess) {
                    var startingTimeMillis = this.timer.DTLibrary$ITimer$GetNumberOfMicroSeconds().div(System.Int64(1000));
                    var count = 0;

                    while (true) {
                        if (this.potentialPlayerMovesList.Count === 0) {
                            this.hasFinishedPopulatingAIsToProcess = true;
                            return;
                        }

                        count = (count + 1) | 0;
                        if (count === 3) {
                            count = 0;
                            var currentTimeMillis = this.timer.DTLibrary$ITimer$GetNumberOfMicroSeconds().div(System.Int64(1000));
                            var elapsedTimeAsLong = currentTimeMillis.sub(startingTimeMillis);
                            var elapsedTimeMillis = System.Int64.clip32(elapsedTimeAsLong);

                            if (elapsedTimeMillis >= millisecondsToThink) {
                                return;
                            }
                        }

                        var move = this.potentialPlayerMovesList.getItem(((this.potentialPlayerMovesList.Count - 1) | 0));

                        var newGameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(this.originalGameState, move);

                        var newGameStateMoveResult = ChessCompStompWithHacksEngine.ComputeMoves.GetMoves(newGameState);

                        if (newGameStateMoveResult.GameStatus === ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.InProgress) {
                            var ai = new ChessCompStompWithHacksEngine.CompositeAI(newGameState, this.timer, this.random, this.ponderingLogger, this.useDebugAI);
                            this.mapping.set(newGameState, ai);
                            this.AIsToProcess.add(ai);
                        }

                        this.potentialPlayerMovesList.removeAt(((this.potentialPlayerMovesList.Count - 1) | 0));
                    }
                }

                if (this.AIsToProcess.Count === 0) {
                    if (this.searchDepth <= 200 && this.AIsCompleted.Count > 0) {
                        this.AIsToProcess = this.AIsCompleted;
                        this.AIsCompleted = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.IChessAI)).ctor();

                        this.logger.DTLibrary$IDTLogger$WriteLine$1("Finished depth: " + (DTLibrary.StringUtil.ToStringCultureInvariant(this.searchDepth) || "") + " (" + (DTLibrary.StringUtil.ToStringCultureInvariant(this.searchTime) || "") + " ms)");

                        this.searchDepth = (this.searchDepth + 2) | 0;
                    }
                }

                if (this.AIsToProcess.Count > 0) {
                    var ai1 = this.AIsToProcess.getItem(((this.AIsToProcess.Count - 1) | 0));
                    ai1.ChessCompStompWithHacksEngine$IChessAI$CalculateBestMove(millisecondsToThink);

                    if (ai1.ChessCompStompWithHacksEngine$IChessAI$HasFinishedCalculation()) {
                        this.AIsToProcess.removeAt(((this.AIsToProcess.Count - 1) | 0));
                    } else {
                        if (ai1.ChessCompStompWithHacksEngine$IChessAI$GetDepthOfBestMoveFoundSoFar() >= this.searchDepth) {
                            this.AIsToProcess.removeAt(((this.AIsToProcess.Count - 1) | 0));
                            this.AIsCompleted.add(ai1);
                        }
                    }
                }
            }
        }
    });

    Bridge.define("DTLibrary.IDTLogger", {
        $kind: "interface"
    });

    Bridge.define("ChessCompStompWithHacksEngine.IChessAI", {
        $kind: "interface"
    });

    Bridge.define("ChessCompStompWithHacksEngine.CastlingUtil", {
        statics: {
            methods: {
                GetCastlingOrSuperCastlingMoveInfo: function (originalBoard, castlingMove) {
                    if (!ChessCompStompWithHacksEngine.MoveUtil.IsCastlingOrSuperCastling(castlingMove, originalBoard)) {
                        return null;
                    }

                    var originalLocationOfKing = new ChessCompStompWithHacksEngine.ChessSquare(System.Nullable.getValue(castlingMove.StartingFile), System.Nullable.getValue(castlingMove.StartingRank));

                    var direction;
                    if (((castlingMove.EndingFile - System.Nullable.getValue(castlingMove.StartingFile)) | 0) === 2) {
                        direction = { Item1: 1, Item2: 0 };
                    } else {
                        if (((castlingMove.EndingFile - System.Nullable.getValue(castlingMove.StartingFile)) | 0) === -2) {
                            direction = { Item1: -1, Item2: 0 };
                        } else {
                            if (((castlingMove.EndingRank - System.Nullable.getValue(castlingMove.StartingRank)) | 0) === 2) {
                                direction = { Item1: 0, Item2: 1 };
                            } else {
                                if (((castlingMove.EndingRank - System.Nullable.getValue(castlingMove.StartingRank)) | 0) === -2) {
                                    direction = { Item1: 0, Item2: -1 };
                                } else {
                                    throw new System.Exception();
                                }
                            }
                        }
                    }

                    var originalLocationOfRook = originalLocationOfKing;
                    while (true) {
                        originalLocationOfRook = new ChessCompStompWithHacksEngine.ChessSquare(((originalLocationOfRook.File + direction.Item1) | 0), ((originalLocationOfRook.Rank + direction.Item2) | 0));
                        if (ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsRook(originalBoard.GetPiece(originalLocationOfRook))) {
                            break;
                        }
                    }

                    return new ChessCompStompWithHacksEngine.CastlingUtil.CastlingInfo(originalLocationOfKing, new ChessCompStompWithHacksEngine.ChessSquare(castlingMove.EndingFile, castlingMove.EndingRank), originalLocationOfRook, new ChessCompStompWithHacksEngine.ChessSquare(((Bridge.Int.div((((System.Nullable.getValue(castlingMove.StartingFile) + castlingMove.EndingFile) | 0)), 2)) | 0), ((Bridge.Int.div((((System.Nullable.getValue(castlingMove.StartingRank) + castlingMove.EndingRank) | 0)), 2)) | 0)));
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.CastlingUtil.CastlingInfo", {
        $kind: "nested class",
        fields: {
            OriginalLocationOfKing: null,
            NewLocationOfKing: null,
            OriginalLocationOfRook: null,
            NewLocationOfRook: null
        },
        ctors: {
            ctor: function (originalLocationOfKing, newLocationOfKing, originalLocationOfRook, newLocationOfRook) {
                this.$initialize();
                this.OriginalLocationOfKing = originalLocationOfKing;
                this.NewLocationOfKing = newLocationOfKing;
                this.OriginalLocationOfRook = originalLocationOfRook;
                this.NewLocationOfRook = newLocationOfRook;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.CheckKingUnderAttack", {
        statics: {
            methods: {
                FindLocationOfKing: function (board, findWhiteKing) {
                    for (var i = 0; i < 8; i = (i + 1) | 0) {
                        for (var j = 0; j < 8; j = (j + 1) | 0) {
                            var piece = board.GetPiece$1(i, j);
                            if (piece !== ChessCompStompWithHacksEngine.ChessSquarePiece.Empty && ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsKing(piece) && ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsWhite(piece) === findWhiteKing) {
                                return new ChessCompStompWithHacksEngine.ChessSquare(i, j);
                            }
                        }
                    }

                    throw new System.Exception();
                },
                /**
                 * Note that this method is used (in part) to determine whether a move is legal.
                 So the board input may represent an invalid board position; e.g. maybe both
                 kings are in check, or the kings are adjacent to each other, etc.
                 *
                 * @static
                 * @public
                 * @this ChessCompStompWithHacksEngine.CheckKingUnderAttack
                 * @memberof ChessCompStompWithHacksEngine.CheckKingUnderAttack
                 * @param   {ChessCompStompWithHacksEngine.ChessSquarePieceArray}        board                        
                 * @param   {ChessCompStompWithHacksEngine.GameState.PlayerAbilities}    playerAbilities              
                 * @param   {boolean}                                                    checkWhiteKingUnderAttack    
                 * @param   {boolean}                                                    isPlayerWhite                
                 * @param   {number}                                                     kingFile                     
                 * @param   {number}                                                     kingRank
                 * @return  {boolean}
                 */
                IsKingUnderThreat: function (board, playerAbilities, checkWhiteKingUnderAttack, isPlayerWhite, kingFile, kingRank) {
                    var isKingAttackedByPawn = ChessCompStompWithHacksEngine.CheckKingUnderAttack.IsKingUnderThreatByPawn(board, playerAbilities, checkWhiteKingUnderAttack, isPlayerWhite, kingFile, kingRank);

                    if (isKingAttackedByPawn) {
                        return true;
                    }

                    var isKingAttackedFromEightDirections = ChessCompStompWithHacksEngine.CheckKingUnderAttack.IsKingUnderThreatFromEightDirections(board, playerAbilities, checkWhiteKingUnderAttack, isPlayerWhite, kingFile, kingRank);

                    if (isKingAttackedFromEightDirections) {
                        return true;
                    }

                    var isKingAttackedViaKnightMove = ChessCompStompWithHacksEngine.CheckKingUnderAttack.IsKingUnderThreatByKnightOrLargeKnightMove(board, playerAbilities, checkWhiteKingUnderAttack, isPlayerWhite, kingFile, kingRank);

                    if (isKingAttackedViaKnightMove) {
                        return true;
                    }

                    return false;
                },
                IsKingUnderThreatByPawn: function (board, playerAbilities, checkWhiteKingUnderAttack, isPlayerWhite, kingFile, kingRank) {
                    if (checkWhiteKingUnderAttack) {
                        var pawnFile = (kingFile - 1) | 0;
                        var pawnRank = (kingRank + 1) | 0;

                        if (ChessCompStompWithHacksEngine.CheckKingUnderAttack.InRange(pawnFile) && ChessCompStompWithHacksEngine.CheckKingUnderAttack.InRange(pawnRank) && board.GetPiece$1(pawnFile, pawnRank) === ChessCompStompWithHacksEngine.ChessSquarePiece.BlackPawn) {
                            return true;
                        }

                        pawnFile = (kingFile + 1) | 0;
                        pawnRank = (kingRank + 1) | 0;

                        if (ChessCompStompWithHacksEngine.CheckKingUnderAttack.InRange(pawnFile) && ChessCompStompWithHacksEngine.CheckKingUnderAttack.InRange(pawnRank) && board.GetPiece$1(pawnFile, pawnRank) === ChessCompStompWithHacksEngine.ChessSquarePiece.BlackPawn) {
                            return true;
                        }

                        if (!isPlayerWhite && playerAbilities.CanSuperEnPassant) {
                            pawnFile = (kingFile - 1) | 0;
                            pawnRank = kingRank;
                            if (ChessCompStompWithHacksEngine.CheckKingUnderAttack.InRange(pawnFile) && ChessCompStompWithHacksEngine.CheckKingUnderAttack.InRange(pawnRank) && board.GetPiece$1(pawnFile, pawnRank) === ChessCompStompWithHacksEngine.ChessSquarePiece.BlackPawn && ChessCompStompWithHacksEngine.CheckKingUnderAttack.InRange(((kingRank - 1) | 0)) && ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsBlack(board.GetPiece$1(kingFile, ((kingRank - 1) | 0))) === false) {
                                return true;
                            }

                            pawnFile = (kingFile + 1) | 0;
                            pawnRank = kingRank;
                            if (ChessCompStompWithHacksEngine.CheckKingUnderAttack.InRange(pawnFile) && ChessCompStompWithHacksEngine.CheckKingUnderAttack.InRange(pawnRank) && board.GetPiece$1(pawnFile, pawnRank) === ChessCompStompWithHacksEngine.ChessSquarePiece.BlackPawn && ChessCompStompWithHacksEngine.CheckKingUnderAttack.InRange(((kingRank - 1) | 0)) && ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsBlack(board.GetPiece$1(kingFile, ((kingRank - 1) | 0))) === false) {
                                return true;
                            }
                        }
                    } else {
                        var pawnFile1 = (kingFile - 1) | 0;
                        var pawnRank1 = (kingRank - 1) | 0;

                        if (ChessCompStompWithHacksEngine.CheckKingUnderAttack.InRange(pawnFile1) && ChessCompStompWithHacksEngine.CheckKingUnderAttack.InRange(pawnRank1) && board.GetPiece$1(pawnFile1, pawnRank1) === ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn) {
                            return true;
                        }

                        pawnFile1 = (kingFile + 1) | 0;
                        pawnRank1 = (kingRank - 1) | 0;

                        if (ChessCompStompWithHacksEngine.CheckKingUnderAttack.InRange(pawnFile1) && ChessCompStompWithHacksEngine.CheckKingUnderAttack.InRange(pawnRank1) && board.GetPiece$1(pawnFile1, pawnRank1) === ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn) {
                            return true;
                        }

                        if (isPlayerWhite && playerAbilities.CanSuperEnPassant) {
                            pawnFile1 = (kingFile - 1) | 0;
                            pawnRank1 = kingRank;
                            if (ChessCompStompWithHacksEngine.CheckKingUnderAttack.InRange(pawnFile1) && ChessCompStompWithHacksEngine.CheckKingUnderAttack.InRange(pawnRank1) && board.GetPiece$1(pawnFile1, pawnRank1) === ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn && ChessCompStompWithHacksEngine.CheckKingUnderAttack.InRange(((kingRank + 1) | 0)) && ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsWhite(board.GetPiece$1(kingFile, ((kingRank + 1) | 0))) === false) {
                                return true;
                            }

                            pawnFile1 = (kingFile + 1) | 0;
                            pawnRank1 = kingRank;
                            if (ChessCompStompWithHacksEngine.CheckKingUnderAttack.InRange(pawnFile1) && ChessCompStompWithHacksEngine.CheckKingUnderAttack.InRange(pawnRank1) && board.GetPiece$1(pawnFile1, pawnRank1) === ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn && ChessCompStompWithHacksEngine.CheckKingUnderAttack.InRange(((kingRank + 1) | 0)) && ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsWhite(board.GetPiece$1(kingFile, ((kingRank + 1) | 0))) === false) {
                                return true;
                            }
                        }
                    }

                    return false;
                },
                IsKingUnderThreatFromEightDirections: function (board, playerAbilities, checkWhiteKingUnderAttack, isPlayerWhite, kingFile, kingRank) {
                    var $t, $t1;
                    var shouldCheckRookCannon = playerAbilities.CanRooksCaptureLikeCannons && (isPlayerWhite && !checkWhiteKingUnderAttack || !isPlayerWhite && checkWhiteKingUnderAttack);

                    var enemyKing = checkWhiteKingUnderAttack ? ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKing : ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKing;
                    var enemyQueen = checkWhiteKingUnderAttack ? ChessCompStompWithHacksEngine.ChessSquarePiece.BlackQueen : ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteQueen;
                    var enemyRook = checkWhiteKingUnderAttack ? ChessCompStompWithHacksEngine.ChessSquarePiece.BlackRook : ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook;
                    var enemyBishop = checkWhiteKingUnderAttack ? ChessCompStompWithHacksEngine.ChessSquarePiece.BlackBishop : ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteBishop;

                    var piecesThatAttackHorizontallyOrVertically = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquarePiece)).ctor();
                    piecesThatAttackHorizontallyOrVertically.add(enemyRook);
                    piecesThatAttackHorizontallyOrVertically.add(enemyQueen);

                    var piecesThatAttackDiagonally = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquarePiece)).ctor();
                    piecesThatAttackDiagonally.add(enemyBishop);
                    piecesThatAttackDiagonally.add(enemyQueen);
                    if (playerAbilities.CanRooksMoveLikeBishops && (isPlayerWhite && !checkWhiteKingUnderAttack || !isPlayerWhite && checkWhiteKingUnderAttack)) {
                        piecesThatAttackDiagonally.add(enemyRook);
                    }

                    var deltas = new (System.Collections.Generic.List$1(System.Tuple$3(System.Int32,System.Int32,System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquarePiece)))).ctor();
                    deltas.add({ Item1: 1, Item2: 0, Item3: piecesThatAttackHorizontallyOrVertically });
                    deltas.add({ Item1: -1, Item2: 0, Item3: piecesThatAttackHorizontallyOrVertically });
                    deltas.add({ Item1: 0, Item2: 1, Item3: piecesThatAttackHorizontallyOrVertically });
                    deltas.add({ Item1: 0, Item2: -1, Item3: piecesThatAttackHorizontallyOrVertically });
                    deltas.add({ Item1: 1, Item2: 1, Item3: piecesThatAttackDiagonally });
                    deltas.add({ Item1: 1, Item2: -1, Item3: piecesThatAttackDiagonally });
                    deltas.add({ Item1: -1, Item2: 1, Item3: piecesThatAttackDiagonally });
                    deltas.add({ Item1: -1, Item2: -1, Item3: piecesThatAttackDiagonally });

                    $t = Bridge.getEnumerator(deltas);
                    try {
                        while ($t.moveNext()) {
                            var delta = $t.Current;
                            var i = kingFile;
                            var j = kingRank;
                            var isFirstIteration = true;
                            while (true) {
                                i = (i + delta.Item1) | 0;
                                j = (j + delta.Item2) | 0;

                                if (i < 0 || i >= 8 || j < 0 || j >= 8) {
                                    break;
                                }

                                var pieceAtThisSquare = board.GetPiece$1(i, j);
                                if (pieceAtThisSquare !== ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                                    $t1 = Bridge.getEnumerator(delta.Item3);
                                    try {
                                        while ($t1.moveNext()) {
                                            var enemyPiece = $t1.Current;
                                            if (pieceAtThisSquare === enemyPiece) {
                                                return true;
                                            }
                                        }
                                    } finally {
                                        if (Bridge.is($t1, System.IDisposable)) {
                                            $t1.System$IDisposable$Dispose();
                                        }
                                    }

                                    if (isFirstIteration && pieceAtThisSquare === enemyKing) {
                                        return true;
                                    }
                                }

                                isFirstIteration = false;

                                if (pieceAtThisSquare !== ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                                    if (shouldCheckRookCannon && delta.Item3.contains(enemyRook)) {
                                        while (true) {
                                            i = (i + delta.Item1) | 0;
                                            j = (j + delta.Item2) | 0;
                                            if (i < 0 || i >= 8 || j < 0 || j >= 8) {
                                                break;
                                            }

                                            if (board.GetPiece$1(i, j) === enemyRook) {
                                                return true;
                                            }

                                            if (board.GetPiece$1(i, j) !== ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                                                break;
                                            }
                                        }
                                    }

                                    break;
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    return false;
                },
                IsKingUnderThreatByKnightOrLargeKnightMove: function (board, playerAbilities, checkWhiteKingUnderAttack, isPlayerWhite, kingFile, kingRank) {
                    var $t;
                    var deltas = new (System.Collections.Generic.List$1(System.Tuple$2(System.Int32,System.Int32))).ctor();
                    deltas.add({ Item1: 2, Item2: 1 });
                    deltas.add({ Item1: 1, Item2: 2 });
                    deltas.add({ Item1: 2, Item2: -1 });
                    deltas.add({ Item1: 1, Item2: -2 });
                    deltas.add({ Item1: -2, Item2: 1 });
                    deltas.add({ Item1: -1, Item2: 2 });
                    deltas.add({ Item1: -2, Item2: -1 });
                    deltas.add({ Item1: -1, Item2: -2 });

                    if (playerAbilities.CanKnightsMakeLargeKnightsMove && (checkWhiteKingUnderAttack && !isPlayerWhite || !checkWhiteKingUnderAttack && isPlayerWhite)) {
                        deltas.add({ Item1: 3, Item2: 1 });
                        deltas.add({ Item1: 1, Item2: 3 });
                        deltas.add({ Item1: 3, Item2: -1 });
                        deltas.add({ Item1: 1, Item2: -3 });
                        deltas.add({ Item1: -3, Item2: 1 });
                        deltas.add({ Item1: -1, Item2: 3 });
                        deltas.add({ Item1: -3, Item2: -1 });
                        deltas.add({ Item1: -1, Item2: -3 });
                    }

                    var enemyKnight = checkWhiteKingUnderAttack ? ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKnight : ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKnight;
                    var enemyQueen = checkWhiteKingUnderAttack ? ChessCompStompWithHacksEngine.ChessSquarePiece.BlackQueen : ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteQueen;

                    $t = Bridge.getEnumerator(deltas);
                    try {
                        while ($t.moveNext()) {
                            var delta = $t.Current;
                            var i = (kingFile + delta.Item1) | 0;
                            var j = (kingRank + delta.Item2) | 0;

                            if (i < 0 || i >= 8 || j < 0 || j >= 8) {
                                continue;
                            }

                            if (board.GetPiece$1(i, j) === enemyKnight) {
                                return true;
                            }

                            if (playerAbilities.CanQueensMoveLikeKnights && (checkWhiteKingUnderAttack && !isPlayerWhite || !checkWhiteKingUnderAttack && isPlayerWhite) && board.GetPiece$1(i, j) === enemyQueen) {
                                return true;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    return false;
                },
                InRange: function (x) {
                    return 0 <= x && x < 8;
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.ChessSquare", {
        inherits: function () { return [System.IEquatable$1(ChessCompStompWithHacksEngine.ChessSquare)]; },
        fields: {
            File: 0,
            Rank: 0
        },
        alias: ["equalsT", "System$IEquatable$1$ChessCompStompWithHacksEngine$ChessSquare$equalsT"],
        ctors: {
            ctor: function (file, rank) {
                this.$initialize();
                this.File = file;
                this.Rank = rank;
            }
        },
        methods: {
            equals: function (obj) {
                return this.equalsT(Bridge.as(obj, ChessCompStompWithHacksEngine.ChessSquare));
            },
            equalsT: function (other) {
                return other != null && this.File === other.File && this.Rank === other.Rank;
            },
            getHashCode: function () {
                return (((this.File << 3) + this.Rank) | 0);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.ChessSquarePiece", {
        $kind: "enum",
        statics: {
            fields: {
                BlackPawn: 0,
                BlackKnight: 1,
                BlackBishop: 2,
                BlackRook: 3,
                BlackQueen: 4,
                BlackKing: 5,
                WhitePawn: 6,
                WhiteKnight: 7,
                WhiteBishop: 8,
                WhiteRook: 9,
                WhiteQueen: 10,
                WhiteKing: 11,
                Empty: 12
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.ChessSquarePieceArray", {
        inherits: function () { return [System.IEquatable$1(ChessCompStompWithHacksEngine.ChessSquarePieceArray)]; },
        statics: {
            methods: {
                EmptyBoard: function () {
                    var $t;
                    var returnValue = new ChessCompStompWithHacksEngine.ChessSquarePieceArray.ctor();

                    returnValue.board = System.Array.init(8, null, System.Array.type(ChessCompStompWithHacksEngine.ChessSquarePiece));
                    for (var i = 0; i < 8; i = (i + 1) | 0) {
                        returnValue.board[System.Array.index(i, returnValue.board)] = System.Array.init(8, 0, ChessCompStompWithHacksEngine.ChessSquarePiece);
                        for (var j = 0; j < 8; j = (j + 1) | 0) {
                            ($t = returnValue.board[System.Array.index(i, returnValue.board)])[System.Array.index(j, $t)] = ChessCompStompWithHacksEngine.ChessSquarePiece.Empty;
                        }
                    }

                    return returnValue;
                },
                CopyBoard: function (board) {
                    var $t, $t1;
                    var newBoard = System.Array.init(8, null, System.Array.type(ChessCompStompWithHacksEngine.ChessSquarePiece));
                    for (var i = 0; i < 8; i = (i + 1) | 0) {
                        newBoard[System.Array.index(i, newBoard)] = System.Array.init(8, 0, ChessCompStompWithHacksEngine.ChessSquarePiece);
                        for (var j = 0; j < 8; j = (j + 1) | 0) {
                            ($t = newBoard[System.Array.index(i, newBoard)])[System.Array.index(j, $t)] = ($t1 = board[System.Array.index(i, board)])[System.Array.index(j, $t1)];
                        }
                    }

                    return newBoard;
                }
            }
        },
        fields: {
            board: null,
            hashCode: null
        },
        alias: ["equalsT", "System$IEquatable$1$ChessCompStompWithHacksEngine$ChessSquarePieceArray$equalsT"],
        ctors: {
            ctor: function () {
                this.$initialize();
                this.board = null;
                this.hashCode = null;
            },
            $ctor1: function (board) {
                this.$initialize();
                this.board = ChessCompStompWithHacksEngine.ChessSquarePieceArray.CopyBoard(board);
                this.hashCode = null;
            }
        },
        methods: {
            GetPiece$1: function (file, rank) {
                var $t;
                return ($t = this.board[System.Array.index(file, this.board)])[System.Array.index(rank, $t)];
            },
            GetPiece: function (chessSquare) {
                var $t;
                return ($t = this.board[System.Array.index(chessSquare.File, this.board)])[System.Array.index(chessSquare.Rank, $t)];
            },
            SetPiece: function (file, rank, piece) {
                var $t, $t1, $t2;
                var newBoard = System.Array.init(8, null, System.Array.type(ChessCompStompWithHacksEngine.ChessSquarePiece));

                for (var i = 0; i < 8; i = (i + 1) | 0) {
                    if (i !== file) {
                        newBoard[System.Array.index(i, newBoard)] = this.board[System.Array.index(i, this.board)];
                    } else {
                        newBoard[System.Array.index(i, newBoard)] = System.Array.init(8, 0, ChessCompStompWithHacksEngine.ChessSquarePiece);
                        for (var j = 0; j < 8; j = (j + 1) | 0) {
                            ($t = newBoard[System.Array.index(i, newBoard)])[System.Array.index(j, $t)] = ($t1 = this.board[System.Array.index(i, this.board)])[System.Array.index(j, $t1)];
                        }
                        ($t2 = newBoard[System.Array.index(i, newBoard)])[System.Array.index(rank, $t2)] = piece;
                    }
                }

                var returnValue = new ChessCompStompWithHacksEngine.ChessSquarePieceArray.ctor();
                returnValue.board = newBoard;

                return returnValue;
            },
            equals: function (obj) {
                return this.equalsT(Bridge.as(obj, ChessCompStompWithHacksEngine.ChessSquarePieceArray));
            },
            equalsT: function (other) {
                var $t, $t1;
                if (other == null) {
                    return false;
                }

                if (Bridge.referenceEquals(this, other)) {
                    return true;
                }

                for (var i = 0; i < 8; i = (i + 1) | 0) {
                    for (var j = 0; j < 8; j = (j + 1) | 0) {
                        if (($t = this.board[System.Array.index(i, this.board)])[System.Array.index(j, $t)] !== ($t1 = other.board[System.Array.index(i, other.board)])[System.Array.index(j, $t1)]) {
                            return false;
                        }
                    }
                }

                return true;
            },
            getHashCode: function () {
                var $t;
                if (System.Nullable.hasValue(this.hashCode)) {
                    return System.Nullable.getValue(this.hashCode);
                }

                var hashCode = 0;

                for (var i = 0; i < 8; i = (i + 1) | 0) {
                    for (var j = 0; j < 8; j = (j + 1) | 0) {
                        hashCode = Bridge.Int.mul(hashCode, 31);
                        var pieceHashCode = ChessCompStompWithHacksEngine.ChessSquarePieceUtil.GetValueForHashCode(($t = this.board[System.Array.index(i, this.board)])[System.Array.index(j, $t)]);
                        hashCode = ((hashCode + pieceHashCode) | 0);
                    }
                }

                this.hashCode = hashCode;
                return System.Nullable.getValue(this.hashCode);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.ChessSquarePieceUtil", {
        statics: {
            methods: {
                GetValueForHashCode: function (piece) {
                    switch (piece) {
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackPawn: 
                            return 1;
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKnight: 
                            return 2;
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackBishop: 
                            return 3;
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackRook: 
                            return 4;
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackQueen: 
                            return 5;
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKing: 
                            return 6;
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn: 
                            return 7;
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKnight: 
                            return 8;
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteBishop: 
                            return 9;
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook: 
                            return 10;
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteQueen: 
                            return 11;
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKing: 
                            return 12;
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.Empty: 
                            return 13;
                        default: 
                            throw new System.Exception();
                    }
                },
                IsPawn: function (piece) {
                    return piece === ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn || piece === ChessCompStompWithHacksEngine.ChessSquarePiece.BlackPawn;
                },
                IsRook: function (piece) {
                    return piece === ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook || piece === ChessCompStompWithHacksEngine.ChessSquarePiece.BlackRook;
                },
                IsKnight: function (piece) {
                    return piece === ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKnight || piece === ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKnight;
                },
                IsBishop: function (piece) {
                    return piece === ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteBishop || piece === ChessCompStompWithHacksEngine.ChessSquarePiece.BlackBishop;
                },
                IsQueen: function (piece) {
                    return piece === ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteQueen || piece === ChessCompStompWithHacksEngine.ChessSquarePiece.BlackQueen;
                },
                IsKing: function (piece) {
                    return piece === ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKing || piece === ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKing;
                },
                IsWhite: function (piece) {
                    switch (piece) {
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackPawn: 
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKnight: 
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackBishop: 
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackRook: 
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackQueen: 
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKing: 
                            return false;
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn: 
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKnight: 
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteBishop: 
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook: 
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteQueen: 
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKing: 
                            return true;
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.Empty: 
                            return false;
                        default: 
                            throw new System.Exception();
                    }
                },
                IsBlack: function (piece) {
                    if (piece === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                        return false;
                    }

                    return !ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsWhite(piece);
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.ComputeMoves", {
        statics: {
            methods: {
                GetMoves: function (gameState) {
                    var $t;
                    var kingFile = -1;
                    var kingRank = -1;

                    var king = gameState.IsWhiteTurn ? ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKing : ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKing;

                    for (var i = 0; i < 8; i = (i + 1) | 0) {
                        for (var j = 0; j < 8; j = (j + 1) | 0) {
                            if (gameState.Board.GetPiece$1(i, j) === king) {
                                kingFile = i;
                                kingRank = j;
                                break;
                            }
                        }

                        if (kingFile !== -1) {
                            break;
                        }
                    }

                    if (kingFile === -1) {
                        throw new System.Exception();
                    }

                    var moves = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ComputeMoves.MoveInfo)).ctor();

                    for (var i1 = 0; i1 < 8; i1 = (i1 + 1) | 0) {
                        for (var j1 = 0; j1 < 8; j1 = (j1 + 1) | 0) {
                            var piece = gameState.Board.GetPiece$1(i1, j1);

                            if (gameState.IsWhiteTurn) {
                                if (!ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsWhite(piece)) {
                                    continue;
                                }
                            } else {
                                if (!ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsBlack(piece)) {
                                    continue;
                                }
                            }

                            switch (piece) {
                                case ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn: 
                                case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackPawn: 
                                    ChessCompStompWithHacksEngine.ComputeMovesPawn.AddPawnMoves(gameState, i1, j1, kingFile, kingRank, moves);
                                    break;
                                case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook: 
                                case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackRook: 
                                    ChessCompStompWithHacksEngine.ComputeMovesRook.AddRookMoves(gameState, i1, j1, kingFile, kingRank, moves);
                                    break;
                                case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKnight: 
                                case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKnight: 
                                    ChessCompStompWithHacksEngine.ComputeMovesKnight.AddKnightMoves(gameState, i1, j1, kingFile, kingRank, moves);
                                    break;
                                case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteBishop: 
                                case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackBishop: 
                                    ChessCompStompWithHacksEngine.ComputeMovesBishop.AddBishopMoves(gameState, i1, j1, kingFile, kingRank, moves);
                                    break;
                                case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteQueen: 
                                case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackQueen: 
                                    ChessCompStompWithHacksEngine.ComputeMovesQueen.AddQueenMoves(gameState, i1, j1, kingFile, kingRank, moves);
                                    break;
                                case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKing: 
                                case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKing: 
                                    ChessCompStompWithHacksEngine.ComputeMovesKing.AddKingMoves(gameState, i1, j1, moves);
                                    break;
                                case ChessCompStompWithHacksEngine.ChessSquarePiece.Empty: 
                                    break;
                                default: 
                                    throw new System.Exception();
                            }
                        }
                    }

                    ChessCompStompWithHacksEngine.ComputeMovesTacticalNuke.AddTacticalNukeMoves(gameState, kingFile, kingRank, moves);

                    if (!gameState.IsPlayerTurn() && gameState.Abilities.HasOpponentMustCaptureWhenPossible) {
                        var captureMoves = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ComputeMoves.MoveInfo)).ctor();
                        $t = Bridge.getEnumerator(moves);
                        try {
                            while ($t.moveNext()) {
                                var move = $t.Current;
                                if (move.IsCaptureMove) {
                                    captureMoves.add(move);
                                }
                            }
                        } finally {
                            if (Bridge.is($t, System.IDisposable)) {
                                $t.System$IDisposable$Dispose();
                            }
                        }

                        if (captureMoves.Count > 0) {
                            moves = captureMoves;
                        }
                    }

                    var gameStatus = new ChessCompStompWithHacksEngine.ComputeMoves.GameStatus();

                    if (moves.Count > 0) {
                        gameStatus = ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.InProgress;
                    } else {
                        var isKingUnderThreat = ChessCompStompWithHacksEngine.CheckKingUnderAttack.IsKingUnderThreat(gameState.Board, gameState.Abilities, gameState.IsWhiteTurn, gameState.IsPlayerWhite, kingFile, kingRank);

                        if (isKingUnderThreat) {
                            gameStatus = gameState.IsWhiteTurn ? ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.BlackVictory : ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.WhiteVictory;
                        } else {
                            if (gameState.Abilities.HasStalemateIsVictory) {
                                gameStatus = gameState.IsPlayerWhite ? ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.WhiteVictory : ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.BlackVictory;
                            } else {
                                gameStatus = ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.Stalemate;
                            }
                        }
                    }

                    var returnValue = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.Move)).$ctor2(moves.Count);
                    for (var i2 = 0; i2 < moves.Count; i2 = (i2 + 1) | 0) {
                        returnValue.add(moves.getItem(i2).Move);
                    }

                    return new ChessCompStompWithHacksEngine.ComputeMoves.Result(returnValue, gameStatus);
                },
                AddMoveInfosForNonEnPassantNonCastlingMoves: function (startingFile, startingRank, endingFile, endingRank, piece, gameState, kingFile, kingRank, moves) {
                    var isCaptureMove = gameState.Board.GetPiece$1(endingFile, endingRank) !== ChessCompStompWithHacksEngine.ChessSquarePiece.Empty;

                    var shouldDestroyPiece = isCaptureMove && !gameState.IsPlayerTurn() && gameState.Abilities.HasPawnsDestroyCapturingPiece && ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsPawn(gameState.Board.GetPiece$1(endingFile, endingRank));

                    var newBoard = gameState.Board.SetPiece(endingFile, endingRank, shouldDestroyPiece ? ChessCompStompWithHacksEngine.ChessSquarePiece.Empty : (gameState.IsWhiteTurn ? ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook : ChessCompStompWithHacksEngine.ChessSquarePiece.BlackRook)).SetPiece(startingFile, startingRank, ChessCompStompWithHacksEngine.ChessSquarePiece.Empty);

                    if (ChessCompStompWithHacksEngine.CheckKingUnderAttack.IsKingUnderThreat(newBoard, gameState.Abilities, gameState.IsWhiteTurn, gameState.IsPlayerWhite, kingFile, kingRank)) {
                        return;
                    }

                    if (gameState.IsWhiteTurn) {
                        var isPromotion;

                        if (ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsPawn(piece) && endingRank === 7) {
                            isPromotion = true;
                        } else {
                            if (gameState.IsPlayerWhite && gameState.Abilities.HasAnyPieceCanPromote && (ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsRook(piece) || ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsKnight(piece) || ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsBishop(piece) || ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsQueen(piece)) && endingRank === 7) {
                                isPromotion = true;
                            } else {
                                isPromotion = false;
                            }
                        }

                        if (isPromotion) {
                            ChessCompStompWithHacksEngine.ComputeMoves.AddPromotionMoveInfos(startingFile, startingRank, endingFile, endingRank, isCaptureMove, moves);
                        } else {
                            moves.add(new ChessCompStompWithHacksEngine.ComputeMoves.MoveInfo(ChessCompStompWithHacksEngine.Move.NormalMove(startingFile, startingRank, endingFile, endingRank), isCaptureMove));
                        }
                    } else {
                        var isPromotion1;

                        if (ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsPawn(piece) && endingRank === 0) {
                            isPromotion1 = true;
                        } else {
                            if (!gameState.IsPlayerWhite && gameState.Abilities.HasAnyPieceCanPromote && (ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsRook(piece) || ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsKnight(piece) || ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsBishop(piece) || ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsQueen(piece)) && endingRank === 0) {
                                isPromotion1 = true;
                            } else {
                                isPromotion1 = false;
                            }
                        }

                        if (isPromotion1) {
                            ChessCompStompWithHacksEngine.ComputeMoves.AddPromotionMoveInfos(startingFile, startingRank, endingFile, endingRank, isCaptureMove, moves);
                        } else {
                            moves.add(new ChessCompStompWithHacksEngine.ComputeMoves.MoveInfo(ChessCompStompWithHacksEngine.Move.NormalMove(startingFile, startingRank, endingFile, endingRank), isCaptureMove));
                        }
                    }
                },
                AddPromotionMoveInfos: function (startingFile, startingRank, endingFile, endingRank, isCaptureMove, moves) {
                    moves.add(new ChessCompStompWithHacksEngine.ComputeMoves.MoveInfo(ChessCompStompWithHacksEngine.Move.PromotionMove(startingFile, startingRank, endingFile, endingRank, ChessCompStompWithHacksEngine.Move.PromotionType.PromoteToRook), isCaptureMove));
                    moves.add(new ChessCompStompWithHacksEngine.ComputeMoves.MoveInfo(ChessCompStompWithHacksEngine.Move.PromotionMove(startingFile, startingRank, endingFile, endingRank, ChessCompStompWithHacksEngine.Move.PromotionType.PromoteToKnight), isCaptureMove));
                    moves.add(new ChessCompStompWithHacksEngine.ComputeMoves.MoveInfo(ChessCompStompWithHacksEngine.Move.PromotionMove(startingFile, startingRank, endingFile, endingRank, ChessCompStompWithHacksEngine.Move.PromotionType.PromoteToBishop), isCaptureMove));
                    moves.add(new ChessCompStompWithHacksEngine.ComputeMoves.MoveInfo(ChessCompStompWithHacksEngine.Move.PromotionMove(startingFile, startingRank, endingFile, endingRank, ChessCompStompWithHacksEngine.Move.PromotionType.PromoteToQueen), isCaptureMove));
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.ComputeMoves.GameStatus", {
        $kind: "nested enum",
        statics: {
            fields: {
                InProgress: 0,
                Stalemate: 1,
                WhiteVictory: 2,
                BlackVictory: 3
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.ComputeMoves.MoveInfo", {
        $kind: "nested class",
        fields: {
            Move: null,
            IsCaptureMove: false
        },
        ctors: {
            ctor: function (move, isCaptureMove) {
                this.$initialize();
                this.Move = move;
                this.IsCaptureMove = isCaptureMove;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.ComputeMoves.Result", {
        $kind: "nested class",
        fields: {
            Moves: null,
            GameStatus: 0
        },
        ctors: {
            ctor: function (moves, gameStatus) {
                this.$initialize();
                this.Moves = moves;
                this.GameStatus = gameStatus;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.ComputeMovesBishop", {
        statics: {
            methods: {
                AddBishopMoves: function (gameState, i, j, kingFile, kingRank, moves) {
                    var $t;
                    var piece = gameState.IsWhiteTurn ? ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteBishop : ChessCompStompWithHacksEngine.ChessSquarePiece.BlackBishop;

                    var deltas = new (System.Collections.Generic.List$1(System.Tuple$2(System.Int32,System.Int32))).ctor();
                    deltas.add({ Item1: 1, Item2: 1 });
                    deltas.add({ Item1: 1, Item2: -1 });
                    deltas.add({ Item1: -1, Item2: 1 });
                    deltas.add({ Item1: -1, Item2: -1 });

                    $t = Bridge.getEnumerator(deltas);
                    try {
                        while ($t.moveNext()) {
                            var delta = $t.Current;
                            var endI = i;
                            var endJ = j;
                            while (true) {
                                endI = (endI + delta.Item1) | 0;
                                endJ = (endJ + delta.Item2) | 0;
                                if (endI < 0 || endI >= 8 || endJ < 0 || endJ >= 8) {
                                    break;
                                }

                                var pieceAtDestination = gameState.Board.GetPiece$1(endI, endJ);

                                if (gameState.IsWhiteTurn && !ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsWhite(pieceAtDestination) || !gameState.IsWhiteTurn && !ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsBlack(pieceAtDestination)) {
                                    ChessCompStompWithHacksEngine.ComputeMoves.AddMoveInfosForNonEnPassantNonCastlingMoves(i, j, endI, endJ, piece, gameState, kingFile, kingRank, moves);
                                }

                                if (pieceAtDestination !== ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                                    break;
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.ComputeMovesKing", {
        statics: {
            methods: {
                AddKingMoves: function (gameState, i, j, moves) {
                    ChessCompStompWithHacksEngine.ComputeMovesKing.AddNonCastlingKingMoves(gameState, i, j, moves);

                    var canSuperCastle = gameState.IsPlayerTurn() && gameState.Abilities.CanSuperCastle;

                    if (canSuperCastle) {
                        ChessCompStompWithHacksEngine.ComputeMovesKing.AddSuperCastlingKingMoves(gameState, i, j, moves);
                    } else {
                        ChessCompStompWithHacksEngine.ComputeMovesKing.AddNormalCastlingKingMoves(gameState, i, j, moves);
                    }
                },
                AddNormalCastlingKingMoves: function (gameState, i, j, moves) {
                    var friendlyKing = gameState.IsWhiteTurn ? ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKing : ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKing;
                    var friendlyRook = gameState.IsWhiteTurn ? ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook : ChessCompStompWithHacksEngine.ChessSquarePiece.BlackRook;

                    var backRank = gameState.IsWhiteTurn ? 0 : 7;

                    var canNormalCastleKingside = gameState.IsWhiteTurn ? gameState.Castling.CanWhiteCastleKingside : gameState.Castling.CanBlackCastleKingside;

                    var canNormalCastleQueenside = gameState.IsWhiteTurn ? gameState.Castling.CanWhiteCastleQueenside : gameState.Castling.CanBlackCastleQueenside;

                    if (canNormalCastleKingside) {
                        if (gameState.Board.GetPiece$1(4, backRank) === friendlyKing && gameState.Board.GetPiece$1(5, backRank) === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty && gameState.Board.GetPiece$1(6, backRank) === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty && gameState.Board.GetPiece$1(7, backRank) === friendlyRook) {
                            var interimBoard = gameState.Board.SetPiece(4, backRank, ChessCompStompWithHacksEngine.ChessSquarePiece.Empty).SetPiece(5, backRank, friendlyKing);
                            var newBoard = gameState.Board.SetPiece(4, backRank, ChessCompStompWithHacksEngine.ChessSquarePiece.Empty).SetPiece(5, backRank, friendlyRook).SetPiece(6, backRank, friendlyKing).SetPiece(7, backRank, ChessCompStompWithHacksEngine.ChessSquarePiece.Empty);
                            ChessCompStompWithHacksEngine.ComputeMovesKing.GetMoveInfosForCastlingAndSuperCastlingMoves(i, j, 6, backRank, interimBoard, newBoard, gameState, moves);
                        }
                    }

                    if (canNormalCastleQueenside) {
                        if (gameState.Board.GetPiece$1(4, backRank) === friendlyKing && gameState.Board.GetPiece$1(3, backRank) === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty && gameState.Board.GetPiece$1(2, backRank) === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty && gameState.Board.GetPiece$1(1, backRank) === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty && gameState.Board.GetPiece$1(0, backRank) === friendlyRook) {
                            var interimBoard1 = gameState.Board.SetPiece(4, backRank, ChessCompStompWithHacksEngine.ChessSquarePiece.Empty).SetPiece(3, backRank, friendlyKing);
                            var newBoard1 = gameState.Board.SetPiece(4, backRank, ChessCompStompWithHacksEngine.ChessSquarePiece.Empty).SetPiece(3, backRank, friendlyRook).SetPiece(2, backRank, friendlyKing).SetPiece(1, backRank, ChessCompStompWithHacksEngine.ChessSquarePiece.Empty).SetPiece(0, backRank, ChessCompStompWithHacksEngine.ChessSquarePiece.Empty);
                            ChessCompStompWithHacksEngine.ComputeMovesKing.GetMoveInfosForCastlingAndSuperCastlingMoves(i, j, 2, backRank, interimBoard1, newBoard1, gameState, moves);
                        }
                    }
                },
                AddSuperCastlingKingMoves: function (gameState, i, j, moves) {
                    var $t;
                    var friendlyKing = gameState.IsWhiteTurn ? ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKing : ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKing;
                    var friendlyRook = gameState.IsWhiteTurn ? ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook : ChessCompStompWithHacksEngine.ChessSquarePiece.BlackRook;

                    var deltas = new (System.Collections.Generic.List$1(System.Tuple$2(System.Int32,System.Int32))).ctor();
                    if (((i + 2) | 0) < 8) {
                        deltas.add({ Item1: 1, Item2: 0 });
                    }
                    if (((i - 2) | 0) >= 0) {
                        deltas.add({ Item1: -1, Item2: 0 });
                    }
                    if (((j + 2) | 0) < 8) {
                        deltas.add({ Item1: 0, Item2: 1 });
                    }
                    if (((j - 2) | 0) >= 0) {
                        deltas.add({ Item1: 0, Item2: -1 });
                    }

                    $t = Bridge.getEnumerator(deltas);
                    try {
                        while ($t.moveNext()) {
                            var delta = $t.Current;
                            var kingI = i;
                            var kingJ = j;
                            var count = 0;
                            while (true) {
                                kingI = (kingI + delta.Item1) | 0;
                                kingJ = (kingJ + delta.Item2) | 0;
                                count = (count + 1) | 0;

                                if (kingI < 0 || kingI >= 8 || kingJ < 0 || kingJ >= 8) {
                                    break;
                                }

                                if (gameState.Board.GetPiece$1(kingI, kingJ) === friendlyRook) {
                                    if (count !== 1 || gameState.Board.GetPiece$1(((((i + delta.Item1) | 0) + delta.Item1) | 0), ((((j + delta.Item2) | 0) + delta.Item2) | 0)) === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                                        var interimBoard = gameState.Board.SetPiece(i, j, ChessCompStompWithHacksEngine.ChessSquarePiece.Empty).SetPiece(((i + delta.Item1) | 0), ((j + delta.Item2) | 0), friendlyKing);
                                        var newBoard = gameState.Board.SetPiece(i, j, ChessCompStompWithHacksEngine.ChessSquarePiece.Empty).SetPiece(kingI, kingJ, ChessCompStompWithHacksEngine.ChessSquarePiece.Empty).SetPiece(((i + delta.Item1) | 0), ((j + delta.Item2) | 0), friendlyRook).SetPiece(((((i + delta.Item1) | 0) + delta.Item1) | 0), ((((j + delta.Item2) | 0) + delta.Item2) | 0), friendlyKing);

                                        ChessCompStompWithHacksEngine.ComputeMovesKing.GetMoveInfosForCastlingAndSuperCastlingMoves(i, j, ((((i + delta.Item1) | 0) + delta.Item1) | 0), ((((j + delta.Item2) | 0) + delta.Item2) | 0), interimBoard, newBoard, gameState, moves);
                                    }
                                    break;
                                }

                                if (gameState.Board.GetPiece$1(kingI, kingJ) !== ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                                    break;
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                },
                AddNonCastlingKingMoves: function (gameState, i, j, moves) {
                    var $t;
                    var piece = gameState.IsWhiteTurn ? ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKing : ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKing;

                    var kingMoves = new (System.Collections.Generic.List$1(System.Tuple$2(System.Int32,System.Int32))).ctor();
                    kingMoves.add({ Item1: ((i - 1) | 0), Item2: ((j - 1) | 0) });
                    kingMoves.add({ Item1: ((i - 1) | 0), Item2: j });
                    kingMoves.add({ Item1: ((i - 1) | 0), Item2: ((j + 1) | 0) });
                    kingMoves.add({ Item1: i, Item2: ((j - 1) | 0) });
                    kingMoves.add({ Item1: i, Item2: ((j + 1) | 0) });
                    kingMoves.add({ Item1: ((i + 1) | 0), Item2: ((j - 1) | 0) });
                    kingMoves.add({ Item1: ((i + 1) | 0), Item2: j });
                    kingMoves.add({ Item1: ((i + 1) | 0), Item2: ((j + 1) | 0) });

                    $t = Bridge.getEnumerator(kingMoves);
                    try {
                        while ($t.moveNext()) {
                            var kingMove = $t.Current;
                            if (0 <= kingMove.Item1 && kingMove.Item1 < 8 && 0 <= kingMove.Item2 && kingMove.Item2 < 8) {
                                var pieceAtDestination = gameState.Board.GetPiece$1(kingMove.Item1, kingMove.Item2);

                                if (gameState.IsWhiteTurn && !ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsWhite(pieceAtDestination) || !gameState.IsWhiteTurn && !ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsBlack(pieceAtDestination)) {
                                    if (ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsPawn(pieceAtDestination) === false || gameState.IsPlayerTurn() || gameState.Abilities.HasPawnsDestroyCapturingPiece === false) {
                                        ChessCompStompWithHacksEngine.ComputeMoves.AddMoveInfosForNonEnPassantNonCastlingMoves(i, j, kingMove.Item1, kingMove.Item2, piece, gameState, kingMove.Item1, kingMove.Item2, moves);
                                    }
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                },
                GetMoveInfosForCastlingAndSuperCastlingMoves: function (startingFile, startingRank, endingFile, endingRank, interimBoard, newBoard, gameState, moves) {
                    if (ChessCompStompWithHacksEngine.CheckKingUnderAttack.IsKingUnderThreat(gameState.Board, gameState.Abilities, gameState.IsWhiteTurn, gameState.IsPlayerWhite, startingFile, startingRank)) {
                        return;
                    }

                    if (ChessCompStompWithHacksEngine.CheckKingUnderAttack.IsKingUnderThreat(interimBoard, gameState.Abilities, gameState.IsWhiteTurn, gameState.IsPlayerWhite, ((Bridge.Int.div((((startingFile + endingFile) | 0)), 2)) | 0), ((Bridge.Int.div((((startingRank + endingRank) | 0)), 2)) | 0))) {
                        return;
                    }

                    if (ChessCompStompWithHacksEngine.CheckKingUnderAttack.IsKingUnderThreat(newBoard, gameState.Abilities, gameState.IsWhiteTurn, gameState.IsPlayerWhite, endingFile, endingRank)) {
                        return;
                    }

                    if (gameState.IsWhiteTurn) {
                        var isPromotion;

                        isPromotion = startingRank === 7 && endingRank === 7 && gameState.IsPlayerTurn() && gameState.Abilities.HasAnyPieceCanPromote;

                        if (isPromotion) {
                            ChessCompStompWithHacksEngine.ComputeMoves.AddPromotionMoveInfos(startingFile, startingRank, endingFile, endingRank, false, moves);
                        } else {
                            moves.add(new ChessCompStompWithHacksEngine.ComputeMoves.MoveInfo(ChessCompStompWithHacksEngine.Move.NormalMove(startingFile, startingRank, endingFile, endingRank), false));
                        }
                    } else {
                        var isPromotion1;

                        isPromotion1 = startingRank === 0 && endingRank === 0 && gameState.IsPlayerTurn() && gameState.Abilities.HasAnyPieceCanPromote;

                        if (isPromotion1) {
                            ChessCompStompWithHacksEngine.ComputeMoves.AddPromotionMoveInfos(startingFile, startingRank, endingFile, endingRank, false, moves);
                        } else {
                            moves.add(new ChessCompStompWithHacksEngine.ComputeMoves.MoveInfo(ChessCompStompWithHacksEngine.Move.NormalMove(startingFile, startingRank, endingFile, endingRank), false));
                        }
                    }
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.ComputeMovesKnight", {
        statics: {
            methods: {
                AddKnightMoves: function (gameState, i, j, kingFile, kingRank, moves) {
                    var $t;
                    var piece = gameState.IsWhiteTurn ? ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKnight : ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKnight;

                    var knightMoves = new (System.Collections.Generic.List$1(System.Tuple$2(System.Int32,System.Int32))).ctor();
                    knightMoves.add({ Item1: ((i + 1) | 0), Item2: ((j + 2) | 0) });
                    knightMoves.add({ Item1: ((i + 1) | 0), Item2: ((j - 2) | 0) });
                    knightMoves.add({ Item1: ((i - 1) | 0), Item2: ((j + 2) | 0) });
                    knightMoves.add({ Item1: ((i - 1) | 0), Item2: ((j - 2) | 0) });
                    knightMoves.add({ Item1: ((i + 2) | 0), Item2: ((j + 1) | 0) });
                    knightMoves.add({ Item1: ((i + 2) | 0), Item2: ((j - 1) | 0) });
                    knightMoves.add({ Item1: ((i - 2) | 0), Item2: ((j + 1) | 0) });
                    knightMoves.add({ Item1: ((i - 2) | 0), Item2: ((j - 1) | 0) });
                    if (gameState.IsPlayerTurn() && gameState.Abilities.CanKnightsMakeLargeKnightsMove) {
                        knightMoves.add({ Item1: ((i + 1) | 0), Item2: ((j + 3) | 0) });
                        knightMoves.add({ Item1: ((i + 1) | 0), Item2: ((j - 3) | 0) });
                        knightMoves.add({ Item1: ((i - 1) | 0), Item2: ((j + 3) | 0) });
                        knightMoves.add({ Item1: ((i - 1) | 0), Item2: ((j - 3) | 0) });
                        knightMoves.add({ Item1: ((i + 3) | 0), Item2: ((j + 1) | 0) });
                        knightMoves.add({ Item1: ((i + 3) | 0), Item2: ((j - 1) | 0) });
                        knightMoves.add({ Item1: ((i - 3) | 0), Item2: ((j + 1) | 0) });
                        knightMoves.add({ Item1: ((i - 3) | 0), Item2: ((j - 1) | 0) });
                    }

                    $t = Bridge.getEnumerator(knightMoves);
                    try {
                        while ($t.moveNext()) {
                            var knightMove = $t.Current;
                            if (0 <= knightMove.Item1 && knightMove.Item1 < 8 && 0 <= knightMove.Item2 && knightMove.Item2 < 8) {
                                var pieceAtDestination = gameState.Board.GetPiece$1(knightMove.Item1, knightMove.Item2);

                                if (gameState.IsWhiteTurn && !ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsWhite(pieceAtDestination) || !gameState.IsWhiteTurn && !ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsBlack(pieceAtDestination)) {
                                    ChessCompStompWithHacksEngine.ComputeMoves.AddMoveInfosForNonEnPassantNonCastlingMoves(i, j, knightMove.Item1, knightMove.Item2, piece, gameState, kingFile, kingRank, moves);
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.ComputeMovesPawn", {
        statics: {
            methods: {
                AddPawnMoves: function (gameState, i, j, kingFile, kingRank, moves) {
                    ChessCompStompWithHacksEngine.ComputeMovesPawn.AddNonCapturePawnMoves(gameState, i, j, kingFile, kingRank, moves);

                    ChessCompStompWithHacksEngine.ComputeMovesPawn.AddCapturingPawnMoves(gameState, i, j, kingFile, kingRank, moves);
                },
                AddNonCapturePawnMoves: function (gameState, i, j, kingFile, kingRank, moves) {
                    var nextRank;
                    var nextNextRank;
                    var nextNextNextRank;
                    var piece = new ChessCompStompWithHacksEngine.ChessSquarePiece();

                    if (gameState.IsWhiteTurn) {
                        nextRank = (j + 1) | 0;
                        nextNextRank = (j + 2) | 0;
                        nextNextNextRank = (j + 3) | 0;
                        piece = ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn;
                    } else {
                        nextRank = (j - 1) | 0;
                        nextNextRank = (j - 2) | 0;
                        nextNextNextRank = (j - 3) | 0;
                        piece = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackPawn;
                    }

                    if (gameState.Board.GetPiece$1(i, nextRank) === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                        ChessCompStompWithHacksEngine.ComputeMoves.AddMoveInfosForNonEnPassantNonCastlingMoves(i, j, i, nextRank, piece, gameState, kingFile, kingRank, moves);

                        if (gameState.UnmovedPawns.HasUnmovedPawn(i, j) && nextNextRank >= 0 && nextNextRank < 8 && gameState.Board.GetPiece$1(i, nextNextRank) === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                            ChessCompStompWithHacksEngine.ComputeMoves.AddMoveInfosForNonEnPassantNonCastlingMoves(i, j, i, nextNextRank, piece, gameState, kingFile, kingRank, moves);

                            if (gameState.IsPlayerTurn() && gameState.Abilities.CanPawnsMoveThreeSpacesInitially && nextNextNextRank >= 0 && nextNextNextRank < 8 && gameState.Board.GetPiece$1(i, nextNextNextRank) === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                                ChessCompStompWithHacksEngine.ComputeMoves.AddMoveInfosForNonEnPassantNonCastlingMoves(i, j, i, nextNextNextRank, piece, gameState, kingFile, kingRank, moves);
                            }
                        }
                    }
                },
                AddCapturingPawnMoves: function (gameState, i, j, kingFile, kingRank, moves) {
                    var $t;
                    var hasSuperEnPassant = gameState.IsPlayerTurn() && gameState.Abilities.CanSuperEnPassant;

                    var nextRank = gameState.IsWhiteTurn ? (((j + 1) | 0)) : (((j - 1) | 0));

                    var endingFiles = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    if (i >= 1) {
                        endingFiles.add(((i - 1) | 0));
                    }
                    if (i <= 6) {
                        endingFiles.add(((i + 1) | 0));
                    }

                    $t = Bridge.getEnumerator(endingFiles);
                    try {
                        while ($t.moveNext()) {
                            var endingFile = $t.Current;
                            var capturingSquare = gameState.Board.GetPiece$1(endingFile, nextRank);
                            var enPassantSquare = gameState.Board.GetPiece$1(endingFile, j);

                            if (gameState.IsWhiteTurn && ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsWhite(capturingSquare) || !gameState.IsWhiteTurn && ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsBlack(capturingSquare)) {
                                continue;
                            }

                            var shouldTakeEnPassant;
                            var hasCapturedOpponentPawn;

                            if (hasSuperEnPassant) {
                                if (!ChessCompStompWithHacksEngine.ComputeMovesPawn.IsOpponentPiece(gameState, capturingSquare) && !ChessCompStompWithHacksEngine.ComputeMovesPawn.IsOpponentPiece(gameState, enPassantSquare)) {
                                    continue;
                                }
                                shouldTakeEnPassant = ChessCompStompWithHacksEngine.ComputeMovesPawn.IsOpponentPiece(gameState, enPassantSquare);
                                hasCapturedOpponentPawn = shouldTakeEnPassant && ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsPawn(enPassantSquare) || ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsPawn(capturingSquare);
                            } else {
                                if (System.Nullable.hasValue(gameState.PreviousPawnMoveFileForEnPassant) && System.Nullable.getValue(gameState.PreviousPawnMoveFileForEnPassant) === endingFile && System.Nullable.hasValue(gameState.PreviousPawnMoveRankForEnPassant) && System.Nullable.getValue(gameState.PreviousPawnMoveRankForEnPassant) === j && ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsPawn(enPassantSquare) && capturingSquare === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                                    shouldTakeEnPassant = true;
                                    hasCapturedOpponentPawn = true;
                                } else {
                                    if (!ChessCompStompWithHacksEngine.ComputeMovesPawn.IsOpponentPiece(gameState, capturingSquare)) {
                                        continue;
                                    }
                                    shouldTakeEnPassant = false;
                                    hasCapturedOpponentPawn = ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsPawn(capturingSquare);
                                }
                            }

                            var newBoard = gameState.Board.SetPiece(i, j, ChessCompStompWithHacksEngine.ChessSquarePiece.Empty);

                            if (shouldTakeEnPassant) {
                                newBoard = newBoard.SetPiece(endingFile, j, ChessCompStompWithHacksEngine.ChessSquarePiece.Empty);
                            }

                            if (!gameState.IsPlayerTurn() && gameState.Abilities.HasPawnsDestroyCapturingPiece && hasCapturedOpponentPawn) {
                                newBoard = newBoard.SetPiece(endingFile, nextRank, ChessCompStompWithHacksEngine.ChessSquarePiece.Empty);
                            } else {
                                newBoard = newBoard.SetPiece(endingFile, nextRank, gameState.IsWhiteTurn ? ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook : ChessCompStompWithHacksEngine.ChessSquarePiece.BlackRook);
                            }

                            ChessCompStompWithHacksEngine.ComputeMovesPawn.AddMoveInfosForCapturingPawnMove(i, j, endingFile, nextRank, newBoard, gameState, kingFile, kingRank, moves);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                },
                IsOpponentPiece: function (gameState, piece) {
                    return gameState.IsWhiteTurn && ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsBlack(piece) || !gameState.IsWhiteTurn && ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsWhite(piece);
                },
                AddMoveInfosForCapturingPawnMove: function (startingFile, startingRank, endingFile, endingRank, newBoard, gameState, kingFile, kingRank, moves) {
                    if (ChessCompStompWithHacksEngine.CheckKingUnderAttack.IsKingUnderThreat(newBoard, gameState.Abilities, gameState.IsWhiteTurn, gameState.IsPlayerWhite, kingFile, kingRank)) {
                        return;
                    }

                    var isPromotion = gameState.IsWhiteTurn ? (endingRank === 7) : (endingRank === 0);

                    if (isPromotion) {
                        ChessCompStompWithHacksEngine.ComputeMoves.AddPromotionMoveInfos(startingFile, startingRank, endingFile, endingRank, true, moves);
                    } else {
                        moves.add(new ChessCompStompWithHacksEngine.ComputeMoves.MoveInfo(ChessCompStompWithHacksEngine.Move.NormalMove(startingFile, startingRank, endingFile, endingRank), true));
                    }
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.ComputeMovesQueen", {
        statics: {
            methods: {
                AddQueenMoves: function (gameState, i, j, kingFile, kingRank, moves) {
                    var $t, $t1;
                    var piece = gameState.IsWhiteTurn ? ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteQueen : ChessCompStompWithHacksEngine.ChessSquarePiece.BlackQueen;

                    var deltas = new (System.Collections.Generic.List$1(System.Tuple$2(System.Int32,System.Int32))).ctor();
                    deltas.add({ Item1: 0, Item2: 1 });
                    deltas.add({ Item1: 0, Item2: -1 });
                    deltas.add({ Item1: 1, Item2: 0 });
                    deltas.add({ Item1: -1, Item2: 0 });
                    deltas.add({ Item1: 1, Item2: 1 });
                    deltas.add({ Item1: 1, Item2: -1 });
                    deltas.add({ Item1: -1, Item2: 1 });
                    deltas.add({ Item1: -1, Item2: -1 });

                    $t = Bridge.getEnumerator(deltas);
                    try {
                        while ($t.moveNext()) {
                            var delta = $t.Current;
                            var endI = i;
                            var endJ = j;
                            while (true) {
                                endI = (endI + delta.Item1) | 0;
                                endJ = (endJ + delta.Item2) | 0;
                                if (endI < 0 || endI >= 8 || endJ < 0 || endJ >= 8) {
                                    break;
                                }

                                var pieceAtDestination = gameState.Board.GetPiece$1(endI, endJ);

                                if (gameState.IsWhiteTurn && !ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsWhite(pieceAtDestination) || !gameState.IsWhiteTurn && !ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsBlack(pieceAtDestination)) {
                                    ChessCompStompWithHacksEngine.ComputeMoves.AddMoveInfosForNonEnPassantNonCastlingMoves(i, j, endI, endJ, piece, gameState, kingFile, kingRank, moves);
                                }

                                if (pieceAtDestination !== ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                                    break;
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    if (gameState.IsPlayerTurn() && gameState.Abilities.CanQueensMoveLikeKnights) {
                        var knightMoves = new (System.Collections.Generic.List$1(System.Tuple$2(System.Int32,System.Int32))).ctor();
                        knightMoves.add({ Item1: ((i + 1) | 0), Item2: ((j + 2) | 0) });
                        knightMoves.add({ Item1: ((i + 1) | 0), Item2: ((j - 2) | 0) });
                        knightMoves.add({ Item1: ((i - 1) | 0), Item2: ((j + 2) | 0) });
                        knightMoves.add({ Item1: ((i - 1) | 0), Item2: ((j - 2) | 0) });
                        knightMoves.add({ Item1: ((i + 2) | 0), Item2: ((j + 1) | 0) });
                        knightMoves.add({ Item1: ((i + 2) | 0), Item2: ((j - 1) | 0) });
                        knightMoves.add({ Item1: ((i - 2) | 0), Item2: ((j + 1) | 0) });
                        knightMoves.add({ Item1: ((i - 2) | 0), Item2: ((j - 1) | 0) });
                        if (gameState.IsPlayerTurn() && gameState.Abilities.CanKnightsMakeLargeKnightsMove) {
                            knightMoves.add({ Item1: ((i + 1) | 0), Item2: ((j + 3) | 0) });
                            knightMoves.add({ Item1: ((i + 1) | 0), Item2: ((j - 3) | 0) });
                            knightMoves.add({ Item1: ((i - 1) | 0), Item2: ((j + 3) | 0) });
                            knightMoves.add({ Item1: ((i - 1) | 0), Item2: ((j - 3) | 0) });
                            knightMoves.add({ Item1: ((i + 3) | 0), Item2: ((j + 1) | 0) });
                            knightMoves.add({ Item1: ((i + 3) | 0), Item2: ((j - 1) | 0) });
                            knightMoves.add({ Item1: ((i - 3) | 0), Item2: ((j + 1) | 0) });
                            knightMoves.add({ Item1: ((i - 3) | 0), Item2: ((j - 1) | 0) });
                        }

                        $t1 = Bridge.getEnumerator(knightMoves);
                        try {
                            while ($t1.moveNext()) {
                                var knightMove = $t1.Current;
                                if (0 <= knightMove.Item1 && knightMove.Item1 < 8 && 0 <= knightMove.Item2 && knightMove.Item2 < 8) {
                                    var pieceAtDestination1 = gameState.Board.GetPiece$1(knightMove.Item1, knightMove.Item2);

                                    if (gameState.IsWhiteTurn && !ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsWhite(pieceAtDestination1) || !gameState.IsWhiteTurn && !ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsBlack(pieceAtDestination1)) {
                                        ChessCompStompWithHacksEngine.ComputeMoves.AddMoveInfosForNonEnPassantNonCastlingMoves(i, j, knightMove.Item1, knightMove.Item2, piece, gameState, kingFile, kingRank, moves);
                                    }
                                }
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }
                    }
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.ComputeMovesRook", {
        statics: {
            methods: {
                AddRookMoves: function (gameState, i, j, kingFile, kingRank, moves) {
                    var $t;
                    var piece = gameState.IsWhiteTurn ? ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook : ChessCompStompWithHacksEngine.ChessSquarePiece.BlackRook;

                    var deltas = new (System.Collections.Generic.List$1(System.Tuple$2(System.Int32,System.Int32))).ctor();
                    deltas.add({ Item1: 0, Item2: 1 });
                    deltas.add({ Item1: 0, Item2: -1 });
                    deltas.add({ Item1: 1, Item2: 0 });
                    deltas.add({ Item1: -1, Item2: 0 });
                    if (gameState.IsPlayerTurn() && gameState.Abilities.CanRooksMoveLikeBishops) {
                        deltas.add({ Item1: 1, Item2: 1 });
                        deltas.add({ Item1: 1, Item2: -1 });
                        deltas.add({ Item1: -1, Item2: 1 });
                        deltas.add({ Item1: -1, Item2: -1 });
                    }

                    $t = Bridge.getEnumerator(deltas);
                    try {
                        while ($t.moveNext()) {
                            var delta = $t.Current;
                            var endI = i;
                            var endJ = j;
                            while (true) {
                                endI = (endI + delta.Item1) | 0;
                                endJ = (endJ + delta.Item2) | 0;
                                if (endI < 0 || endI >= 8 || endJ < 0 || endJ >= 8) {
                                    break;
                                }

                                var pieceAtDestination = gameState.Board.GetPiece$1(endI, endJ);

                                if (gameState.IsWhiteTurn && !ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsWhite(pieceAtDestination) || !gameState.IsWhiteTurn && !ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsBlack(pieceAtDestination)) {
                                    ChessCompStompWithHacksEngine.ComputeMoves.AddMoveInfosForNonEnPassantNonCastlingMoves(i, j, endI, endJ, piece, gameState, kingFile, kingRank, moves);
                                }

                                if (pieceAtDestination !== ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                                    if (gameState.IsPlayerTurn() && gameState.Abilities.CanRooksCaptureLikeCannons) {
                                        while (true) {
                                            endI = (endI + delta.Item1) | 0;
                                            endJ = (endJ + delta.Item2) | 0;
                                            if (endI < 0 || endI >= 8 || endJ < 0 || endJ >= 8) {
                                                break;
                                            }

                                            if (gameState.Board.GetPiece$1(endI, endJ) !== ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                                                if (gameState.IsWhiteTurn && ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsBlack(gameState.Board.GetPiece$1(endI, endJ)) || !gameState.IsWhiteTurn && ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsWhite(gameState.Board.GetPiece$1(endI, endJ))) {
                                                    ChessCompStompWithHacksEngine.ComputeMoves.AddMoveInfosForNonEnPassantNonCastlingMoves(i, j, endI, endJ, piece, gameState, kingFile, kingRank, moves);
                                                }
                                                break;
                                            }
                                        }
                                    }
                                    break;
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.ComputeMovesTacticalNuke", {
        statics: {
            methods: {
                AddTacticalNukeMoves: function (gameState, kingFile, kingRank, moves) {
                    var $t;
                    if (!gameState.IsPlayerTurn()) {
                        return;
                    }

                    if (!gameState.Abilities.HasTacticalNuke) {
                        return;
                    }

                    if (gameState.HasUsedNuke) {
                        return;
                    }

                    if (gameState.TurnCount <= ChessCompStompWithHacksEngine.TacticalNukeUtil.NumberOfMovesPlayedBeforeNukeIsAvailable) {
                        return;
                    }

                    for (var i = 0; i < 8; i = (i + 1) | 0) {
                        for (var j = 0; j < 8; j = (j + 1) | 0) {
                            var nukedSquares = ChessCompStompWithHacksEngine.TacticalNukeUtil.GetNukedSquares$1(i, j);

                            var eitherKingGetsNuked = false;
                            var nukedBoard = gameState.Board;

                            $t = Bridge.getEnumerator(nukedSquares);
                            try {
                                while ($t.moveNext()) {
                                    var nukedSquare = $t.Current;
                                    if (ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsKing(gameState.Board.GetPiece$1(nukedSquare.File, nukedSquare.Rank))) {
                                        eitherKingGetsNuked = true;
                                        break;
                                    }

                                    nukedBoard = nukedBoard.SetPiece(nukedSquare.File, nukedSquare.Rank, ChessCompStompWithHacksEngine.ChessSquarePiece.Empty);
                                }
                            } finally {
                                if (Bridge.is($t, System.IDisposable)) {
                                    $t.System$IDisposable$Dispose();
                                }
                            }

                            if (eitherKingGetsNuked) {
                                continue;
                            }

                            if (!ChessCompStompWithHacksEngine.CheckKingUnderAttack.IsKingUnderThreat(nukedBoard, gameState.Abilities, gameState.IsWhiteTurn, gameState.IsPlayerWhite, kingFile, kingRank)) {
                                moves.add(new ChessCompStompWithHacksEngine.ComputeMoves.MoveInfo(ChessCompStompWithHacksEngine.Move.TacticalNukeMove(i, j), false));
                            }
                        }
                    }
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.DisplayMove", {
        statics: {
            methods: {
                GetDisplayMoves: function (moves, gameState) {
                    var $t;
                    var displayMoves = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.DisplayMove)).ctor();

                    $t = Bridge.getEnumerator(moves);
                    try {
                        while ($t.moveNext()) {
                            var move = $t.Current;
                            displayMoves.add(new ChessCompStompWithHacksEngine.DisplayMove.ctor(move));

                            if (ChessCompStompWithHacksEngine.MoveUtil.IsCastlingOrSuperCastling(move, gameState.Board)) {
                                var king = new ChessCompStompWithHacksEngine.ChessSquare(System.Nullable.getValue(move.StartingFile), System.Nullable.getValue(move.StartingRank));

                                var direction;
                                if (((move.EndingFile - System.Nullable.getValue(move.StartingFile)) | 0) === 2) {
                                    direction = { Item1: 1, Item2: 0 };
                                } else {
                                    if (((move.EndingFile - System.Nullable.getValue(move.StartingFile)) | 0) === -2) {
                                        direction = { Item1: -1, Item2: 0 };
                                    } else {
                                        if (((move.EndingRank - System.Nullable.getValue(move.StartingRank)) | 0) === 2) {
                                            direction = { Item1: 0, Item2: 1 };
                                        } else {
                                            if (((move.EndingRank - System.Nullable.getValue(move.StartingRank)) | 0) === -2) {
                                                direction = { Item1: 0, Item2: -1 };
                                            } else {
                                                throw new System.Exception();
                                            }
                                        }
                                    }
                                }

                                var rook = king;
                                while (true) {
                                    rook = new ChessCompStompWithHacksEngine.ChessSquare(((rook.File + direction.Item1) | 0), ((rook.Rank + direction.Item2) | 0));
                                    if (ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsRook(gameState.Board.GetPiece(rook))) {
                                        break;
                                    }
                                }

                                if (rook.File !== move.EndingFile || rook.Rank !== move.EndingRank) {
                                    displayMoves.add(new ChessCompStompWithHacksEngine.DisplayMove.$ctor1(false, System.Nullable.getValue(move.StartingFile), System.Nullable.getValue(move.StartingRank), rook.File, rook.Rank, move.Promotion, move));
                                }

                                displayMoves.add(new ChessCompStompWithHacksEngine.DisplayMove.$ctor1(false, rook.File, rook.Rank, System.Nullable.getValue(move.StartingFile), System.Nullable.getValue(move.StartingRank), move.Promotion, move));
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    return displayMoves;
                }
            }
        },
        fields: {
            IsNuke: false,
            StartingFile: null,
            StartingRank: null,
            EndingFile: 0,
            EndingRank: 0,
            Promotion: null,
            Move: null
        },
        ctors: {
            $ctor1: function (isNuke, startingFile, startingRank, endingFile, endingRank, promotion, move) {
                this.$initialize();
                this.IsNuke = isNuke;
                this.StartingFile = startingFile;
                this.StartingRank = startingRank;
                this.EndingFile = endingFile;
                this.EndingRank = endingRank;
                this.Promotion = promotion;
                this.Move = move;
            },
            ctor: function (move) {
                this.$initialize();
                this.IsNuke = move.IsNuke;
                this.StartingFile = move.StartingFile;
                this.StartingRank = move.StartingRank;
                this.EndingFile = move.EndingFile;
                this.EndingRank = move.EndingRank;
                this.Promotion = move.Promotion;
                this.Move = move;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.GameState", {
        inherits: function () { return [System.IEquatable$1(ChessCompStompWithHacksEngine.GameState)]; },
        fields: {
            Board: null,
            UnmovedPawns: null,
            TurnCount: 0,
            HasUsedNuke: false,
            IsPlayerWhite: false,
            IsWhiteTurn: false,
            PreviousPawnMoveFileForEnPassant: null,
            PreviousPawnMoveRankForEnPassant: null,
            Castling: null,
            Abilities: null,
            hashCode: null
        },
        alias: ["equalsT", "System$IEquatable$1$ChessCompStompWithHacksEngine$GameState$equalsT"],
        ctors: {
            ctor: function (board, unmovedPawns, turnCount, hasUsedNuke, isPlayerWhite, isWhiteTurn, previousPawnMoveFileForEnPassant, previousPawnMoveRankForEnPassant, castlingRights, playerAbilities) {
                this.$initialize();
                this.Board = board;
                this.UnmovedPawns = unmovedPawns;
                this.TurnCount = turnCount;
                this.HasUsedNuke = hasUsedNuke;
                this.IsPlayerWhite = isPlayerWhite;
                this.IsWhiteTurn = isWhiteTurn;
                this.PreviousPawnMoveFileForEnPassant = previousPawnMoveFileForEnPassant;
                this.PreviousPawnMoveRankForEnPassant = previousPawnMoveRankForEnPassant;
                this.Castling = castlingRights;
                this.Abilities = playerAbilities;

                this.hashCode = null;
            }
        },
        methods: {
            IsPlayerTurn: function () {
                if (this.IsPlayerWhite && this.IsWhiteTurn) {
                    return true;
                }
                if (!this.IsPlayerWhite && !this.IsWhiteTurn) {
                    return true;
                }
                return false;
            },
            equals: function (obj) {
                return this.equalsT(Bridge.as(obj, ChessCompStompWithHacksEngine.GameState));
            },
            equalsT: function (other) {
                if (other == null) {
                    return false;
                }

                if (Bridge.referenceEquals(this, other)) {
                    return true;
                }

                if (this.TurnCount !== other.TurnCount) {
                    return false;
                }

                this.ComputeHashCode();
                other.ComputeHashCode();

                if (System.Nullable.getValue(this.hashCode) !== System.Nullable.getValue(other.hashCode)) {
                    return false;
                }

                if (!this.Board.equalsT(other.Board)) {
                    return false;
                }

                if (this.IsPlayerWhite !== other.IsPlayerWhite) {
                    return false;
                }

                if (this.IsWhiteTurn !== other.IsWhiteTurn) {
                    return false;
                }

                if (this.HasUsedNuke !== other.HasUsedNuke) {
                    return false;
                }

                if (System.Nullable.hasValue(this.PreviousPawnMoveFileForEnPassant) && !System.Nullable.hasValue(other.PreviousPawnMoveFileForEnPassant) || !System.Nullable.hasValue(this.PreviousPawnMoveFileForEnPassant) && System.Nullable.hasValue(other.PreviousPawnMoveFileForEnPassant) || System.Nullable.hasValue(this.PreviousPawnMoveFileForEnPassant) && System.Nullable.hasValue(other.PreviousPawnMoveFileForEnPassant) && System.Nullable.getValue(this.PreviousPawnMoveFileForEnPassant) !== System.Nullable.getValue(other.PreviousPawnMoveFileForEnPassant)) {
                    return false;
                }

                if (System.Nullable.hasValue(this.PreviousPawnMoveRankForEnPassant) && !System.Nullable.hasValue(other.PreviousPawnMoveRankForEnPassant) || !System.Nullable.hasValue(this.PreviousPawnMoveRankForEnPassant) && System.Nullable.hasValue(other.PreviousPawnMoveRankForEnPassant) || System.Nullable.hasValue(this.PreviousPawnMoveRankForEnPassant) && System.Nullable.hasValue(other.PreviousPawnMoveRankForEnPassant) && System.Nullable.getValue(this.PreviousPawnMoveRankForEnPassant) !== System.Nullable.getValue(other.PreviousPawnMoveRankForEnPassant)) {
                    return false;
                }

                if (!this.UnmovedPawns.equalsT(other.UnmovedPawns)) {
                    return false;
                }

                if (!this.Castling.equalsT(other.Castling)) {
                    return false;
                }

                if (!this.Abilities.equalsT(other.Abilities)) {
                    return false;
                }

                return true;
            },
            ComputeHashCode: function () {
                if (System.Nullable.hasValue(this.hashCode)) {
                    return;
                }

                var hashCode = 0;

                if (this.IsPlayerWhite) {
                    hashCode = hashCode | 1;
                }
                if (this.HasUsedNuke) {
                    hashCode = hashCode | 2;
                }
                if (this.IsWhiteTurn) {
                    hashCode = hashCode | 4;
                }

                var unmovedPawnsHashCode = this.UnmovedPawns.getHashCode();
                hashCode = ((Bridge.Int.mul(hashCode, 17) + unmovedPawnsHashCode) | 0);

                var castlingHashCode = this.Castling.getHashCode();
                hashCode = ((Bridge.Int.mul(hashCode, 17) + castlingHashCode) | 0);

                var abilitiesHashCode = this.Abilities.getHashCode();
                hashCode = ((Bridge.Int.mul(hashCode, 17) + abilitiesHashCode) | 0);

                var previousPawnMoveFileForEnPassantHashCode = System.Nullable.hasValue(this.PreviousPawnMoveFileForEnPassant) ? ((System.Nullable.getValue(this.PreviousPawnMoveFileForEnPassant) + 1) | 0) : 0;
                hashCode = ((Bridge.Int.mul(hashCode, 17) + previousPawnMoveFileForEnPassantHashCode) | 0);

                var previousPawnMoveRankForEnPassantHashCode = System.Nullable.hasValue(this.PreviousPawnMoveRankForEnPassant) ? ((System.Nullable.getValue(this.PreviousPawnMoveRankForEnPassant) + 1) | 0) : 0;
                hashCode = ((Bridge.Int.mul(hashCode, 17) + previousPawnMoveRankForEnPassantHashCode) | 0);

                var turnCountHashCode = this.TurnCount;
                hashCode = ((Bridge.Int.mul(hashCode, 17) + turnCountHashCode) | 0);

                var boardHashCode = this.Board.getHashCode();
                hashCode = ((Bridge.Int.mul(hashCode, 17) + boardHashCode) | 0);

                this.hashCode = hashCode;
            },
            getHashCode: function () {
                this.ComputeHashCode();
                return System.Nullable.getValue(this.hashCode);
            }
        }
    });

    /** @namespace ChessCompStompWithHacksEngine */

    /**
     * Tracks whether castling is still allowed.
     Note that this doesn't affect super-castling, which allows the player to castle
     regardless of whether the king or rook has ever moved.
     *
     * @public
     * @class ChessCompStompWithHacksEngine.GameState.CastlingRights
     * @implements  System.IEquatable$1
     */
    Bridge.define("ChessCompStompWithHacksEngine.GameState.CastlingRights", {
        inherits: function () { return [System.IEquatable$1(ChessCompStompWithHacksEngine.GameState.CastlingRights)]; },
        $kind: "nested class",
        fields: {
            CanWhiteCastleKingside: false,
            CanWhiteCastleQueenside: false,
            CanBlackCastleKingside: false,
            CanBlackCastleQueenside: false
        },
        alias: ["equalsT", "System$IEquatable$1$ChessCompStompWithHacksEngine$GameState$CastlingRights$equalsT"],
        ctors: {
            ctor: function (canWhiteCastleKingside, canWhiteCastleQueenside, canBlackCastleKingside, canBlackCastleQueenside) {
                this.$initialize();
                this.CanWhiteCastleKingside = canWhiteCastleKingside;
                this.CanWhiteCastleQueenside = canWhiteCastleQueenside;
                this.CanBlackCastleKingside = canBlackCastleKingside;
                this.CanBlackCastleQueenside = canBlackCastleQueenside;
            }
        },
        methods: {
            equals: function (obj) {
                return this.equalsT(Bridge.as(obj, ChessCompStompWithHacksEngine.GameState.CastlingRights));
            },
            equalsT: function (other) {
                return other != null && this.CanWhiteCastleKingside === other.CanWhiteCastleKingside && this.CanWhiteCastleQueenside === other.CanWhiteCastleQueenside && this.CanBlackCastleKingside === other.CanBlackCastleKingside && this.CanBlackCastleQueenside === other.CanBlackCastleQueenside;
            },
            getHashCode: function () {
                var hashCode = 0;
                if (this.CanWhiteCastleKingside) {
                    hashCode = hashCode | 1;
                }
                if (this.CanWhiteCastleQueenside) {
                    hashCode = hashCode | 2;
                }
                if (this.CanBlackCastleKingside) {
                    hashCode = hashCode | 4;
                }
                if (this.CanBlackCastleQueenside) {
                    hashCode = hashCode | 8;
                }
                return hashCode;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.GameState.PlayerAbilities", {
        inherits: function () { return [System.IEquatable$1(ChessCompStompWithHacksEngine.GameState.PlayerAbilities)]; },
        $kind: "nested class",
        fields: {
            CanPawnsMoveThreeSpacesInitially: false,
            CanSuperEnPassant: false,
            CanRooksMoveLikeBishops: false,
            CanSuperCastle: false,
            CanRooksCaptureLikeCannons: false,
            CanKnightsMakeLargeKnightsMove: false,
            CanQueensMoveLikeKnights: false,
            HasTacticalNuke: false,
            HasAnyPieceCanPromote: false,
            HasStalemateIsVictory: false,
            HasOpponentMustCaptureWhenPossible: false,
            HasPawnsDestroyCapturingPiece: false
        },
        alias: ["equalsT", "System$IEquatable$1$ChessCompStompWithHacksEngine$GameState$PlayerAbilities$equalsT"],
        ctors: {
            ctor: function (canPawnsMoveThreeSpacesInitially, canSuperEnPassant, canRooksMoveLikeBishops, canSuperCastle, canRooksCaptureLikeCannons, canKnightsMakeLargeKnightsMove, canQueensMoveLikeKnights, hasTacticalNuke, hasAnyPieceCanPromote, hasStalemateIsVictory, hasOpponentMustCaptureWhenPossible, hasPawnsDestroyCapturingPiece) {
                this.$initialize();
                this.CanPawnsMoveThreeSpacesInitially = canPawnsMoveThreeSpacesInitially;
                this.CanSuperEnPassant = canSuperEnPassant;
                this.CanRooksMoveLikeBishops = canRooksMoveLikeBishops;
                this.CanSuperCastle = canSuperCastle;
                this.CanRooksCaptureLikeCannons = canRooksCaptureLikeCannons;
                this.CanKnightsMakeLargeKnightsMove = canKnightsMakeLargeKnightsMove;
                this.CanQueensMoveLikeKnights = canQueensMoveLikeKnights;

                this.HasTacticalNuke = hasTacticalNuke;
                this.HasAnyPieceCanPromote = hasAnyPieceCanPromote;
                this.HasStalemateIsVictory = hasStalemateIsVictory;
                this.HasOpponentMustCaptureWhenPossible = hasOpponentMustCaptureWhenPossible;
                this.HasPawnsDestroyCapturingPiece = hasPawnsDestroyCapturingPiece;
            }
        },
        methods: {
            equals: function (obj) {
                return this.equalsT(Bridge.as(obj, ChessCompStompWithHacksEngine.GameState.PlayerAbilities));
            },
            equalsT: function (other) {
                if (Bridge.referenceEquals(this, other)) {
                    return true;
                }

                return other != null && this.CanPawnsMoveThreeSpacesInitially === other.CanPawnsMoveThreeSpacesInitially && this.CanSuperEnPassant === other.CanSuperEnPassant && this.CanRooksMoveLikeBishops === other.CanRooksMoveLikeBishops && this.CanSuperCastle === other.CanSuperCastle && this.CanRooksCaptureLikeCannons === other.CanRooksCaptureLikeCannons && this.CanKnightsMakeLargeKnightsMove === other.CanKnightsMakeLargeKnightsMove && this.CanQueensMoveLikeKnights === other.CanQueensMoveLikeKnights && this.HasTacticalNuke === other.HasTacticalNuke && this.HasAnyPieceCanPromote === other.HasAnyPieceCanPromote && this.HasStalemateIsVictory === other.HasStalemateIsVictory && this.HasOpponentMustCaptureWhenPossible === other.HasOpponentMustCaptureWhenPossible && this.HasPawnsDestroyCapturingPiece === other.HasPawnsDestroyCapturingPiece;
            },
            getHashCode: function () {
                var hashCode = 0;
                if (this.CanPawnsMoveThreeSpacesInitially) {
                    hashCode = hashCode | 1;
                }
                if (this.CanSuperEnPassant) {
                    hashCode = hashCode | (2);
                }
                if (this.CanRooksMoveLikeBishops) {
                    hashCode = hashCode | (4);
                }
                if (this.CanSuperCastle) {
                    hashCode = hashCode | (8);
                }
                if (this.CanRooksCaptureLikeCannons) {
                    hashCode = hashCode | (16);
                }
                if (this.CanKnightsMakeLargeKnightsMove) {
                    hashCode = hashCode | (32);
                }
                if (this.CanQueensMoveLikeKnights) {
                    hashCode = hashCode | (64);
                }
                if (this.HasTacticalNuke) {
                    hashCode = hashCode | (128);
                }
                if (this.HasAnyPieceCanPromote) {
                    hashCode = hashCode | (256);
                }
                if (this.HasStalemateIsVictory) {
                    hashCode = hashCode | (512);
                }
                if (this.HasOpponentMustCaptureWhenPossible) {
                    hashCode = hashCode | (1024);
                }
                if (this.HasPawnsDestroyCapturingPiece) {
                    hashCode = hashCode | (2048);
                }

                return hashCode;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.GameStateUtil", {
        statics: {
            methods: {
                GetGameStateWithoutNukeAbility: function (gameState) {
                    if (gameState.Abilities.HasTacticalNuke === false) {
                        return gameState;
                    }

                    return new ChessCompStompWithHacksEngine.GameState(gameState.Board, gameState.UnmovedPawns, gameState.TurnCount, false, gameState.IsPlayerWhite, gameState.IsWhiteTurn, gameState.PreviousPawnMoveFileForEnPassant, gameState.PreviousPawnMoveRankForEnPassant, gameState.Castling, new ChessCompStompWithHacksEngine.GameState.PlayerAbilities(gameState.Abilities.CanPawnsMoveThreeSpacesInitially, gameState.Abilities.CanSuperEnPassant, gameState.Abilities.CanRooksMoveLikeBishops, gameState.Abilities.CanSuperCastle, gameState.Abilities.CanRooksCaptureLikeCannons, gameState.Abilities.CanKnightsMakeLargeKnightsMove, gameState.Abilities.CanQueensMoveLikeKnights, false, gameState.Abilities.HasAnyPieceCanPromote, gameState.Abilities.HasStalemateIsVictory, gameState.Abilities.HasOpponentMustCaptureWhenPossible, gameState.Abilities.HasPawnsDestroyCapturingPiece));
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.Hack", {
        $kind: "enum",
        statics: {
            fields: {
                ExtraPawnFirst: 0,
                ExtraPawnSecond: 1,
                ExtraQueen: 2,
                PawnsCanMoveThreeSpacesInitially: 3,
                SuperEnPassant: 4,
                RooksCanMoveLikeBishops: 5,
                SuperCastling: 6,
                RooksCanCaptureLikeCannons: 7,
                KnightsCanMakeLargeKnightsMove: 8,
                QueensCanMoveLikeKnights: 9,
                TacticalNuke: 10,
                AnyPieceCanPromote: 11,
                StalemateIsVictory: 12,
                OpponentMustCaptureWhenPossible: 13,
                PawnsDestroyCapturingPiece: 14
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.IBoardEvaluator", {
        $kind: "interface"
    });

    Bridge.define("ChessCompStompWithHacksEngine.Move", {
        statics: {
            methods: {
                NormalMove: function (startingFile, startingRank, endingFile, endingRank) {
                    return new ChessCompStompWithHacksEngine.Move(false, startingFile, startingRank, endingFile, endingRank, null);
                },
                PromotionMove: function (startingFile, startingRank, endingFile, endingRank, promotion) {
                    return new ChessCompStompWithHacksEngine.Move(false, startingFile, startingRank, endingFile, endingRank, promotion);
                },
                TacticalNukeMove: function (file, rank) {
                    return new ChessCompStompWithHacksEngine.Move(true, null, null, file, rank, null);
                }
            }
        },
        fields: {
            IsNuke: false,
            StartingFile: null,
            StartingRank: null,
            EndingFile: 0,
            EndingRank: 0,
            Promotion: null
        },
        ctors: {
            ctor: function (isNuke, startingFile, startingRank, endingFile, endingRank, promotion) {
                this.$initialize();
                this.IsNuke = isNuke;
                this.StartingFile = startingFile;
                this.StartingRank = startingRank;
                this.EndingFile = endingFile;
                this.EndingRank = endingRank;
                this.Promotion = promotion;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.Move.PromotionType", {
        $kind: "nested enum",
        statics: {
            fields: {
                PromoteToRook: 0,
                PromoteToKnight: 1,
                PromoteToBishop: 2,
                PromoteToQueen: 3
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.MoveImplementation", {
        statics: {
            methods: {
                ApplyMove: function (gameState, displayMove) {
                    return ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(gameState, displayMove.Move);
                },
                ApplyMove$1: function (gameState, move) {
                    var newBoard = ChessCompStompWithHacksEngine.MoveImplementation.GetNewBoard(gameState, move);

                    var unmovedPawns = gameState.UnmovedPawns;
                    for (var i = 0; i < 8; i = (i + 1) | 0) {
                        for (var j = 0; j < 8; j = (j + 1) | 0) {
                            if (unmovedPawns.HasUnmovedPawn(i, j)) {
                                if (newBoard.GetPiece$1(i, j) !== gameState.Board.GetPiece$1(i, j)) {
                                    unmovedPawns = unmovedPawns.PawnMoved(i, j);
                                }
                            }
                        }
                    }

                    var previousPawnMoveFileForEnPassant;
                    var previousPawnMoveRankForEnPassant;
                    if (move.IsNuke) {
                        previousPawnMoveFileForEnPassant = null;
                        previousPawnMoveRankForEnPassant = null;
                    } else {
                        var pieceThatMoved = gameState.Board.GetPiece$1(System.Nullable.getValue(move.StartingFile), System.Nullable.getValue(move.StartingRank));
                        var pieceWasPawnAndMovedTwoSpaces = ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsPawn(pieceThatMoved) && System.Nullable.getValue(move.StartingFile) === move.EndingFile && Math.abs(((System.Nullable.getValue(move.StartingRank) - move.EndingRank) | 0)) === 2;
                        var pieceWasPawnAndMovedTwoSpacesFromSecondRank = pieceWasPawnAndMovedTwoSpaces && (System.Nullable.getValue(move.StartingRank) === 1 || System.Nullable.getValue(move.StartingRank) === 6);

                        if (pieceWasPawnAndMovedTwoSpaces && (pieceWasPawnAndMovedTwoSpacesFromSecondRank || !gameState.IsPlayerTurn())) {
                            previousPawnMoveFileForEnPassant = System.Nullable.getValue(move.StartingFile);
                            previousPawnMoveRankForEnPassant = move.EndingRank;
                        } else {
                            previousPawnMoveFileForEnPassant = null;
                            previousPawnMoveRankForEnPassant = null;
                        }
                    }

                    return new ChessCompStompWithHacksEngine.GameState(newBoard, unmovedPawns, ((gameState.TurnCount + 1) | 0), move.IsNuke ? true : gameState.HasUsedNuke, gameState.IsPlayerWhite, !gameState.IsWhiteTurn, previousPawnMoveFileForEnPassant, previousPawnMoveRankForEnPassant, ChessCompStompWithHacksEngine.MoveImplementation.ComputeNewCastlingRights(gameState, newBoard), gameState.Abilities);
                },
                GetNewBoard: function (gameState, move) {
                    var $t;
                    if (move.IsNuke) {
                        var nukedSquares = ChessCompStompWithHacksEngine.TacticalNukeUtil.GetNukedSquares$1(move.EndingFile, move.EndingRank);

                        var newBoard = gameState.Board;
                        $t = Bridge.getEnumerator(nukedSquares);
                        try {
                            while ($t.moveNext()) {
                                var nukedSquare = $t.Current;
                                newBoard = newBoard.SetPiece(nukedSquare.File, nukedSquare.Rank, ChessCompStompWithHacksEngine.ChessSquarePiece.Empty);
                            }
                        } finally {
                            if (Bridge.is($t, System.IDisposable)) {
                                $t.System$IDisposable$Dispose();
                            }
                        }

                        return newBoard;
                    } else {
                        var pieceThatMoved = gameState.Board.GetPiece$1(System.Nullable.getValue(move.StartingFile), System.Nullable.getValue(move.StartingRank));

                        if (ChessCompStompWithHacksEngine.MoveUtil.IsCastlingOrSuperCastling(move, gameState.Board)) {
                            return ChessCompStompWithHacksEngine.MoveImplementation.GetNewBoard_CastlingOrSuperCastling(gameState, move);
                        }

                        var movedPawnAndCapturedSomething = ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsPawn(pieceThatMoved) && System.Nullable.getValue(move.StartingFile) !== move.EndingFile;

                        var wasEnPassantOrSuperEnPassant;

                        if (!movedPawnAndCapturedSomething) {
                            wasEnPassantOrSuperEnPassant = false;
                        } else {
                            if (gameState.Board.GetPiece$1(move.EndingFile, move.EndingRank) === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                                wasEnPassantOrSuperEnPassant = true;
                            } else {
                                if (gameState.IsPlayerTurn() === false) {
                                    wasEnPassantOrSuperEnPassant = false;
                                } else {
                                    if (gameState.Abilities.CanSuperEnPassant === false) {
                                        wasEnPassantOrSuperEnPassant = false;
                                    } else {
                                        var potentialEnPassantCapturedPiece = gameState.Board.GetPiece$1(move.EndingFile, System.Nullable.getValue(move.StartingRank));
                                        if (potentialEnPassantCapturedPiece === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                                            wasEnPassantOrSuperEnPassant = false;
                                        } else {
                                            wasEnPassantOrSuperEnPassant = ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsWhite(potentialEnPassantCapturedPiece) && gameState.IsWhiteTurn === false || ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsBlack(potentialEnPassantCapturedPiece) && gameState.IsWhiteTurn;
                                        }
                                    }
                                }
                            }
                        }

                        var newBoard1 = gameState.Board.SetPiece(move.EndingFile, move.EndingRank, gameState.Board.GetPiece$1(System.Nullable.getValue(move.StartingFile), System.Nullable.getValue(move.StartingRank))).SetPiece(System.Nullable.getValue(move.StartingFile), System.Nullable.getValue(move.StartingRank), ChessCompStompWithHacksEngine.ChessSquarePiece.Empty);

                        if (System.Nullable.hasValue(move.Promotion)) {
                            newBoard1 = newBoard1.SetPiece(move.EndingFile, move.EndingRank, ChessCompStompWithHacksEngine.PromotionTypeUtil.GetPromotedPiece(System.Nullable.getValue(move.Promotion), gameState.IsWhiteTurn));
                        }

                        if (gameState.IsPlayerTurn() === false && gameState.Abilities.HasPawnsDestroyCapturingPiece) {
                            if (ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsPawn(gameState.Board.GetPiece$1(move.EndingFile, move.EndingRank))) {
                                newBoard1 = newBoard1.SetPiece(move.EndingFile, move.EndingRank, ChessCompStompWithHacksEngine.ChessSquarePiece.Empty);
                            } else {
                                if (wasEnPassantOrSuperEnPassant) {
                                    newBoard1 = newBoard1.SetPiece(move.EndingFile, move.EndingRank, ChessCompStompWithHacksEngine.ChessSquarePiece.Empty);
                                }
                            }
                        }

                        if (wasEnPassantOrSuperEnPassant) {
                            newBoard1 = newBoard1.SetPiece(move.EndingFile, System.Nullable.getValue(move.StartingRank), ChessCompStompWithHacksEngine.ChessSquarePiece.Empty);
                        }

                        return newBoard1;
                    }
                },
                GetNewBoard_CastlingOrSuperCastling: function (gameState, move) {
                    var delta;

                    if (move.EndingFile > System.Nullable.getValue(move.StartingFile)) {
                        delta = { Item1: 1, Item2: 0 };
                    } else {
                        if (move.EndingFile < System.Nullable.getValue(move.StartingFile)) {
                            delta = { Item1: -1, Item2: 0 };
                        } else {
                            if (move.EndingRank > System.Nullable.getValue(move.StartingRank)) {
                                delta = { Item1: 0, Item2: 1 };
                            } else {
                                if (move.EndingRank < System.Nullable.getValue(move.StartingRank)) {
                                    delta = { Item1: 0, Item2: -1 };
                                } else {
                                    throw new System.Exception();
                                }
                            }
                        }
                    }

                    var rookThatMoved = gameState.IsWhiteTurn ? ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook : ChessCompStompWithHacksEngine.ChessSquarePiece.BlackRook;
                    var rookThatMovedPossiblyPromoted = System.Nullable.hasValue(move.Promotion) ? ChessCompStompWithHacksEngine.PromotionTypeUtil.GetPromotedPiece(System.Nullable.getValue(move.Promotion), gameState.IsWhiteTurn) : rookThatMoved;

                    var count = 1;
                    while (true) {
                        if (gameState.Board.GetPiece$1(((System.Nullable.getValue(move.StartingFile) + Bridge.Int.mul(delta.Item1, count)) | 0), ((System.Nullable.getValue(move.StartingRank) + Bridge.Int.mul(delta.Item2, count)) | 0)) === rookThatMoved) {
                            break;
                        }
                        count = (count + 1) | 0;
                    }

                    var newBoard = gameState.Board.SetPiece(System.Nullable.getValue(move.StartingFile), System.Nullable.getValue(move.StartingRank), ChessCompStompWithHacksEngine.ChessSquarePiece.Empty).SetPiece(((System.Nullable.getValue(move.StartingFile) + delta.Item1) | 0), ((System.Nullable.getValue(move.StartingRank) + delta.Item2) | 0), rookThatMovedPossiblyPromoted).SetPiece(((((System.Nullable.getValue(move.StartingFile) + delta.Item1) | 0) + delta.Item1) | 0), ((((System.Nullable.getValue(move.StartingRank) + delta.Item2) | 0) + delta.Item2) | 0), gameState.IsWhiteTurn ? ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKing : ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKing);

                    if (count > 2) {
                        newBoard = newBoard.SetPiece(((System.Nullable.getValue(move.StartingFile) + Bridge.Int.mul(delta.Item1, count)) | 0), ((System.Nullable.getValue(move.StartingRank) + Bridge.Int.mul(delta.Item2, count)) | 0), ChessCompStompWithHacksEngine.ChessSquarePiece.Empty);
                    }

                    return newBoard;
                },
                ComputeNewCastlingRights: function (gameState, newBoard) {
                    var canWhiteCastleKingside;
                    if (gameState.Castling.CanWhiteCastleKingside) {
                        canWhiteCastleKingside = newBoard.GetPiece$1(4, 0) === ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKing && newBoard.GetPiece$1(7, 0) === ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook;
                    } else {
                        canWhiteCastleKingside = false;
                    }

                    var canWhiteCastleQueenside;
                    if (gameState.Castling.CanWhiteCastleQueenside) {
                        canWhiteCastleQueenside = newBoard.GetPiece$1(4, 0) === ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKing && newBoard.GetPiece$1(0, 0) === ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook;
                    } else {
                        canWhiteCastleQueenside = false;
                    }

                    var canBlackCastleKingside;
                    if (gameState.Castling.CanBlackCastleKingside) {
                        canBlackCastleKingside = newBoard.GetPiece$1(4, 7) === ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKing && newBoard.GetPiece$1(7, 7) === ChessCompStompWithHacksEngine.ChessSquarePiece.BlackRook;
                    } else {
                        canBlackCastleKingside = false;
                    }

                    var canBlackCastleQueenside;
                    if (gameState.Castling.CanBlackCastleQueenside) {
                        canBlackCastleQueenside = newBoard.GetPiece$1(4, 7) === ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKing && newBoard.GetPiece$1(0, 7) === ChessCompStompWithHacksEngine.ChessSquarePiece.BlackRook;
                    } else {
                        canBlackCastleQueenside = false;
                    }

                    return new ChessCompStompWithHacksEngine.GameState.CastlingRights(canWhiteCastleKingside, canWhiteCastleQueenside, canBlackCastleKingside, canBlackCastleQueenside);
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.MoveNaming", {
        statics: {
            methods: {
                GetNameOfMove: function (move, originalGameState) {
                    if (move.IsNuke) {
                        return ChessCompStompWithHacksEngine.MoveNaming.GetNameOfNukeMove(move, originalGameState);
                    }

                    var startingFile = System.Nullable.getValue(move.StartingFile);
                    var startingRank = System.Nullable.getValue(move.StartingRank);

                    var pieceBeingMoved = originalGameState.Board.GetPiece$1(startingFile, startingRank);

                    if (ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsPawn(pieceBeingMoved)) {
                        return ChessCompStompWithHacksEngine.MoveNaming.GetNameOfPawnMove(move, originalGameState);
                    }

                    if (ChessCompStompWithHacksEngine.MoveUtil.IsCastlingOrSuperCastling(move, originalGameState.Board)) {
                        return ChessCompStompWithHacksEngine.MoveNaming.GetNameOfCastlingMove(move, originalGameState);
                    }

                    return ChessCompStompWithHacksEngine.MoveNaming.GetNameOfNonPawnNonCastlingNonNukeMove(move, originalGameState);
                },
                GetNameOfNonPawnNonCastlingNonNukeMove: function (move, originalGameState) {
                    var $t, $t1, $t2;
                    var name;

                    var pieceBeingMoved = originalGameState.Board.GetPiece$1(System.Nullable.getValue(move.StartingFile), System.Nullable.getValue(move.StartingRank));

                    if (ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsRook(pieceBeingMoved)) {
                        name = "R";
                    } else {
                        if (ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsKnight(pieceBeingMoved)) {
                            name = "N";
                        } else {
                            if (ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsBishop(pieceBeingMoved)) {
                                name = "B";
                            } else {
                                if (ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsQueen(pieceBeingMoved)) {
                                    name = "Q";
                                } else {
                                    if (ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsKing(pieceBeingMoved)) {
                                        name = "K";
                                    } else {
                                        throw new System.Exception();
                                    }
                                }
                            }
                        }
                    }

                    var allMoves = ChessCompStompWithHacksEngine.ComputeMoves.GetMoves(originalGameState).Moves;
                    var piecesThatCanMakeThisMove = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor();
                    $t = Bridge.getEnumerator(allMoves);
                    try {
                        while ($t.moveNext()) {
                            var m = $t.Current;
                            if (m.IsNuke) {
                                continue;
                            }

                            if (originalGameState.Board.GetPiece$1(System.Nullable.getValue(m.StartingFile), System.Nullable.getValue(m.StartingRank)) !== pieceBeingMoved) {
                                continue;
                            }

                            if (m.EndingFile !== move.EndingFile || m.EndingRank !== move.EndingRank) {
                                continue;
                            }

                            if (System.Nullable.hasValue(m.Promotion) && System.Nullable.getValue(m.Promotion) !== ChessCompStompWithHacksEngine.Move.PromotionType.PromoteToQueen) {
                                continue;
                            }

                            piecesThatCanMakeThisMove.add(new ChessCompStompWithHacksEngine.ChessSquare(System.Nullable.getValue(m.StartingFile), System.Nullable.getValue(m.StartingRank)));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    if (piecesThatCanMakeThisMove.Count > 1) {
                        var fileCount = 0;
                        $t1 = Bridge.getEnumerator(piecesThatCanMakeThisMove);
                        try {
                            while ($t1.moveNext()) {
                                var cs = $t1.Current;
                                if (cs.File === System.Nullable.getValue(move.StartingFile)) {
                                    fileCount = (fileCount + 1) | 0;
                                }
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }

                        if (fileCount === 1) {
                            name = (name || "") + (ChessCompStompWithHacksEngine.MoveNaming.GetFileName(System.Nullable.getValue(move.StartingFile)) || "");
                        } else {
                            var rankCount = 0;
                            $t2 = Bridge.getEnumerator(piecesThatCanMakeThisMove);
                            try {
                                while ($t2.moveNext()) {
                                    var cs1 = $t2.Current;
                                    if (cs1.Rank === System.Nullable.getValue(move.StartingRank)) {
                                        rankCount = (rankCount + 1) | 0;
                                    }
                                }
                            } finally {
                                if (Bridge.is($t2, System.IDisposable)) {
                                    $t2.System$IDisposable$Dispose();
                                }
                            }

                            if (rankCount === 1) {
                                name = (name || "") + (ChessCompStompWithHacksEngine.MoveNaming.GetRankName(System.Nullable.getValue(move.StartingRank)) || "");
                            } else {
                                name = (name || "") + (ChessCompStompWithHacksEngine.MoveNaming.GetFileName(System.Nullable.getValue(move.StartingFile)) || "") + (ChessCompStompWithHacksEngine.MoveNaming.GetRankName(System.Nullable.getValue(move.StartingRank)) || "");
                            }
                        }
                    }

                    if (ChessCompStompWithHacksEngine.MoveUtil.IsCapturingMove(move, originalGameState.Board)) {
                        name = (name || "") + "x";
                    }

                    name = (name || "") + (ChessCompStompWithHacksEngine.MoveNaming.GetFileName(move.EndingFile) || "") + (ChessCompStompWithHacksEngine.MoveNaming.GetRankName(move.EndingRank) || "");

                    if (move.Promotion != null) {
                        name = (name || "") + (ChessCompStompWithHacksEngine.MoveNaming.GetPromotionString(move) || "");
                    }

                    var moveResult = ChessCompStompWithHacksEngine.MoveNaming.ApplyMove(move, originalGameState);

                    if (moveResult.IsCheck) {
                        name = (name || "") + "+";
                    }
                    if (moveResult.IsCheckmate) {
                        name = (name || "") + "#";
                    }

                    return name;
                },
                /**
                 * Returns the number of squares the rook moves
                 *
                 * @static
                 * @private
                 * @this ChessCompStompWithHacksEngine.MoveNaming
                 * @memberof ChessCompStompWithHacksEngine.MoveNaming
                 * @param   {ChessCompStompWithHacksEngine.Move}         castlingMove         
                 * @param   {ChessCompStompWithHacksEngine.GameState}    originalGameState
                 * @return  {number}
                 */
                GetLengthOfCastlingMove: function (castlingMove, originalGameState) {
                    var direction;
                    if (((castlingMove.EndingFile - System.Nullable.getValue(castlingMove.StartingFile)) | 0) === 2) {
                        direction = { Item1: 1, Item2: 0 };
                    } else {
                        if (((castlingMove.EndingFile - System.Nullable.getValue(castlingMove.StartingFile)) | 0) === -2) {
                            direction = { Item1: -1, Item2: 0 };
                        } else {
                            if (((castlingMove.EndingRank - System.Nullable.getValue(castlingMove.StartingRank)) | 0) === 2) {
                                direction = { Item1: 0, Item2: 1 };
                            } else {
                                if (((castlingMove.EndingRank - System.Nullable.getValue(castlingMove.StartingRank)) | 0) === -2) {
                                    direction = { Item1: 0, Item2: -1 };
                                } else {
                                    throw new System.Exception();
                                }
                            }
                        }
                    }

                    var rook = new ChessCompStompWithHacksEngine.ChessSquare(System.Nullable.getValue(castlingMove.StartingFile), System.Nullable.getValue(castlingMove.StartingRank));
                    var count = 0;
                    while (true) {
                        rook = new ChessCompStompWithHacksEngine.ChessSquare(((rook.File + direction.Item1) | 0), ((rook.Rank + direction.Item2) | 0));
                        count = (count + 1) | 0;
                        if (ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsRook(originalGameState.Board.GetPiece(rook))) {
                            break;
                        }
                    }

                    return ((count - 1) | 0);
                },
                GetNameOfCastlingMove: function (castlingMove, originalGameState) {
                    var $t;
                    var castlingLength = ChessCompStompWithHacksEngine.MoveNaming.GetLengthOfCastlingMove(castlingMove, originalGameState);

                    var allMoves = ChessCompStompWithHacksEngine.ComputeMoves.GetMoves(originalGameState).Moves;

                    var count = 0;
                    $t = Bridge.getEnumerator(allMoves);
                    try {
                        while ($t.moveNext()) {
                            var m = $t.Current;
                            if (ChessCompStompWithHacksEngine.MoveUtil.IsCastlingOrSuperCastling(m, originalGameState.Board)) {
                                if (m.Promotion == null || System.Nullable.getValue(m.Promotion) === ChessCompStompWithHacksEngine.Move.PromotionType.PromoteToQueen) {
                                    var length = ChessCompStompWithHacksEngine.MoveNaming.GetLengthOfCastlingMove(m, originalGameState);
                                    if (length === castlingLength) {
                                        count = (count + 1) | 0;
                                    }
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    var isAmbiguous = count > 1;

                    var name;

                    if (isAmbiguous || castlingLength === 0) {
                        name = "K" + (ChessCompStompWithHacksEngine.MoveNaming.GetFileName(castlingMove.EndingFile) || "") + (ChessCompStompWithHacksEngine.MoveNaming.GetRankName(castlingMove.EndingRank) || "");
                    } else {
                        switch (castlingLength) {
                            case 1: 
                                name = "0";
                                break;
                            case 2: 
                                name = "0-0";
                                break;
                            case 3: 
                                name = "0-0-0";
                                break;
                            case 4: 
                                name = "0-0-0-0";
                                break;
                            case 5: 
                                name = "0-0-0-0-0";
                                break;
                            case 6: 
                                name = "0-0-0-0-0-0";
                                break;
                            default: 
                                throw new System.Exception();
                        }
                    }

                    if (castlingMove.Promotion != null) {
                        name = (name || "") + (ChessCompStompWithHacksEngine.MoveNaming.GetPromotionString(castlingMove) || "");
                    }

                    var moveResult = ChessCompStompWithHacksEngine.MoveNaming.ApplyMove(castlingMove, originalGameState);

                    if (moveResult.IsCheck) {
                        name = (name || "") + "+";
                    }
                    if (moveResult.IsCheckmate) {
                        name = (name || "") + "#";
                    }

                    return name;
                },
                GetNameOfPawnMove: function (pawnMove, originalGameState) {
                    var name;
                    var isEnPassantOrSuperEnPassant;

                    var moveResult = ChessCompStompWithHacksEngine.MoveNaming.ApplyMove(pawnMove, originalGameState);

                    if (ChessCompStompWithHacksEngine.MoveUtil.IsCapturingMove(pawnMove, originalGameState.Board)) {
                        name = (ChessCompStompWithHacksEngine.MoveNaming.GetFileName(System.Nullable.getValue(pawnMove.StartingFile)) || "") + "x" + (ChessCompStompWithHacksEngine.MoveNaming.GetFileName(pawnMove.EndingFile) || "") + (ChessCompStompWithHacksEngine.MoveNaming.GetRankName(pawnMove.EndingRank) || "");

                        var potentialEnPassantSquare = new ChessCompStompWithHacksEngine.ChessSquare(pawnMove.EndingFile, System.Nullable.getValue(pawnMove.StartingRank));
                        isEnPassantOrSuperEnPassant = originalGameState.Board.GetPiece(potentialEnPassantSquare) !== moveResult.NewGameState.Board.GetPiece(potentialEnPassantSquare);
                    } else {
                        name = (ChessCompStompWithHacksEngine.MoveNaming.GetFileName(pawnMove.EndingFile) || "") + (ChessCompStompWithHacksEngine.MoveNaming.GetRankName(pawnMove.EndingRank) || "");
                        isEnPassantOrSuperEnPassant = false;
                    }

                    if (System.Nullable.hasValue(pawnMove.Promotion)) {
                        name = (name || "") + (ChessCompStompWithHacksEngine.MoveNaming.GetPromotionString(pawnMove) || "");
                    }

                    if (moveResult.IsCheck) {
                        name = (name || "") + "+";
                    }
                    if (moveResult.IsCheckmate) {
                        name = (name || "") + "#";
                    }

                    if (isEnPassantOrSuperEnPassant) {
                        name = (name || "") + " e.p.";
                    }

                    return name;
                },
                GetPromotionString: function (move) {
                    if (move.Promotion == null) {
                        return "";
                    }

                    switch (System.Nullable.getValue(move.Promotion)) {
                        case ChessCompStompWithHacksEngine.Move.PromotionType.PromoteToRook: 
                            return "=R";
                        case ChessCompStompWithHacksEngine.Move.PromotionType.PromoteToKnight: 
                            return "=N";
                        case ChessCompStompWithHacksEngine.Move.PromotionType.PromoteToBishop: 
                            return "=B";
                        case ChessCompStompWithHacksEngine.Move.PromotionType.PromoteToQueen: 
                            return "=Q";
                        default: 
                            throw new System.Exception();
                    }
                },
                GetNameOfNukeMove: function (nukeMove, originalGameState) {
                    var name = "ICBM";
                    name = (name || "") + (ChessCompStompWithHacksEngine.MoveNaming.GetFileName(nukeMove.EndingFile) || "") + (ChessCompStompWithHacksEngine.MoveNaming.GetRankName(nukeMove.EndingRank) || "");

                    var result = ChessCompStompWithHacksEngine.MoveNaming.ApplyMove(nukeMove, originalGameState);

                    if (result.IsCheck) {
                        return (name || "") + "+";
                    }
                    if (result.IsCheckmate) {
                        return (name || "") + "#";
                    }
                    return name;
                },
                ApplyMove: function (move, originalGameState) {
                    var newGameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(originalGameState, move);
                    var result = ChessCompStompWithHacksEngine.ComputeMoves.GetMoves(newGameState);

                    if (originalGameState.IsWhiteTurn && result.GameStatus === ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.WhiteVictory || !originalGameState.IsWhiteTurn && result.GameStatus === ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.BlackVictory) {
                        return new ChessCompStompWithHacksEngine.MoveNaming.MoveResult(newGameState, false, true);
                    }

                    var kingFile = null;
                    var kingRank = null;

                    for (var i = 0; i < 8; i = (i + 1) | 0) {
                        for (var j = 0; j < 8; j = (j + 1) | 0) {
                            var piece = newGameState.Board.GetPiece$1(i, j);
                            if (ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsKing(piece)) {
                                if (newGameState.IsWhiteTurn && ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsWhite(piece) || !newGameState.IsWhiteTurn && ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsBlack(piece)) {
                                    kingFile = i;
                                    kingRank = j;
                                    break;
                                }
                            }
                        }

                        if (kingFile != null) {
                            break;
                        }
                    }

                    var isCheck = ChessCompStompWithHacksEngine.CheckKingUnderAttack.IsKingUnderThreat(newGameState.Board, newGameState.Abilities, newGameState.IsWhiteTurn, newGameState.IsPlayerWhite, System.Nullable.getValue(kingFile), System.Nullable.getValue(kingRank));

                    return new ChessCompStompWithHacksEngine.MoveNaming.MoveResult(newGameState, isCheck, false);
                },
                GetRankName: function (rank) {
                    switch (rank) {
                        case 0: 
                            return "1";
                        case 1: 
                            return "2";
                        case 2: 
                            return "3";
                        case 3: 
                            return "4";
                        case 4: 
                            return "5";
                        case 5: 
                            return "6";
                        case 6: 
                            return "7";
                        case 7: 
                            return "8";
                        default: 
                            throw new System.Exception();
                    }
                },
                GetFileName: function (file) {
                    switch (file) {
                        case 0: 
                            return "a";
                        case 1: 
                            return "b";
                        case 2: 
                            return "c";
                        case 3: 
                            return "d";
                        case 4: 
                            return "e";
                        case 5: 
                            return "f";
                        case 6: 
                            return "g";
                        case 7: 
                            return "h";
                        default: 
                            throw new System.Exception();
                    }
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.MoveNaming.MoveResult", {
        $kind: "nested class",
        fields: {
            NewGameState: null,
            IsCheck: false,
            IsCheckmate: false
        },
        ctors: {
            ctor: function (newGameState, isCheck, isCheckmate) {
                this.$initialize();
                this.NewGameState = newGameState;
                this.IsCheck = isCheck;
                this.IsCheckmate = isCheckmate;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.MoveUtil", {
        statics: {
            methods: {
                IsCastlingOrSuperCastling: function (move, originalBoard) {
                    if (move.IsNuke) {
                        return false;
                    }

                    if (ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsKing(originalBoard.GetPiece$1(System.Nullable.getValue(move.StartingFile), System.Nullable.getValue(move.StartingRank))) === false) {
                        return false;
                    }

                    return Math.abs(((System.Nullable.getValue(move.StartingFile) - move.EndingFile) | 0)) === 2 || Math.abs(((System.Nullable.getValue(move.StartingRank) - move.EndingRank) | 0)) === 2;
                },
                IsCapturingMove: function (move, originalBoard) {
                    if (move.IsNuke) {
                        return false;
                    }

                    if (ChessCompStompWithHacksEngine.MoveUtil.IsCastlingOrSuperCastling(move, originalBoard)) {
                        return false;
                    }

                    if (originalBoard.GetPiece$1(move.EndingFile, move.EndingRank) !== ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                        return true;
                    }

                    return ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsPawn(originalBoard.GetPiece$1(System.Nullable.getValue(move.StartingFile), System.Nullable.getValue(move.StartingRank))) && System.Nullable.getValue(move.StartingFile) !== move.EndingFile;
                },
                IsPawnMove: function (move, originalBoard) {
                    if (move.IsNuke) {
                        return false;
                    }

                    return ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsPawn(originalBoard.GetPiece$1(System.Nullable.getValue(move.StartingFile), System.Nullable.getValue(move.StartingRank)));
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.Objective", {
        $kind: "enum",
        statics: {
            fields: {
                DefeatComputer: 0,
                DefeatComputerByPlayingAtMost25Moves: 1,
                DefeatComputerWith5QueensOnTheBoard: 2,
                CheckmateUsingAKnight: 3,
                PromoteAPieceToABishop: 4,
                LaunchANuke: 5,
                WinFinalBattle: 6,
                PlayAStupidOpening: 7,
                NukeYourOwnPieces: 8,
                WinByCastlingVeryLongAndPromotingRookToQueen: 9
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.ObjectiveChecker", {
        statics: {
            methods: {
                GetCompletedObjectives: function (originalGameState, move, isFinalBattle) {
                    var completedObjectives = new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.Objective)).ctor();

                    if (move.IsNuke) {
                        completedObjectives.add(ChessCompStompWithHacksEngine.Objective.LaunchANuke);
                    }

                    if (originalGameState.IsPlayerTurn() && System.Nullable.hasValue(move.Promotion) && System.Nullable.getValue(move.Promotion) === ChessCompStompWithHacksEngine.Move.PromotionType.PromoteToBishop) {
                        completedObjectives.add(ChessCompStompWithHacksEngine.Objective.PromoteAPieceToABishop);
                    }

                    var newGameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(originalGameState, move);
                    var newGameStatus = ChessCompStompWithHacksEngine.ComputeMoves.GetMoves(newGameState).GameStatus;

                    var hasPlayerWon = newGameStatus === ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.WhiteVictory && newGameState.IsPlayerWhite || newGameStatus === ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.BlackVictory && !newGameState.IsPlayerWhite;

                    if (hasPlayerWon) {
                        completedObjectives.add(ChessCompStompWithHacksEngine.Objective.DefeatComputer);
                    }

                    if (hasPlayerWon && isFinalBattle) {
                        completedObjectives.add(ChessCompStompWithHacksEngine.Objective.WinFinalBattle);
                    }

                    var numberOfMovesPlayedByPlayer;
                    if (newGameState.IsPlayerWhite) {
                        numberOfMovesPlayedByPlayer = (Bridge.Int.div(newGameState.TurnCount, 2)) | 0;
                    } else {
                        numberOfMovesPlayedByPlayer = (Bridge.Int.div((((newGameState.TurnCount - 1) | 0)), 2)) | 0;
                    }

                    if (hasPlayerWon && numberOfMovesPlayedByPlayer <= 25) {
                        completedObjectives.add(ChessCompStompWithHacksEngine.Objective.DefeatComputerByPlayingAtMost25Moves);
                    }

                    if (hasPlayerWon && ChessCompStompWithHacksEngine.ObjectiveChecker.AtLeast5QueensOnTheBoard(newGameState.Board)) {
                        completedObjectives.add(ChessCompStompWithHacksEngine.Objective.DefeatComputerWith5QueensOnTheBoard);
                    }

                    if (ChessCompStompWithHacksEngine.ObjectiveChecker.HasPlayerDeliveredCheckmateUsingAKnight(hasPlayerWon, newGameState)) {
                        completedObjectives.add(ChessCompStompWithHacksEngine.Objective.CheckmateUsingAKnight);
                    }

                    if (ChessCompStompWithHacksEngine.ObjectiveChecker.PlayedAStupidOpening(originalGameState, move)) {
                        completedObjectives.add(ChessCompStompWithHacksEngine.Objective.PlayAStupidOpening);
                    }

                    if (ChessCompStompWithHacksEngine.ObjectiveChecker.NukedOwnPieces(originalGameState, move)) {
                        completedObjectives.add(ChessCompStompWithHacksEngine.Objective.NukeYourOwnPieces);
                    }

                    if (ChessCompStompWithHacksEngine.ObjectiveChecker.WonByCastlingVeryLongAndPromotingToQueen(originalGameState, move)) {
                        completedObjectives.add(ChessCompStompWithHacksEngine.Objective.WinByCastlingVeryLongAndPromotingRookToQueen);
                    }

                    return completedObjectives;
                },
                WonByCastlingVeryLongAndPromotingToQueen: function (originalGameState, move) {
                    if (!originalGameState.IsPlayerTurn()) {
                        return false;
                    }

                    if (!ChessCompStompWithHacksEngine.MoveUtil.IsCastlingOrSuperCastling(move, originalGameState.Board)) {
                        return false;
                    }

                    var requiredMoveName = ChessCompStompWithHacksEngine.ObjectiveChecker.GetNameOfCastlingVeryLongAndPromotingToQueenWithCheckmateMove();

                    var moveName = ChessCompStompWithHacksEngine.MoveNaming.GetNameOfMove(move, originalGameState);

                    return Bridge.referenceEquals(moveName, requiredMoveName);
                },
                GetNameOfCastlingVeryLongAndPromotingToQueenWithCheckmateMove: function () {
                    var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7;
                    var underlyingBoard = System.Array.init(8, null, System.Array.type(ChessCompStompWithHacksEngine.ChessSquarePiece));
                    for (var i = 0; i < 8; i = (i + 1) | 0) {
                        underlyingBoard[System.Array.index(i, underlyingBoard)] = System.Array.init(8, 0, ChessCompStompWithHacksEngine.ChessSquarePiece);
                        for (var j = 0; j < 8; j = (j + 1) | 0) {
                            ($t = underlyingBoard[System.Array.index(i, underlyingBoard)])[System.Array.index(j, $t)] = ChessCompStompWithHacksEngine.ChessSquarePiece.Empty;
                        }
                    }

                    ($t1 = underlyingBoard[System.Array.index(0, underlyingBoard)])[System.Array.index(7, $t1)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKing;
                    ($t2 = underlyingBoard[System.Array.index(7, underlyingBoard)])[System.Array.index(7, $t2)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook;
                    ($t3 = underlyingBoard[System.Array.index(0, underlyingBoard)])[System.Array.index(6, $t3)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook;
                    ($t4 = underlyingBoard[System.Array.index(2, underlyingBoard)])[System.Array.index(6, $t4)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook;
                    ($t5 = underlyingBoard[System.Array.index(1, underlyingBoard)])[System.Array.index(0, $t5)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKing;

                    var board = new ChessCompStompWithHacksEngine.ChessSquarePieceArray.$ctor1(underlyingBoard);

                    var underlyingUnmovedPawns = System.Array.init(8, null, System.Array.type(System.Boolean));
                    for (var i1 = 0; i1 < 8; i1 = (i1 + 1) | 0) {
                        underlyingUnmovedPawns[System.Array.index(i1, underlyingUnmovedPawns)] = System.Array.init(8, false, System.Boolean);
                        for (var j1 = 0; j1 < 8; j1 = (j1 + 1) | 0) {
                            ($t6 = underlyingUnmovedPawns[System.Array.index(i1, underlyingUnmovedPawns)])[System.Array.index(j1, $t6)] = false;
                        }
                    }
                    var unmovedPawnsArray = new ChessCompStompWithHacksEngine.UnmovedPawnsArray.$ctor1(underlyingUnmovedPawns);

                    var gameState = new ChessCompStompWithHacksEngine.GameState(board, unmovedPawnsArray, 101, false, true, true, null, null, new ChessCompStompWithHacksEngine.GameState.CastlingRights(false, false, false, false), new ChessCompStompWithHacksEngine.GameState.PlayerAbilities(false, false, false, true, false, false, false, false, true, false, false, false));

                    var moves = ChessCompStompWithHacksEngine.ComputeMoves.GetMoves(gameState).Moves;

                    $t7 = Bridge.getEnumerator(moves);
                    try {
                        while ($t7.moveNext()) {
                            var move = $t7.Current;
                            if (!move.IsNuke && System.Nullable.getValue(move.StartingFile) === 0 && System.Nullable.getValue(move.StartingRank) === 7 && move.EndingFile === 2 && move.EndingRank === 7 && System.Nullable.hasValue(move.Promotion) && System.Nullable.getValue(move.Promotion) === ChessCompStompWithHacksEngine.Move.PromotionType.PromoteToQueen) {
                                return ChessCompStompWithHacksEngine.MoveNaming.GetNameOfMove(move, gameState);
                            }
                        }
                    } finally {
                        if (Bridge.is($t7, System.IDisposable)) {
                            $t7.System$IDisposable$Dispose();
                        }
                    }

                    throw new System.Exception();
                },
                NukedOwnPieces: function (originalGameState, move) {
                    var $t;
                    if (!originalGameState.IsPlayerTurn()) {
                        return false;
                    }

                    if (!move.IsNuke) {
                        return false;
                    }

                    var numPlayerPiecesNuked = 0;
                    var numOpponentPiecesNuked = 0;

                    var playerPieceValueNuked = 0;
                    var opponentPieceValueNuked = 0;

                    var nukedSquares = ChessCompStompWithHacksEngine.TacticalNukeUtil.GetNukedSquares$1(move.EndingFile, move.EndingRank);

                    $t = Bridge.getEnumerator(nukedSquares);
                    try {
                        while ($t.moveNext()) {
                            var nukedSquare = $t.Current;
                            var piece = originalGameState.Board.GetPiece(nukedSquare);

                            if (piece === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                                continue;
                            }

                            var isPlayerPiece = ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsWhite(piece) === originalGameState.IsPlayerWhite;

                            var pieceValue;
                            if (ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsPawn(piece)) {
                                pieceValue = 1;
                            } else {
                                if (ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsBishop(piece) || ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsKnight(piece)) {
                                    pieceValue = 3;
                                } else {
                                    if (ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsRook(piece)) {
                                        pieceValue = 5;
                                    } else {
                                        if (ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsQueen(piece)) {
                                            pieceValue = 9;
                                        } else {
                                            throw new System.Exception();
                                        }
                                    }
                                }
                            }

                            if (isPlayerPiece) {
                                numPlayerPiecesNuked = (numPlayerPiecesNuked + 1) | 0;
                                playerPieceValueNuked = (playerPieceValueNuked + pieceValue) | 0;
                            } else {
                                numOpponentPiecesNuked = (numOpponentPiecesNuked + 1) | 0;
                                opponentPieceValueNuked = (opponentPieceValueNuked + pieceValue) | 0;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    if (numPlayerPiecesNuked < 4) {
                        return false;
                    }

                    if (numPlayerPiecesNuked <= numOpponentPiecesNuked) {
                        return false;
                    }
                    if (((numPlayerPiecesNuked - numOpponentPiecesNuked) | 0) < 2) {
                        return false;
                    }

                    if (playerPieceValueNuked <= opponentPieceValueNuked) {
                        return false;
                    }
                    if (((playerPieceValueNuked - opponentPieceValueNuked) | 0) < 4) {
                        return false;
                    }

                    var kingSquare = ChessCompStompWithHacksEngine.CheckKingUnderAttack.FindLocationOfKing(originalGameState.Board, originalGameState.IsPlayerWhite);

                    var wasPlayerInCheck = ChessCompStompWithHacksEngine.CheckKingUnderAttack.IsKingUnderThreat(originalGameState.Board, originalGameState.Abilities, originalGameState.IsPlayerWhite, originalGameState.IsPlayerWhite, kingSquare.File, kingSquare.Rank);

                    if (wasPlayerInCheck) {
                        return false;
                    }

                    return true;
                },
                PlayedAStupidOpening: function (originalGameState, move) {
                    if (!originalGameState.IsPlayerTurn()) {
                        return false;
                    }

                    if (originalGameState.TurnCount !== 3 && originalGameState.TurnCount !== 4) {
                        return false;
                    }

                    if (move.IsNuke) {
                        return false;
                    }

                    var pieceBeingMoved = originalGameState.Board.GetPiece$1(System.Nullable.getValue(move.StartingFile), System.Nullable.getValue(move.StartingRank));

                    if (!ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsKing(pieceBeingMoved)) {
                        return false;
                    }

                    return System.Nullable.getValue(move.StartingFile) === move.EndingFile && System.Nullable.getValue(move.StartingRank) !== move.EndingRank;
                },
                AtLeast5QueensOnTheBoard: function (board) {
                    var count = 0;
                    for (var i = 0; i < 8; i = (i + 1) | 0) {
                        for (var j = 0; j < 8; j = (j + 1) | 0) {
                            if (ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsQueen(board.GetPiece$1(i, j))) {
                                count = (count + 1) | 0;
                            }
                        }
                    }

                    return count >= 5;
                },
                HasPlayerDeliveredCheckmateUsingAKnight: function (hasPlayerWon, gameState) {
                    var $t;
                    if (!hasPlayerWon) {
                        return false;
                    }

                    var playerKnight = gameState.IsPlayerWhite ? ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKnight : ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKnight;
                    var enemyKing = gameState.IsPlayerWhite ? ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKing : ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKing;

                    for (var i = 0; i < 8; i = (i + 1) | 0) {
                        for (var j = 0; j < 8; j = (j + 1) | 0) {
                            if (gameState.Board.GetPiece$1(i, j) === enemyKing) {
                                var knightMoves = new (System.Collections.Generic.List$1(System.Tuple$2(System.Int32,System.Int32))).ctor();
                                knightMoves.add({ Item1: ((i + 1) | 0), Item2: ((j + 2) | 0) });
                                knightMoves.add({ Item1: ((i + 1) | 0), Item2: ((j - 2) | 0) });
                                knightMoves.add({ Item1: ((i - 1) | 0), Item2: ((j + 2) | 0) });
                                knightMoves.add({ Item1: ((i - 1) | 0), Item2: ((j - 2) | 0) });
                                knightMoves.add({ Item1: ((i + 2) | 0), Item2: ((j + 1) | 0) });
                                knightMoves.add({ Item1: ((i + 2) | 0), Item2: ((j - 1) | 0) });
                                knightMoves.add({ Item1: ((i - 2) | 0), Item2: ((j + 1) | 0) });
                                knightMoves.add({ Item1: ((i - 2) | 0), Item2: ((j - 1) | 0) });
                                if (gameState.Abilities.CanKnightsMakeLargeKnightsMove) {
                                    knightMoves.add({ Item1: ((i + 1) | 0), Item2: ((j + 3) | 0) });
                                    knightMoves.add({ Item1: ((i + 1) | 0), Item2: ((j - 3) | 0) });
                                    knightMoves.add({ Item1: ((i - 1) | 0), Item2: ((j + 3) | 0) });
                                    knightMoves.add({ Item1: ((i - 1) | 0), Item2: ((j - 3) | 0) });
                                    knightMoves.add({ Item1: ((i + 3) | 0), Item2: ((j + 1) | 0) });
                                    knightMoves.add({ Item1: ((i + 3) | 0), Item2: ((j - 1) | 0) });
                                    knightMoves.add({ Item1: ((i - 3) | 0), Item2: ((j + 1) | 0) });
                                    knightMoves.add({ Item1: ((i - 3) | 0), Item2: ((j - 1) | 0) });
                                }

                                $t = Bridge.getEnumerator(knightMoves);
                                try {
                                    while ($t.moveNext()) {
                                        var knightMove = $t.Current;
                                        if (0 <= knightMove.Item1 && knightMove.Item1 < 8 && 0 <= knightMove.Item2 && knightMove.Item2 < 8) {
                                            if (gameState.Board.GetPiece$1(knightMove.Item1, knightMove.Item2) === playerKnight) {
                                                return true;
                                            }
                                        }
                                    }
                                } finally {
                                    if (Bridge.is($t, System.IDisposable)) {
                                        $t.System$IDisposable$Dispose();
                                    }
                                }
                            }
                        }
                    }

                    return false;
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.PromotionTypeUtil", {
        statics: {
            methods: {
                GetPromotedPiece: function (promotionType, isWhite) {
                    switch (promotionType) {
                        case ChessCompStompWithHacksEngine.Move.PromotionType.PromoteToRook: 
                            return isWhite ? ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook : ChessCompStompWithHacksEngine.ChessSquarePiece.BlackRook;
                        case ChessCompStompWithHacksEngine.Move.PromotionType.PromoteToKnight: 
                            return isWhite ? ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKnight : ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKnight;
                        case ChessCompStompWithHacksEngine.Move.PromotionType.PromoteToBishop: 
                            return isWhite ? ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteBishop : ChessCompStompWithHacksEngine.ChessSquarePiece.BlackBishop;
                        case ChessCompStompWithHacksEngine.Move.PromotionType.PromoteToQueen: 
                            return isWhite ? ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteQueen : ChessCompStompWithHacksEngine.ChessSquarePiece.BlackQueen;
                        default: 
                            throw new System.Exception();
                    }
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.TacticalNukeUtil", {
        statics: {
            fields: {
                NumberOfMovesPlayedBeforeNukeIsAvailable: 0
            },
            ctors: {
                init: function () {
                    this.NumberOfMovesPlayedBeforeNukeIsAvailable = 10;
                }
            },
            methods: {
                GetNukedSquares: function (chessSquare) {
                    return ChessCompStompWithHacksEngine.TacticalNukeUtil.GetNukedSquares$1(chessSquare.File, chessSquare.Rank);
                },
                GetNukedSquares$1: function (file, rank) {
                    if (file < 0 || file >= 8) {
                        throw new System.Exception("File not in range: " + (DTLibrary.StringUtil.ToStringCultureInvariant(file) || ""));
                    }

                    if (rank < 0 || rank >= 8) {
                        throw new System.Exception("Rank not in range: " + (DTLibrary.StringUtil.ToStringCultureInvariant(rank) || ""));
                    }

                    var list = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor();

                    ChessCompStompWithHacksEngine.TacticalNukeUtil.TryAddSquare(list, ((file - 3) | 0), rank);
                    ChessCompStompWithHacksEngine.TacticalNukeUtil.TryAddSquare(list, ((file + 3) | 0), rank);

                    for (var j = -1; j <= 1; j = (j + 1) | 0) {
                        ChessCompStompWithHacksEngine.TacticalNukeUtil.TryAddSquare(list, ((file - 2) | 0), ((rank + j) | 0));
                        ChessCompStompWithHacksEngine.TacticalNukeUtil.TryAddSquare(list, ((file + 2) | 0), ((rank + j) | 0));
                    }

                    for (var j1 = -2; j1 <= 2; j1 = (j1 + 1) | 0) {
                        ChessCompStompWithHacksEngine.TacticalNukeUtil.TryAddSquare(list, ((file - 1) | 0), ((rank + j1) | 0));
                        ChessCompStompWithHacksEngine.TacticalNukeUtil.TryAddSquare(list, ((file + 1) | 0), ((rank + j1) | 0));
                    }

                    for (var j2 = -3; j2 <= 3; j2 = (j2 + 1) | 0) {
                        ChessCompStompWithHacksEngine.TacticalNukeUtil.TryAddSquare(list, file, ((rank + j2) | 0));
                    }

                    return list;
                },
                TryAddSquare: function (list, file, rank) {
                    if (0 <= file && file < 8 && 0 <= rank && rank < 8) {
                        list.add(new ChessCompStompWithHacksEngine.ChessSquare(file, rank));
                    }
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.UnmovedPawnsArray", {
        inherits: function () { return [System.IEquatable$1(ChessCompStompWithHacksEngine.UnmovedPawnsArray)]; },
        statics: {
            methods: {
                CopyBoard: function (board) {
                    var $t, $t1;
                    var newBoard = System.Array.init(8, null, System.Array.type(System.Boolean));
                    for (var i = 0; i < 8; i = (i + 1) | 0) {
                        newBoard[System.Array.index(i, newBoard)] = System.Array.init(8, false, System.Boolean);
                        for (var j = 0; j < 8; j = (j + 1) | 0) {
                            ($t = newBoard[System.Array.index(i, newBoard)])[System.Array.index(j, $t)] = ($t1 = board[System.Array.index(i, board)])[System.Array.index(j, $t1)];
                        }
                    }

                    return newBoard;
                }
            }
        },
        fields: {
            board: null,
            hashCode: null
        },
        alias: ["equalsT", "System$IEquatable$1$ChessCompStompWithHacksEngine$UnmovedPawnsArray$equalsT"],
        ctors: {
            ctor: function () {
                this.$initialize();
                this.board = null;
                this.hashCode = null;
            },
            $ctor1: function (board) {
                this.$initialize();
                this.board = ChessCompStompWithHacksEngine.UnmovedPawnsArray.CopyBoard(board);
                this.hashCode = null;
            }
        },
        methods: {
            HasUnmovedPawn: function (file, rank) {
                var $t;
                return ($t = this.board[System.Array.index(file, this.board)])[System.Array.index(rank, $t)];
            },
            PawnMoved: function (file, rank) {
                var $t, $t1, $t2;
                var newBoard = System.Array.init(8, null, System.Array.type(System.Boolean));

                for (var i = 0; i < 8; i = (i + 1) | 0) {
                    if (i !== file) {
                        newBoard[System.Array.index(i, newBoard)] = this.board[System.Array.index(i, this.board)];
                    } else {
                        newBoard[System.Array.index(i, newBoard)] = System.Array.init(8, false, System.Boolean);
                        for (var j = 0; j < 8; j = (j + 1) | 0) {
                            ($t = newBoard[System.Array.index(i, newBoard)])[System.Array.index(j, $t)] = ($t1 = this.board[System.Array.index(i, this.board)])[System.Array.index(j, $t1)];
                        }
                        ($t2 = newBoard[System.Array.index(i, newBoard)])[System.Array.index(rank, $t2)] = false;
                    }
                }

                var returnValue = new ChessCompStompWithHacksEngine.UnmovedPawnsArray.ctor();
                returnValue.board = newBoard;

                return returnValue;
            },
            equals: function (obj) {
                return this.equalsT(Bridge.as(obj, ChessCompStompWithHacksEngine.UnmovedPawnsArray));
            },
            equalsT: function (other) {
                var $t, $t1;
                if (other == null) {
                    return false;
                }

                if (Bridge.referenceEquals(this, other)) {
                    return true;
                }

                for (var i = 0; i < 8; i = (i + 1) | 0) {
                    for (var j = 0; j < 8; j = (j + 1) | 0) {
                        if (($t = this.board[System.Array.index(i, this.board)])[System.Array.index(j, $t)] !== ($t1 = other.board[System.Array.index(i, other.board)])[System.Array.index(j, $t1)]) {
                            return false;
                        }
                    }
                }

                return true;
            },
            getHashCode: function () {
                var $t;
                if (System.Nullable.hasValue(this.hashCode)) {
                    return System.Nullable.getValue(this.hashCode);
                }

                var hashCode = 0;

                for (var i = 0; i < 8; i = (i + 1) | 0) {
                    for (var j = 0; j < 8; j = (j + 1) | 0) {
                        hashCode = Bridge.Int.mul(hashCode, 17);
                        if (($t = this.board[System.Array.index(i, this.board)])[System.Array.index(j, $t)]) {
                            hashCode = ((hashCode + 1) | 0);
                        }
                    }
                }

                this.hashCode = hashCode;
                return System.Nullable.getValue(this.hashCode);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.AIHackLevelSelectionBoardPreview", {
        statics: {
            methods: {
                GetRenderSquare: function (i, j, renderFromWhitePerspective) {
                    if (renderFromWhitePerspective) {
                        return new ChessCompStompWithHacksEngine.ChessSquare(i, j);
                    }

                    return new ChessCompStompWithHacksEngine.ChessSquare(((7 - i) | 0), ((7 - j) | 0));
                },
                Render: function (isPlayerWhite, researchedHacks, aiHackLevel, displayOutput) {
                    var gameState = ChessCompStompWithHacksLibrary.NewGameCreation.CreateNewGame(isPlayerWhite, researchedHacks, aiHackLevel);

                    var board = gameState.Board;

                    var scalingFactorScaled = 10;

                    var width = (Bridge.Int.div(Bridge.Int.mul(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetWidth(ChessCompStompWithHacksLibrary.GameImage.WhitePawn), scalingFactorScaled), 128)) | 0;
                    var height = (Bridge.Int.div(Bridge.Int.mul(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetHeight(ChessCompStompWithHacksLibrary.GameImage.WhitePawn), scalingFactorScaled), 128)) | 0;

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, ((Bridge.Int.mul(width, 8) + 20) | 0), ((Bridge.Int.mul(height, 8) + 20) | 0), DTLibrary.DTColor.White(), true);

                    var darkSquareColor = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetDarkSquareColor(ChessCompStompWithHacksLibrary.ColorTheme.Final);
                    var lightSquareColor = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetLightSquareColor(ChessCompStompWithHacksLibrary.ColorTheme.Final);

                    for (var i = 0; i < 8; i = (i + 1) | 0) {
                        for (var j = 0; j < 8; j = (j + 1) | 0) {
                            var renderSquare = ChessCompStompWithHacksLibrary.AIHackLevelSelectionBoardPreview.GetRenderSquare(i, j, isPlayerWhite);

                            displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(((10 + Bridge.Int.mul(renderSquare.File, width)) | 0), ((10 + Bridge.Int.mul(renderSquare.Rank, height)) | 0), width, height, (((i + j) | 0)) % 2 === 0 ? darkSquareColor : lightSquareColor, true);
                        }
                    }

                    for (var i1 = 0; i1 < 8; i1 = (i1 + 1) | 0) {
                        for (var j1 = 0; j1 < 8; j1 = (j1 + 1) | 0) {
                            var square = board.GetPiece$1(i1, j1);

                            var renderSquare1 = ChessCompStompWithHacksLibrary.AIHackLevelSelectionBoardPreview.GetRenderSquare(i1, j1, isPlayerWhite);

                            if (square === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                                continue;
                            }

                            displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawImageRotatedClockwise$1(ChessCompStompWithHacksLibrary.GameImageUtil.GetImage(square), ((10 + Bridge.Int.mul(renderSquare1.File, width)) | 0), ((10 + Bridge.Int.mul(renderSquare1.Rank, height)) | 0), 0, scalingFactorScaled);
                        }
                    }
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.AIHackLevelSelectionButton", {
        fields: {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            text: null,
            textXOffset: 0,
            textYOffset: 0,
            font: 0,
            isMobileDisplayType: false,
            isPlayerWhite: false,
            researchedHacks: null,
            hoveredHackLevel: null,
            clickedHackLevel: null,
            previousMouseInput: null
        },
        ctors: {
            ctor: function (x, y, width, height, text, textXOffset, textYOffset, font, isPlayerWhite, researchedHacks, isMobileDisplayType) {
                this.$initialize();
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.text = text;
                this.textXOffset = textXOffset;
                this.textYOffset = textYOffset;
                this.font = font;

                this.isMobileDisplayType = isMobileDisplayType;

                this.isPlayerWhite = isPlayerWhite;
                this.researchedHacks = researchedHacks;

                this.hoveredHackLevel = null;
                this.clickedHackLevel = null;

                this.previousMouseInput = null;
            }
        },
        methods: {
            SetX: function (x) {
                this.x = x;
            },
            SetY: function (y) {
                this.y = y;
            },
            IsHover: function (mouseInput) {
                var mouseX = mouseInput.DTLibrary$IMouse$GetX();
                var mouseY = mouseInput.DTLibrary$IMouse$GetY();
                var isHover = this.x <= mouseX && mouseX <= ((this.x + this.width) | 0) && this.y <= mouseY && mouseY <= ((this.y + this.height) | 0);

                if (!isHover) {
                    return null;
                }

                var offset = (mouseX - this.x) | 0;

                if (offset < ((Bridge.Int.div(this.width, 4)) | 0)) {
                    return ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.Initial;
                }
                if (offset < ((Bridge.Int.div(this.width, 2)) | 0)) {
                    return ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.UpgradedOnce;
                }
                if (offset < ((Bridge.Int.div(Bridge.Int.mul(this.width, 3), 4)) | 0)) {
                    return ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.UpgradedTwice;
                }
                return ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.UpgradedThrice;
            },
            ProcessFrame: function (mouseInput, previousMouseInput) {
                if (this.previousMouseInput != null) {
                    previousMouseInput = this.previousMouseInput;
                }

                this.previousMouseInput = new DTLibrary.CopiedMouse(mouseInput);

                var hoveredAIHackLevel = this.IsHover(mouseInput);

                this.hoveredHackLevel = hoveredAIHackLevel;

                if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                    if (System.Nullable.hasValue(hoveredAIHackLevel)) {
                        this.clickedHackLevel = System.Nullable.getValue(this.hoveredHackLevel);
                    }
                }

                if (this.isMobileDisplayType) {
                    if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && System.Nullable.hasValue(hoveredAIHackLevel) && System.Nullable.hasValue(this.clickedHackLevel)) {
                        this.clickedHackLevel = System.Nullable.getValue(hoveredAIHackLevel);
                    }
                }

                if (System.Nullable.hasValue(this.clickedHackLevel) && !mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                    if (System.Nullable.hasValue(hoveredAIHackLevel) && System.Nullable.getValue(hoveredAIHackLevel) === System.Nullable.getValue(this.clickedHackLevel)) {
                        this.clickedHackLevel = null;
                        return System.Nullable.getValue(hoveredAIHackLevel);
                    }

                    this.clickedHackLevel = null;
                }

                return null;
            },
            RenderButton: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(this.x, this.y, ((this.width - 1) | 0), ((this.height - 1) | 0), new DTLibrary.DTColor.ctor(200, 200, 200), true);

                if (System.Nullable.hasValue(this.hoveredHackLevel) && !this.isMobileDisplayType) {
                    var offset;
                    var colorTheme = new ChessCompStompWithHacksLibrary.ColorTheme();

                    switch (System.Nullable.getValue(this.hoveredHackLevel)) {
                        case ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.Initial: 
                            offset = 0;
                            colorTheme = ChessCompStompWithHacksLibrary.ColorTheme.Initial;
                            break;
                        case ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.UpgradedOnce: 
                            offset = (Bridge.Int.div(this.width, 4)) | 0;
                            colorTheme = ChessCompStompWithHacksLibrary.ColorTheme.Progress1;
                            break;
                        case ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.UpgradedTwice: 
                            offset = (Bridge.Int.div(this.width, 2)) | 0;
                            colorTheme = ChessCompStompWithHacksLibrary.ColorTheme.Progress2;
                            break;
                        case ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.UpgradedThrice: 
                            offset = (Bridge.Int.div(Bridge.Int.mul(this.width, 3), 4)) | 0;
                            colorTheme = ChessCompStompWithHacksLibrary.ColorTheme.Progress3;
                            break;
                        case ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.FinalBattle: 
                        default: 
                            throw new System.Exception();
                    }

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(((this.x + offset) | 0), this.y, ((((Bridge.Int.div(this.width, 4)) | 0) - 1) | 0), ((this.height - 1) | 0), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(colorTheme), true);
                }

                if (System.Nullable.hasValue(this.clickedHackLevel)) {
                    var offset1;
                    var colorTheme1 = new ChessCompStompWithHacksLibrary.ColorTheme();

                    switch (System.Nullable.getValue(this.clickedHackLevel)) {
                        case ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.Initial: 
                            offset1 = 0;
                            colorTheme1 = ChessCompStompWithHacksLibrary.ColorTheme.Initial;
                            break;
                        case ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.UpgradedOnce: 
                            offset1 = (Bridge.Int.div(this.width, 4)) | 0;
                            colorTheme1 = ChessCompStompWithHacksLibrary.ColorTheme.Progress1;
                            break;
                        case ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.UpgradedTwice: 
                            offset1 = (Bridge.Int.div(this.width, 2)) | 0;
                            colorTheme1 = ChessCompStompWithHacksLibrary.ColorTheme.Progress2;
                            break;
                        case ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.UpgradedThrice: 
                            offset1 = (Bridge.Int.div(Bridge.Int.mul(this.width, 3), 4)) | 0;
                            colorTheme1 = ChessCompStompWithHacksLibrary.ColorTheme.Progress3;
                            break;
                        case ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.FinalBattle: 
                        default: 
                            throw new System.Exception();
                    }

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(((this.x + offset1) | 0), this.y, ((((Bridge.Int.div(this.width, 4)) | 0) - 1) | 0), ((this.height - 1) | 0), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(colorTheme1), true);
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(this.x, this.y, this.width, this.height, DTLibrary.DTColor.Black(), false);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((this.x + this.textXOffset) | 0), ((((this.y + this.height) | 0) - this.textYOffset) | 0), this.text, this.font, DTLibrary.DTColor.Black());
            },
            RenderBoardPreview: function (displayOutput) {
                var previewAIHackLevel;

                if (System.Nullable.hasValue(this.clickedHackLevel)) {
                    previewAIHackLevel = System.Nullable.getValue(this.clickedHackLevel);
                } else {
                    if (System.Nullable.hasValue(this.hoveredHackLevel) && !this.isMobileDisplayType) {
                        previewAIHackLevel = System.Nullable.getValue(this.hoveredHackLevel);
                    } else {
                        previewAIHackLevel = null;
                    }
                }

                if (System.Nullable.hasValue(previewAIHackLevel)) {
                    ChessCompStompWithHacksLibrary.AIHackLevelSelectionBoardPreview.Render(this.isPlayerWhite, this.researchedHacks, System.Nullable.getValue(previewAIHackLevel), new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, ((this.x + 34) | 0), ((((this.y + this.height) | 0) + 10) | 0)));
                }
            }
        }
    });

    Bridge.definei("DTLibrary.IFrame$4", function (ImageEnum, FontEnum, SoundEnum, MusicEnum) { return {
        $kind: "interface"
    }; });

    Bridge.define("ChessCompStompWithHacksLibrary.AIMessageType", {
        $kind: "enum",
        statics: {
            fields: {
                AIHackMessage: 0,
                FinalBattleMessage: 1
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.Button", {
        fields: {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            backgroundColor: null,
            hoverColor: null,
            clickColor: null,
            text: null,
            textXOffset: 0,
            textYOffset: 0,
            font: 0,
            isHover: false,
            isClicked: false,
            isMobileDisplayType: false,
            previousMouseInput: null
        },
        ctors: {
            ctor: function (x, y, width, height, backgroundColor, hoverColor, clickColor, text, textXOffset, textYOffset, font, isMobileDisplayType) {
                this.$initialize();
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.backgroundColor = backgroundColor;
                this.hoverColor = hoverColor;
                this.clickColor = clickColor;
                this.text = text;
                this.textXOffset = textXOffset;
                this.textYOffset = textYOffset;
                this.font = font;

                this.isHover = false;
                this.isClicked = false;

                this.previousMouseInput = null;

                this.isMobileDisplayType = isMobileDisplayType;
            }
        },
        methods: {
            SetX: function (x) {
                this.x = x;
            },
            SetY: function (y) {
                this.y = y;
            },
            SetWidth: function (width) {
                this.width = width;
            },
            SetHeight: function (height) {
                this.height = height;
            },
            SetText: function (text) {
                this.text = text;
            },
            SetTextXOffset: function (textXOffset) {
                this.textXOffset = textXOffset;
            },
            SetTextYOffset: function (textYOffset) {
                this.textYOffset = textYOffset;
            },
            SetIsMobileDisplayType: function (isMobileDisplayType) {
                this.isMobileDisplayType = isMobileDisplayType;
            },
            IsHover: function (mouseInput) {
                var mouseX = mouseInput.DTLibrary$IMouse$GetX();
                var mouseY = mouseInput.DTLibrary$IMouse$GetY();
                return this.x <= mouseX && mouseX <= ((this.x + this.width) | 0) && this.y <= mouseY && mouseY <= ((this.y + this.height) | 0);
            },
            /**
             * Returns whether or not the user has clicked the button
             *
             * @instance
             * @public
             * @this ChessCompStompWithHacksLibrary.Button
             * @memberof ChessCompStompWithHacksLibrary.Button
             * @param   {DTLibrary.IMouse}    mouseInput            
             * @param   {DTLibrary.IMouse}    previousMouseInput
             * @return  {boolean}
             */
            ProcessFrame: function (mouseInput, previousMouseInput) {
                if (this.previousMouseInput != null) {
                    previousMouseInput = this.previousMouseInput;
                }

                this.previousMouseInput = new DTLibrary.CopiedMouse(mouseInput);

                var inRange = this.IsHover(mouseInput);

                this.isHover = inRange;

                if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                    if (inRange) {
                        this.isClicked = true;
                    }
                }

                if (this.isClicked && !mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                    this.isClicked = false;

                    if (inRange) {
                        return true;
                    }
                }

                return false;
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(this.x, this.y, this.width, this.height, this.isClicked ? this.clickColor : ((this.isHover && !this.isMobileDisplayType) ? this.hoverColor : this.backgroundColor), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(this.x, this.y, this.width, this.height, DTLibrary.DTColor.Black(), false);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((this.x + this.textXOffset) | 0), ((((this.y + this.height) | 0) - this.textYOffset) | 0), this.text, this.font, DTLibrary.DTColor.Black());
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ChessPiecesRenderer", {
        statics: {
            fields: {
                NUKE_BEGIN_LANDING_MICROSECONDS: 0,
                NUKE_IMPACT_MICROSECONDS: 0,
                NUKE_EXPLOSION_FINISHED_MICROSECONDS: 0,
                NUKE_ANIMATION_COMPLETED_MICROSECONDS: 0
            },
            ctors: {
                init: function () {
                    this.NUKE_BEGIN_LANDING_MICROSECONDS = 1000000;
                    this.NUKE_IMPACT_MICROSECONDS = 1300000;
                    this.NUKE_EXPLOSION_FINISHED_MICROSECONDS = 1600000;
                    this.NUKE_ANIMATION_COMPLETED_MICROSECONDS = 1650000;
                }
            },
            methods: {
                GetChessPiecesRenderer: function (pieces, kingInDangerSquare, previousMoveSquares, renderFromWhitePerspective, colorTheme) {
                    return new ChessCompStompWithHacksLibrary.ChessPiecesRenderer(pieces, kingInDangerSquare, previousMoveSquares, null, DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList(), null, null, null, renderFromWhitePerspective, null, null, null, colorTheme);
                },
                GetHoverSquare: function (mouseInput, renderFromWhitePerspective, chessPieceScalingFactor, displayProcessing) {
                    var width = (Bridge.Int.div(Bridge.Int.mul(displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetWidth(ChessCompStompWithHacksLibrary.GameImage.WhitePawn), chessPieceScalingFactor), 128)) | 0;
                    var height = (Bridge.Int.div(Bridge.Int.mul(displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetHeight(ChessCompStompWithHacksLibrary.GameImage.WhitePawn), chessPieceScalingFactor), 128)) | 0;

                    var mouseX = mouseInput.DTLibrary$IMouse$GetX();
                    var mouseY = mouseInput.DTLibrary$IMouse$GetY();

                    if (mouseX < 0 || mouseY < 0) {
                        return null;
                    }

                    var i = (Bridge.Int.div(mouseX, width)) | 0;
                    var j = (Bridge.Int.div(mouseY, height)) | 0;

                    if (0 <= i && i < 8 && 0 <= j && j < 8) {
                        if (renderFromWhitePerspective) {
                            return new ChessCompStompWithHacksEngine.ChessSquare(i, j);
                        } else {
                            return new ChessCompStompWithHacksEngine.ChessSquare(((7 - i) | 0), ((7 - j) | 0));
                        }
                    }

                    return null;
                },
                GetRenderSquare$1: function (i, j, renderFromWhitePerspective) {
                    if (renderFromWhitePerspective) {
                        return new ChessCompStompWithHacksEngine.ChessSquare(i, j);
                    }

                    return new ChessCompStompWithHacksEngine.ChessSquare(((7 - i) | 0), ((7 - j) | 0));
                },
                GetRenderSquare: function (square, renderFromWhitePerspective) {
                    return ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetRenderSquare$1(square.File, square.Rank, renderFromWhitePerspective);
                },
                GetDarkSquareColor: function (colorTheme) {
                    switch (colorTheme) {
                        case ChessCompStompWithHacksLibrary.ColorTheme.Initial: 
                            return new DTLibrary.DTColor.ctor(140, 89, 11);
                        case ChessCompStompWithHacksLibrary.ColorTheme.Progress1: 
                            return new DTLibrary.DTColor.ctor(140, 80, 11);
                        case ChessCompStompWithHacksLibrary.ColorTheme.Progress2: 
                            return new DTLibrary.DTColor.ctor(140, 71, 11);
                        case ChessCompStompWithHacksLibrary.ColorTheme.Progress3: 
                            return new DTLibrary.DTColor.ctor(140, 63, 11);
                        case ChessCompStompWithHacksLibrary.ColorTheme.Final: 
                            return new DTLibrary.DTColor.ctor(140, 54, 11);
                        default: 
                            throw new System.Exception();
                    }
                },
                GetLightSquareColor: function (colorTheme) {
                    switch (colorTheme) {
                        case ChessCompStompWithHacksLibrary.ColorTheme.Initial: 
                            return new DTLibrary.DTColor.ctor(194, 146, 74);
                        case ChessCompStompWithHacksLibrary.ColorTheme.Progress1: 
                            return new DTLibrary.DTColor.ctor(194, 138, 74);
                        case ChessCompStompWithHacksLibrary.ColorTheme.Progress2: 
                            return new DTLibrary.DTColor.ctor(194, 130, 74);
                        case ChessCompStompWithHacksLibrary.ColorTheme.Progress3: 
                            return new DTLibrary.DTColor.ctor(194, 122, 74);
                        case ChessCompStompWithHacksLibrary.ColorTheme.Final: 
                            return new DTLibrary.DTColor.ctor(194, 114, 74);
                        default: 
                            throw new System.Exception();
                    }
                },
                GetPossibleMoveSquareColor: function (colorTheme) {
                    switch (colorTheme) {
                        case ChessCompStompWithHacksLibrary.ColorTheme.Initial: 
                            return new DTLibrary.DTColor.ctor(0, 128, 0);
                        case ChessCompStompWithHacksLibrary.ColorTheme.Progress1: 
                            return new DTLibrary.DTColor.ctor(0, 128, 0);
                        case ChessCompStompWithHacksLibrary.ColorTheme.Progress2: 
                            return new DTLibrary.DTColor.ctor(226, 255, 94);
                        case ChessCompStompWithHacksLibrary.ColorTheme.Progress3: 
                            return new DTLibrary.DTColor.ctor(226, 255, 94);
                        case ChessCompStompWithHacksLibrary.ColorTheme.Final: 
                            return new DTLibrary.DTColor.ctor(226, 255, 94);
                        default: 
                            throw new System.Exception();
                    }
                }
            }
        },
        fields: {
            pieces: null,
            kingInDangerSquare: null,
            previousMoveSquares: null,
            selectedPieceSquare: null,
            possibleMoveSquares: null,
            potentialNukeSquaresInfo: null,
            hoverSquare: null,
            hoverPieceInfo: null,
            renderFromWhitePerspective: false,
            nukeAnimationMicroseconds: null,
            nukeCenter: null,
            nukedSquares: null,
            colorTheme: 0
        },
        ctors: {
            ctor: function (pieces, kingInDangerSquare, previousMoveSquares, selectedPieceSquare, possibleMoveSquares, potentialNukeSquaresInfo, hoverSquare, hoverPieceInfo, renderFromWhitePerspective, nukeAnimationMicroseconds, nukeCenter, nukedSquares, colorTheme) {
                this.$initialize();
                this.pieces = pieces;
                this.kingInDangerSquare = kingInDangerSquare;
                this.previousMoveSquares = previousMoveSquares;
                this.selectedPieceSquare = selectedPieceSquare;
                this.possibleMoveSquares = possibleMoveSquares;
                this.potentialNukeSquaresInfo = potentialNukeSquaresInfo;
                this.hoverSquare = hoverSquare;
                this.hoverPieceInfo = hoverPieceInfo;
                this.renderFromWhitePerspective = renderFromWhitePerspective;
                this.nukeAnimationMicroseconds = nukeAnimationMicroseconds;
                this.nukeCenter = nukeCenter;
                this.nukedSquares = nukedSquares;
                this.colorTheme = colorTheme;
            }
        },
        methods: {
            LandNuke: function (nukeCenter) {
                var nukedSquares = ChessCompStompWithHacksEngine.TacticalNukeUtil.GetNukedSquares(nukeCenter);

                return new ChessCompStompWithHacksLibrary.ChessPiecesRenderer(this.pieces, this.kingInDangerSquare, this.previousMoveSquares, this.selectedPieceSquare, this.possibleMoveSquares, this.potentialNukeSquaresInfo, this.hoverSquare, this.hoverPieceInfo, this.renderFromWhitePerspective, 0, nukeCenter, new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor2(nukedSquares), this.colorTheme);
            },
            ProcessFrame: function (pieces, kingInDangerSquare, previousMoveSquares, selectedPieceSquare, possibleMoveSquares, potentialNukeSquaresInfo, hoverSquare, hoverPieceInfo, elapsedMicrosPerFrame) {
                var newNukeAnimationMicroseconds;
                if (this.nukeAnimationMicroseconds == null) {
                    newNukeAnimationMicroseconds = null;
                } else {
                    newNukeAnimationMicroseconds = Bridge.Int.clip32(System.Nullable.getValue(this.nukeAnimationMicroseconds) + elapsedMicrosPerFrame);
                }

                if (System.Nullable.hasValue(newNukeAnimationMicroseconds) && System.Nullable.getValue(newNukeAnimationMicroseconds) > ChessCompStompWithHacksLibrary.ChessPiecesRenderer.NUKE_ANIMATION_COMPLETED_MICROSECONDS) {
                    newNukeAnimationMicroseconds = 1650001;
                }

                return new ChessCompStompWithHacksLibrary.ChessPiecesRenderer(pieces, kingInDangerSquare, previousMoveSquares, selectedPieceSquare, possibleMoveSquares, potentialNukeSquaresInfo, hoverSquare, hoverPieceInfo, this.renderFromWhitePerspective, newNukeAnimationMicroseconds, this.nukeCenter, this.nukedSquares, this.colorTheme);
            },
            HasNukeLanded: function () {
                return System.Nullable.hasValue(this.nukeAnimationMicroseconds) && System.Nullable.getValue(this.nukeAnimationMicroseconds) >= ChessCompStompWithHacksLibrary.ChessPiecesRenderer.NUKE_IMPACT_MICROSECONDS;
            },
            HasNukeFinished: function () {
                return System.Nullable.hasValue(this.nukeAnimationMicroseconds) && System.Nullable.getValue(this.nukeAnimationMicroseconds) >= ChessCompStompWithHacksLibrary.ChessPiecesRenderer.NUKE_ANIMATION_COMPLETED_MICROSECONDS;
            },
            Render: function (displayOutput, chessPiecesRendererPieceAnimation, chessPieceScalingFactor, isMobileDisplayType) {
                var $t, $t1, $t2, $t3, $t4, $t5;
                var width = (Bridge.Int.div(Bridge.Int.mul(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetWidth(ChessCompStompWithHacksLibrary.GameImage.WhitePawn), chessPieceScalingFactor), 128)) | 0;
                var height = (Bridge.Int.div(Bridge.Int.mul(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetHeight(ChessCompStompWithHacksLibrary.GameImage.WhitePawn), chessPieceScalingFactor), 128)) | 0;

                var darkSquareColor = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetDarkSquareColor(this.colorTheme);
                var lightSquareColor = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetLightSquareColor(this.colorTheme);

                for (var i = 0; i < 8; i = (i + 1) | 0) {
                    for (var j = 0; j < 8; j = (j + 1) | 0) {
                        var renderSquare = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetRenderSquare$1(i, j, this.renderFromWhitePerspective);

                        displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(Bridge.Int.mul(renderSquare.File, width), Bridge.Int.mul(renderSquare.Rank, height), width, height, (((i + j) | 0)) % 2 === 0 ? darkSquareColor : lightSquareColor, true);
                    }
                }

                for (var i1 = 0; i1 < this.previousMoveSquares.Count; i1 = (i1 + 1) | 0) {
                    var previousMoveSquare = this.previousMoveSquares.getItem(i1);
                    var renderSquare1 = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetRenderSquare(previousMoveSquare, this.renderFromWhitePerspective);
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(Bridge.Int.mul(renderSquare1.File, width), Bridge.Int.mul(renderSquare1.Rank, height), width, height, (((previousMoveSquare.File + previousMoveSquare.Rank) | 0)) % 2 === 0 ? new DTLibrary.DTColor.ctor(134, 109, 70) : new DTLibrary.DTColor.ctor(161, 137, 101), true);
                }

                if (this.kingInDangerSquare != null) {
                    var renderSquare2 = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetRenderSquare(this.kingInDangerSquare, this.renderFromWhitePerspective);
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(Bridge.Int.mul(renderSquare2.File, width), Bridge.Int.mul(renderSquare2.Rank, height), width, height, (((this.kingInDangerSquare.File + this.kingInDangerSquare.Rank) | 0)) % 2 === 0 ? new DTLibrary.DTColor.ctor(198, 44, 5) : new DTLibrary.DTColor.ctor(225, 73, 37), true);
                }

                var pieceAnimations = chessPiecesRendererPieceAnimation.GetPieceAnimations();

                for (var i2 = 0; i2 < 8; i2 = (i2 + 1) | 0) {
                    for (var j1 = 0; j1 < 8; j1 = (j1 + 1) | 0) {
                        if (($t = pieceAnimations[System.Array.index(i2, pieceAnimations)])[System.Array.index(j1, $t)] != null) {
                            continue;
                        }

                        var square = this.pieces.GetPiece$1(i2, j1);

                        var renderSquare3 = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetRenderSquare$1(i2, j1, this.renderFromWhitePerspective);

                        if (square === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                            continue;
                        }

                        displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawImageRotatedClockwise$1(ChessCompStompWithHacksLibrary.GameImageUtil.GetImage(square), Bridge.Int.mul(renderSquare3.File, width), Bridge.Int.mul(renderSquare3.Rank, height), 0, chessPieceScalingFactor);
                    }
                }

                for (var i3 = 0; i3 < 8; i3 = (i3 + 1) | 0) {
                    for (var j2 = 0; j2 < 8; j2 = (j2 + 1) | 0) {
                        if (($t1 = pieceAnimations[System.Array.index(i3, pieceAnimations)])[System.Array.index(j2, $t1)] == null) {
                            continue;
                        }

                        var originRenderSquare = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetRenderSquare(($t2 = pieceAnimations[System.Array.index(i3, pieceAnimations)])[System.Array.index(j2, $t2)].OriginSquare, this.renderFromWhitePerspective);
                        var destinationRenderSquare = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetRenderSquare$1(i3, j2, this.renderFromWhitePerspective);

                        var originX = System.Int64(Bridge.Int.mul(originRenderSquare.File, width));
                        var originY = System.Int64(Bridge.Int.mul(originRenderSquare.Rank, height));

                        var destinationX = System.Int64(Bridge.Int.mul(destinationRenderSquare.File, width));
                        var destinationY = System.Int64(Bridge.Int.mul(destinationRenderSquare.Rank, height));

                        var renderX = System.Int64.clip32(originX.add((destinationX.sub(originX)).mul(System.Int64(($t3 = pieceAnimations[System.Array.index(i3, pieceAnimations)])[System.Array.index(j2, $t3)].ElapsedMicros)).div((System.Int64(100000)))));
                        var renderY = System.Int64.clip32(originY.add((destinationY.sub(originY)).mul(System.Int64(($t4 = pieceAnimations[System.Array.index(i3, pieceAnimations)])[System.Array.index(j2, $t4)].ElapsedMicros)).div((System.Int64(100000)))));

                        displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawImageRotatedClockwise$1(ChessCompStompWithHacksLibrary.GameImageUtil.GetImage(($t5 = pieceAnimations[System.Array.index(i3, pieceAnimations)])[System.Array.index(j2, $t5)].Piece), renderX, renderY, 0, chessPieceScalingFactor);
                    }
                }

                if (this.selectedPieceSquare != null) {
                    var renderSquare4 = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetRenderSquare(this.selectedPieceSquare, this.renderFromWhitePerspective);
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(Bridge.Int.mul(renderSquare4.File, width), Bridge.Int.mul(renderSquare4.Rank, height), width, height, new DTLibrary.DTColor.$ctor1(0, 128, 0, 128), true);
                }

                var possibleMoveSquareColor = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetPossibleMoveSquareColor(this.colorTheme);
                for (var i4 = 0; i4 < this.possibleMoveSquares.Count; i4 = (i4 + 1) | 0) {
                    var possibleMoveSquare = this.possibleMoveSquares.getItem(i4);
                    var renderSquare5 = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetRenderSquare(possibleMoveSquare, this.renderFromWhitePerspective);
                    for (var x = 0; x < 7; x = (x + 1) | 0) {
                        var rectangleWidth = (((width + 1) | 0) - Bridge.Int.mul(2, x)) | 0;
                        var rectangleHeight = (((height + 1) | 0) - Bridge.Int.mul(2, x)) | 0;

                        if (rectangleWidth > 0 && rectangleHeight > 0) {
                            displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(((Bridge.Int.mul(renderSquare5.File, width) + x) | 0), ((Bridge.Int.mul(renderSquare5.Rank, height) + x) | 0), rectangleWidth, rectangleHeight, new DTLibrary.DTColor.$ctor1(possibleMoveSquareColor.R, possibleMoveSquareColor.G, possibleMoveSquareColor.B, ((128 - Bridge.Int.mul(20, x)) | 0)), false);
                        }
                    }
                }

                if (this.hoverSquare != null) {
                    var renderSquare6 = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetRenderSquare(this.hoverSquare, this.renderFromWhitePerspective);
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(Bridge.Int.mul(renderSquare6.File, width), Bridge.Int.mul(renderSquare6.Rank, height), width, height, new DTLibrary.DTColor.$ctor1(0, 0, 128, 128), true);
                }

                if (this.potentialNukeSquaresInfo != null) {
                    for (var i5 = 0; i5 < this.potentialNukeSquaresInfo.PotentialNukeSquares.Count; i5 = (i5 + 1) | 0) {
                        var potentialNukeSquare = this.potentialNukeSquaresInfo.PotentialNukeSquares.getItem(i5);
                        var renderSquare7 = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetRenderSquare(potentialNukeSquare, this.renderFromWhitePerspective);
                        displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(Bridge.Int.mul(renderSquare7.File, width), Bridge.Int.mul(renderSquare7.Rank, height), width, height, this.potentialNukeSquaresInfo.IsNukeLocationValid ? new DTLibrary.DTColor.$ctor1(0, 200, 0, 200) : new DTLibrary.DTColor.$ctor1(200, 0, 0, 200), true);
                    }
                }

                if (this.hoverPieceInfo != null) {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawImageRotatedClockwise$1(ChessCompStompWithHacksLibrary.GameImageUtil.GetImage(this.hoverPieceInfo.ChessSquarePiece), ((this.hoverPieceInfo.X - ((Bridge.Int.div(width, 2)) | 0)) | 0), ((this.hoverPieceInfo.Y - ((Bridge.Int.div(height, 2)) | 0)) | 0), 0, chessPieceScalingFactor);
                }

                var windowHeight = isMobileDisplayType ? displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight() : ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT;

                this.RenderNukeAnimation(displayOutput, chessPieceScalingFactor, windowHeight);
            },
            RenderNukeAnimation: function (displayOutput, chessPieceScalingFactor, windowHeight) {
                if (this.nukeAnimationMicroseconds == null) {
                    return;
                }

                var width = (Bridge.Int.div(Bridge.Int.mul(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetWidth(ChessCompStompWithHacksLibrary.GameImage.WhitePawn), chessPieceScalingFactor), 128)) | 0;
                var height = (Bridge.Int.div(Bridge.Int.mul(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetHeight(ChessCompStompWithHacksLibrary.GameImage.WhitePawn), chessPieceScalingFactor), 128)) | 0;

                if (System.Nullable.getValue(this.nukeAnimationMicroseconds) <= ChessCompStompWithHacksLibrary.ChessPiecesRenderer.NUKE_IMPACT_MICROSECONDS) {
                    if (System.Nullable.getValue(this.nukeAnimationMicroseconds) >= ChessCompStompWithHacksLibrary.ChessPiecesRenderer.NUKE_BEGIN_LANDING_MICROSECONDS) {
                        var nukeRenderCenter = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetRenderSquare$1(this.nukeCenter.File, this.nukeCenter.Rank, this.renderFromWhitePerspective);

                        var rocketWidth = displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetWidth(ChessCompStompWithHacksLibrary.GameImage.Nuke_Ready);

                        var rocketFireScalingFactor = 256;
                        var rocketFireWidthOriginal = displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetWidth(ChessCompStompWithHacksLibrary.GameImage.Nuke_RocketFire);
                        var rocketFireHeightOriginal = displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetHeight(ChessCompStompWithHacksLibrary.GameImage.Nuke_RocketFire);
                        var rocketFireWidthScaled = (Bridge.Int.div(Bridge.Int.mul(rocketFireWidthOriginal, rocketFireScalingFactor), 128)) | 0;
                        var rocketFireHeightScaled = (Bridge.Int.div(Bridge.Int.mul(rocketFireHeightOriginal, rocketFireScalingFactor), 128)) | 0;
                        var endingY = (Bridge.Int.mul(nukeRenderCenter.Rank, height) + ((Bridge.Int.div(height, 2)) | 0)) | 0;
                        var startingY = (endingY + windowHeight) | 0;
                        var totalDistanceY = (startingY - endingY) | 0;
                        var y = System.Int64.clip32(((System.Int64(1300000)).sub(System.Int64(System.Nullable.getValue(this.nukeAnimationMicroseconds)))).mul(System.Int64(totalDistanceY)).div((System.Int64(300000))).add(System.Int64(endingY)));

                        var x = (Bridge.Int.mul(nukeRenderCenter.File, width) + ((Bridge.Int.div(width, 2)) | 0)) | 0;

                        displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawImageRotatedClockwise$1(ChessCompStompWithHacksLibrary.GameImage.Nuke_Ready, ((x - (displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetWidth(ChessCompStompWithHacksLibrary.GameImage.Nuke_Ready) >> 1)) | 0), y, 23040, 128);

                        displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawImageRotatedClockwise$1(ChessCompStompWithHacksLibrary.GameImage.Nuke_RocketFire, ((((x - (displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetWidth(ChessCompStompWithHacksLibrary.GameImage.Nuke_Ready) >> 1)) | 0) + ((Bridge.Int.div((((rocketWidth - rocketFireWidthScaled) | 0)), 2)) | 0)) | 0), ((y + displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetHeight(ChessCompStompWithHacksLibrary.GameImage.Nuke_Ready)) | 0), 23040, rocketFireScalingFactor);
                    }
                } else if (System.Nullable.getValue(this.nukeAnimationMicroseconds) <= ChessCompStompWithHacksLibrary.ChessPiecesRenderer.NUKE_EXPLOSION_FINISHED_MICROSECONDS) {
                    var elapsedTime = (System.Nullable.getValue(this.nukeAnimationMicroseconds) - ChessCompStompWithHacksLibrary.ChessPiecesRenderer.NUKE_IMPACT_MICROSECONDS) | 0;
                    var totalTime = 300000;

                    var spriteNum = (((Bridge.Int.div(Bridge.Int.mul(elapsedTime, 9), totalTime)) | 0) + 1) | 0;
                    if (spriteNum < 1) {
                        spriteNum = 1;
                    }
                    if (spriteNum > 9) {
                        spriteNum = 9;
                    }

                    var explosionImage = new ChessCompStompWithHacksLibrary.GameImage();

                    switch (spriteNum) {
                        case 1: 
                            explosionImage = ChessCompStompWithHacksLibrary.GameImage.Nuke_Explosion1;
                            break;
                        case 2: 
                            explosionImage = ChessCompStompWithHacksLibrary.GameImage.Nuke_Explosion2;
                            break;
                        case 3: 
                            explosionImage = ChessCompStompWithHacksLibrary.GameImage.Nuke_Explosion3;
                            break;
                        case 4: 
                            explosionImage = ChessCompStompWithHacksLibrary.GameImage.Nuke_Explosion4;
                            break;
                        case 5: 
                            explosionImage = ChessCompStompWithHacksLibrary.GameImage.Nuke_Explosion5;
                            break;
                        case 6: 
                            explosionImage = ChessCompStompWithHacksLibrary.GameImage.Nuke_Explosion6;
                            break;
                        case 7: 
                            explosionImage = ChessCompStompWithHacksLibrary.GameImage.Nuke_Explosion7;
                            break;
                        case 8: 
                            explosionImage = ChessCompStompWithHacksLibrary.GameImage.Nuke_Explosion8;
                            break;
                        case 9: 
                            explosionImage = ChessCompStompWithHacksLibrary.GameImage.Nuke_Explosion9;
                            break;
                        default: 
                            throw new System.Exception();
                    }

                    var nukeRenderCenter1 = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetRenderSquare$1(this.nukeCenter.File, this.nukeCenter.Rank, this.renderFromWhitePerspective);

                    var explosionScalingFactor = 256;

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawImageRotatedClockwise$1(explosionImage, ((((Bridge.Int.mul(nukeRenderCenter1.File, width) + ((Bridge.Int.div(width, 2)) | 0)) | 0) - ((Bridge.Int.div(((Bridge.Int.div(Bridge.Int.mul(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetWidth(explosionImage), explosionScalingFactor), 128)) | 0), 2)) | 0)) | 0), ((((Bridge.Int.mul(nukeRenderCenter1.Rank, height) + ((Bridge.Int.div(height, 2)) | 0)) | 0) - ((Bridge.Int.div(((Bridge.Int.div(Bridge.Int.mul(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetHeight(explosionImage), explosionScalingFactor), 128)) | 0), 2)) | 0)) | 0), 0, explosionScalingFactor);
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ChessPiecesRenderer.HoverPieceInfo", {
        $kind: "nested class",
        fields: {
            ChessSquarePiece: 0,
            X: 0,
            Y: 0
        },
        ctors: {
            ctor: function (chessSquarePiece, x, y) {
                this.$initialize();
                this.ChessSquarePiece = chessSquarePiece;
                this.X = x;
                this.Y = y;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ChessPiecesRenderer.PotentialNukeSquaresInfo", {
        $kind: "nested class",
        fields: {
            PotentialNukeSquares: null,
            IsNukeLocationValid: false
        },
        ctors: {
            ctor: function (nukeCenter, isNukeLocationValid) {
                this.$initialize();
                var potentialNukedSquares = ChessCompStompWithHacksEngine.TacticalNukeUtil.GetNukedSquares(nukeCenter);

                this.PotentialNukeSquares = new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor2(potentialNukedSquares);
                this.IsNukeLocationValid = isNukeLocationValid;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ChessPiecesRendererFadeOutFadeIn", {
        statics: {
            fields: {
                TIME_TO_FADE_IN: 0,
                TIME_TO_FADE_OUT: 0
            },
            ctors: {
                init: function () {
                    this.TIME_TO_FADE_IN = 500000;
                    this.TIME_TO_FADE_OUT = 500000;
                }
            }
        },
        fields: {
            elapsedMicros: 0,
            colorTheme: 0
        },
        ctors: {
            ctor: function (colorTheme) {
                this.$initialize();
                this.elapsedMicros = 0;
                this.colorTheme = colorTheme;
            }
        },
        methods: {
            HasFinishedFadingIn: function () {
                return this.elapsedMicros >= 1000000;
            },
            HasFinishedFadingOut: function () {
                return this.elapsedMicros >= ChessCompStompWithHacksLibrary.ChessPiecesRendererFadeOutFadeIn.TIME_TO_FADE_OUT;
            },
            ProcessFrame: function (elapsedMicrosPerFrame) {
                this.elapsedMicros = (this.elapsedMicros + elapsedMicrosPerFrame) | 0;

                if (this.elapsedMicros > 1000000) {
                    this.elapsedMicros = 1000001;
                }
            },
            Render: function (displayOutput, chessPieceScalingFactor) {
                var width = (Bridge.Int.div(Bridge.Int.mul(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetWidth(ChessCompStompWithHacksLibrary.GameImage.WhitePawn), chessPieceScalingFactor), 128)) | 0;
                var height = (Bridge.Int.div(Bridge.Int.mul(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetHeight(ChessCompStompWithHacksLibrary.GameImage.WhitePawn), chessPieceScalingFactor), 128)) | 0;

                var darkSquareColor = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetDarkSquareColor(this.colorTheme);
                var lightSquareColor = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetLightSquareColor(this.colorTheme);

                var alpha;
                if (!this.HasFinishedFadingOut()) {
                    alpha = (Bridge.Int.div(Bridge.Int.mul(this.elapsedMicros, 255), ChessCompStompWithHacksLibrary.ChessPiecesRendererFadeOutFadeIn.TIME_TO_FADE_OUT)) | 0;
                    if (alpha < 0) {
                        alpha = 0;
                    }
                    if (alpha > 255) {
                        alpha = 255;
                    }
                } else if (!this.HasFinishedFadingIn()) {
                    alpha = (255 - ((Bridge.Int.div(Bridge.Int.mul((((this.elapsedMicros - ChessCompStompWithHacksLibrary.ChessPiecesRendererFadeOutFadeIn.TIME_TO_FADE_OUT) | 0)), 255), ChessCompStompWithHacksLibrary.ChessPiecesRendererFadeOutFadeIn.TIME_TO_FADE_IN)) | 0)) | 0;
                    if (alpha < 0) {
                        alpha = 0;
                    }
                    if (alpha > 255) {
                        alpha = 255;
                    }
                } else {
                    alpha = 0;
                }

                darkSquareColor = new DTLibrary.DTColor.$ctor1(darkSquareColor.R, darkSquareColor.G, darkSquareColor.B, alpha);
                lightSquareColor = new DTLibrary.DTColor.$ctor1(lightSquareColor.R, lightSquareColor.G, lightSquareColor.B, alpha);

                for (var i = 0; i < 8; i = (i + 1) | 0) {
                    for (var j = 0; j < 8; j = (j + 1) | 0) {
                        displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(Bridge.Int.mul(i, width), Bridge.Int.mul(j, height), width, height, (((i + j) | 0)) % 2 === 0 ? darkSquareColor : lightSquareColor, true);
                    }
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation", {
        statics: {
            methods: {
                EmptyChessPiecesRendererPieceAnimation: function () {
                    var $t;
                    var pieceAnimations = System.Array.init(8, null, System.Array.type(ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.PieceAnimation));
                    for (var i = 0; i < 8; i = (i + 1) | 0) {
                        pieceAnimations[System.Array.index(i, pieceAnimations)] = System.Array.init(8, null, ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.PieceAnimation);
                        for (var j = 0; j < 8; j = (j + 1) | 0) {
                            ($t = pieceAnimations[System.Array.index(i, pieceAnimations)])[System.Array.index(j, $t)] = null;
                        }
                    }
                    return new ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation(pieceAnimations);
                },
                GetChessPiecesRendererPieceAnimation: function () {
                    return ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.EmptyChessPiecesRendererPieceAnimation();
                },
                CopyPieceAnimations: function (pieceAnimations) {
                    var $t, $t1;
                    var newPieceAnimations = System.Array.init(8, null, System.Array.type(ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.PieceAnimation));
                    for (var i = 0; i < 8; i = (i + 1) | 0) {
                        newPieceAnimations[System.Array.index(i, newPieceAnimations)] = System.Array.init(8, null, ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.PieceAnimation);
                        for (var j = 0; j < 8; j = (j + 1) | 0) {
                            ($t = newPieceAnimations[System.Array.index(i, newPieceAnimations)])[System.Array.index(j, $t)] = ($t1 = pieceAnimations[System.Array.index(i, pieceAnimations)])[System.Array.index(j, $t1)];
                        }
                    }

                    return newPieceAnimations;
                }
            }
        },
        fields: {
            pieceAnimations: null
        },
        ctors: {
            ctor: function (pieceAnimations) {
                this.$initialize();
                this.pieceAnimations = pieceAnimations;
            }
        },
        methods: {
            AddRawMove: function (startingFile, startingRank, endingFile, endingRank, piece) {
                var $t, $t1;
                var newPieceAnimations = ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.CopyPieceAnimations(this.pieceAnimations);

                ($t = newPieceAnimations[System.Array.index(startingFile, newPieceAnimations)])[System.Array.index(startingRank, $t)] = null;

                ($t1 = newPieceAnimations[System.Array.index(endingFile, newPieceAnimations)])[System.Array.index(endingRank, $t1)] = new ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.PieceAnimation(piece, new ChessCompStompWithHacksEngine.ChessSquare(startingFile, startingRank), 0);

                return new ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation(newPieceAnimations);
            },
            AddMove: function (originalGameState, displayMove, shouldMoveBeInstant) {
                var $t, $t1, $t2, $t3, $t4;
                if (ChessCompStompWithHacksEngine.MoveUtil.IsCastlingOrSuperCastling(displayMove.Move, originalGameState.Board)) {
                    var newPieceAnimations = ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.CopyPieceAnimations(this.pieceAnimations);
                    var castlingInfo = ChessCompStompWithHacksEngine.CastlingUtil.GetCastlingOrSuperCastlingMoveInfo(originalGameState.Board, displayMove.Move);

                    ($t = newPieceAnimations[System.Array.index(castlingInfo.OriginalLocationOfKing.File, newPieceAnimations)])[System.Array.index(castlingInfo.OriginalLocationOfKing.Rank, $t)] = null;
                    ($t1 = newPieceAnimations[System.Array.index(castlingInfo.OriginalLocationOfRook.File, newPieceAnimations)])[System.Array.index(castlingInfo.OriginalLocationOfRook.Rank, $t1)] = null;

                    ($t2 = newPieceAnimations[System.Array.index(castlingInfo.NewLocationOfKing.File, newPieceAnimations)])[System.Array.index(castlingInfo.NewLocationOfKing.Rank, $t2)] = new ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.PieceAnimation(originalGameState.Board.GetPiece(castlingInfo.OriginalLocationOfKing), castlingInfo.OriginalLocationOfKing, 0);

                    ($t3 = newPieceAnimations[System.Array.index(castlingInfo.NewLocationOfRook.File, newPieceAnimations)])[System.Array.index(castlingInfo.NewLocationOfRook.Rank, $t3)] = new ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.PieceAnimation(originalGameState.Board.GetPiece(castlingInfo.OriginalLocationOfRook), castlingInfo.OriginalLocationOfRook, 0);

                    if (shouldMoveBeInstant) {
                        if (System.Nullable.getValue(displayMove.StartingFile) === System.Nullable.getValue(displayMove.Move.StartingFile) && System.Nullable.getValue(displayMove.StartingRank) === System.Nullable.getValue(displayMove.Move.StartingRank) && displayMove.EndingFile === displayMove.Move.EndingFile && displayMove.EndingRank === displayMove.Move.EndingRank) {
                            ($t4 = newPieceAnimations[System.Array.index(castlingInfo.NewLocationOfKing.File, newPieceAnimations)])[System.Array.index(castlingInfo.NewLocationOfKing.Rank, $t4)] = null;
                        }
                    }

                    return new ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation(newPieceAnimations);
                }

                return this.AddMove$1(originalGameState, displayMove.Move, shouldMoveBeInstant);
            },
            AddMove$1: function (originalGameState, move, shouldMoveBeInstant) {
                var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10;
                var newPieceAnimations = ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.CopyPieceAnimations(this.pieceAnimations);

                if (move.IsNuke) {
                    var nukedSquares = ChessCompStompWithHacksEngine.TacticalNukeUtil.GetNukedSquares$1(move.EndingFile, move.EndingRank);

                    $t = Bridge.getEnumerator(nukedSquares);
                    try {
                        while ($t.moveNext()) {
                            var nukedSquare = $t.Current;
                            ($t1 = newPieceAnimations[System.Array.index(nukedSquare.File, newPieceAnimations)])[System.Array.index(nukedSquare.Rank, $t1)] = null;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    return new ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation(newPieceAnimations);
                }

                if (ChessCompStompWithHacksEngine.MoveUtil.IsCastlingOrSuperCastling(move, originalGameState.Board)) {
                    var castlingInfo = ChessCompStompWithHacksEngine.CastlingUtil.GetCastlingOrSuperCastlingMoveInfo(originalGameState.Board, move);

                    ($t2 = newPieceAnimations[System.Array.index(castlingInfo.OriginalLocationOfKing.File, newPieceAnimations)])[System.Array.index(castlingInfo.OriginalLocationOfKing.Rank, $t2)] = null;
                    ($t3 = newPieceAnimations[System.Array.index(castlingInfo.OriginalLocationOfRook.File, newPieceAnimations)])[System.Array.index(castlingInfo.OriginalLocationOfRook.Rank, $t3)] = null;

                    if (shouldMoveBeInstant) {
                        ($t4 = newPieceAnimations[System.Array.index(castlingInfo.NewLocationOfKing.File, newPieceAnimations)])[System.Array.index(castlingInfo.NewLocationOfKing.Rank, $t4)] = null;
                        ($t5 = newPieceAnimations[System.Array.index(castlingInfo.NewLocationOfRook.File, newPieceAnimations)])[System.Array.index(castlingInfo.NewLocationOfRook.Rank, $t5)] = null;
                    } else {
                        ($t6 = newPieceAnimations[System.Array.index(castlingInfo.NewLocationOfKing.File, newPieceAnimations)])[System.Array.index(castlingInfo.NewLocationOfKing.Rank, $t6)] = new ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.PieceAnimation(originalGameState.Board.GetPiece(castlingInfo.OriginalLocationOfKing), castlingInfo.OriginalLocationOfKing, 0);

                        ($t7 = newPieceAnimations[System.Array.index(castlingInfo.NewLocationOfRook.File, newPieceAnimations)])[System.Array.index(castlingInfo.NewLocationOfRook.Rank, $t7)] = new ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.PieceAnimation(originalGameState.Board.GetPiece(castlingInfo.OriginalLocationOfRook), castlingInfo.OriginalLocationOfRook, 0);
                    }

                    return new ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation(newPieceAnimations);
                }

                ($t8 = newPieceAnimations[System.Array.index(System.Nullable.getValue(move.StartingFile), newPieceAnimations)])[System.Array.index(System.Nullable.getValue(move.StartingRank), $t8)] = null;

                if (shouldMoveBeInstant) {
                    ($t9 = newPieceAnimations[System.Array.index(move.EndingFile, newPieceAnimations)])[System.Array.index(move.EndingRank, $t9)] = null;
                } else {
                    ($t10 = newPieceAnimations[System.Array.index(move.EndingFile, newPieceAnimations)])[System.Array.index(move.EndingRank, $t10)] = new ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.PieceAnimation(originalGameState.Board.GetPiece$1(System.Nullable.getValue(move.StartingFile), System.Nullable.getValue(move.StartingRank)), new ChessCompStompWithHacksEngine.ChessSquare(System.Nullable.getValue(move.StartingFile), System.Nullable.getValue(move.StartingRank)), 0);
                }

                return new ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation(newPieceAnimations);
            },
            GetPieceAnimations: function () {
                return ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.CopyPieceAnimations(this.pieceAnimations);
            },
            ProcessFrame: function (elapsedMicrosPerFrame) {
                var $t, $t1, $t2, $t3, $t4, $t5;
                var newPieceAnimations = ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.CopyPieceAnimations(this.pieceAnimations);

                for (var i = 0; i < 8; i = (i + 1) | 0) {
                    for (var j = 0; j < 8; j = (j + 1) | 0) {
                        if (($t = newPieceAnimations[System.Array.index(i, newPieceAnimations)])[System.Array.index(j, $t)] == null) {
                            continue;
                        }
                        var newElapsedMicros = (($t1 = newPieceAnimations[System.Array.index(i, newPieceAnimations)])[System.Array.index(j, $t1)].ElapsedMicros + elapsedMicrosPerFrame) | 0;
                        if (newElapsedMicros >= ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.PieceAnimation.ANIMATION_DURATION_MICROS) {
                            ($t2 = newPieceAnimations[System.Array.index(i, newPieceAnimations)])[System.Array.index(j, $t2)] = null;
                        } else {
                            ($t3 = newPieceAnimations[System.Array.index(i, newPieceAnimations)])[System.Array.index(j, $t3)] = new ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.PieceAnimation(($t4 = newPieceAnimations[System.Array.index(i, newPieceAnimations)])[System.Array.index(j, $t4)].Piece, ($t5 = newPieceAnimations[System.Array.index(i, newPieceAnimations)])[System.Array.index(j, $t5)].OriginSquare, newElapsedMicros);
                        }
                    }
                }

                return new ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation(newPieceAnimations);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.PieceAnimation", {
        $kind: "nested class",
        statics: {
            fields: {
                ANIMATION_DURATION_MICROS: 0
            },
            ctors: {
                init: function () {
                    this.ANIMATION_DURATION_MICROS = 100000;
                }
            }
        },
        fields: {
            Piece: 0,
            OriginSquare: null,
            ElapsedMicros: 0
        },
        ctors: {
            ctor: function (piece, originSquare, elapsedMicros) {
                this.$initialize();
                this.Piece = piece;
                this.OriginSquare = originSquare;
                this.ElapsedMicros = elapsedMicros;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ChessPiecesRendererUtil", {
        statics: {
            methods: {
                GetKingInDangerSquare: function (gameState) {
                    var kingFile = null;
                    var kingRank = null;

                    for (var i = 0; i < 8; i = (i + 1) | 0) {
                        for (var j = 0; j < 8; j = (j + 1) | 0) {
                            if (ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsKing(gameState.Board.GetPiece$1(i, j)) && ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsWhite(gameState.Board.GetPiece$1(i, j)) === gameState.IsWhiteTurn) {
                                kingFile = i;
                                kingRank = j;
                                break;
                            }
                        }

                        if (System.Nullable.hasValue(kingFile)) {
                            break;
                        }
                    }

                    var isKingUnderAttack = ChessCompStompWithHacksEngine.CheckKingUnderAttack.IsKingUnderThreat(gameState.Board, gameState.Abilities, gameState.IsWhiteTurn, gameState.IsPlayerWhite, System.Nullable.getValue(kingFile), System.Nullable.getValue(kingRank));

                    if (isKingUnderAttack) {
                        return new ChessCompStompWithHacksEngine.ChessSquare(System.Nullable.getValue(kingFile), System.Nullable.getValue(kingRank));
                    }
                    return null;
                },
                GetPreviousMoveSquares: function (originalGameState, displayMove) {
                    return ChessCompStompWithHacksLibrary.ChessPiecesRendererUtil.GetPreviousMoveSquares$1(originalGameState, displayMove.Move);
                },
                GetPreviousMoveSquares$1: function (originalGameState, move) {
                    if (move.IsNuke) {
                        var nukedSquares = ChessCompStompWithHacksEngine.TacticalNukeUtil.GetNukedSquares$1(move.EndingFile, move.EndingRank);

                        return DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).AsImmutableList(nukedSquares);
                    }

                    if (ChessCompStompWithHacksEngine.MoveUtil.IsCastlingOrSuperCastling(move, originalGameState.Board)) {
                        var squares = new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor();

                        var king = new ChessCompStompWithHacksEngine.ChessSquare(System.Nullable.getValue(move.StartingFile), System.Nullable.getValue(move.StartingRank));

                        var direction;
                        if (((move.EndingFile - System.Nullable.getValue(move.StartingFile)) | 0) === 2) {
                            direction = { Item1: 1, Item2: 0 };
                        } else {
                            if (((move.EndingFile - System.Nullable.getValue(move.StartingFile)) | 0) === -2) {
                                direction = { Item1: -1, Item2: 0 };
                            } else {
                                if (((move.EndingRank - System.Nullable.getValue(move.StartingRank)) | 0) === 2) {
                                    direction = { Item1: 0, Item2: 1 };
                                } else {
                                    if (((move.EndingRank - System.Nullable.getValue(move.StartingRank)) | 0) === -2) {
                                        direction = { Item1: 0, Item2: -1 };
                                    } else {
                                        throw new System.Exception();
                                    }
                                }
                            }
                        }

                        var rook = king;
                        while (true) {
                            rook = new ChessCompStompWithHacksEngine.ChessSquare(((rook.File + direction.Item1) | 0), ((rook.Rank + direction.Item2) | 0));
                            if (ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsRook(originalGameState.Board.GetPiece(rook))) {
                                break;
                            }
                        }

                        squares.add(king);
                        squares.add(rook);
                        squares.add(new ChessCompStompWithHacksEngine.ChessSquare(move.EndingFile, move.EndingRank));
                        squares.add(new ChessCompStompWithHacksEngine.ChessSquare(((Bridge.Int.div((((System.Nullable.getValue(move.StartingFile) + move.EndingFile) | 0)), 2)) | 0), ((Bridge.Int.div((((System.Nullable.getValue(move.StartingRank) + move.EndingRank) | 0)), 2)) | 0)));

                        return new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor1(squares);
                    } else {
                        var squares1 = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor();
                        squares1.add(new ChessCompStompWithHacksEngine.ChessSquare(System.Nullable.getValue(move.StartingFile), System.Nullable.getValue(move.StartingRank)));
                        squares1.add(new ChessCompStompWithHacksEngine.ChessSquare(move.EndingFile, move.EndingRank));

                        return DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).AsImmutableList(squares1);
                    }
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ColorTheme", {
        $kind: "enum",
        statics: {
            fields: {
                Initial: 0,
                Progress1: 1,
                Progress2: 2,
                Progress3: 3,
                Final: 4
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ColorThemeUtil", {
        statics: {
            methods: {
                GetTextBackgroundColor: function (colorTheme) {
                    switch (colorTheme) {
                        case ChessCompStompWithHacksLibrary.ColorTheme.Initial: 
                            return new DTLibrary.DTColor.ctor(255, 245, 171);
                        case ChessCompStompWithHacksLibrary.ColorTheme.Progress1: 
                            return new DTLibrary.DTColor.ctor(255, 234, 152);
                        case ChessCompStompWithHacksLibrary.ColorTheme.Progress2: 
                            return new DTLibrary.DTColor.ctor(255, 223, 134);
                        case ChessCompStompWithHacksLibrary.ColorTheme.Progress3: 
                            return new DTLibrary.DTColor.ctor(255, 211, 115);
                        case ChessCompStompWithHacksLibrary.ColorTheme.Final: 
                            return new DTLibrary.DTColor.ctor(255, 200, 97);
                        default: 
                            throw new System.Exception();
                    }
                },
                GetHoverColor: function (colorTheme) {
                    switch (colorTheme) {
                        case ChessCompStompWithHacksLibrary.ColorTheme.Initial: 
                            return new DTLibrary.DTColor.ctor(250, 249, 200);
                        case ChessCompStompWithHacksLibrary.ColorTheme.Progress1: 
                            return new DTLibrary.DTColor.ctor(251, 239, 178);
                        case ChessCompStompWithHacksLibrary.ColorTheme.Progress2: 
                            return new DTLibrary.DTColor.ctor(252, 228, 155);
                        case ChessCompStompWithHacksLibrary.ColorTheme.Progress3: 
                            return new DTLibrary.DTColor.ctor(253, 218, 133);
                        case ChessCompStompWithHacksLibrary.ColorTheme.Final: 
                            return new DTLibrary.DTColor.ctor(255, 207, 110);
                        default: 
                            throw new System.Exception();
                    }
                },
                GetClickColor: function (colorTheme) {
                    switch (colorTheme) {
                        case ChessCompStompWithHacksLibrary.ColorTheme.Initial: 
                            return new DTLibrary.DTColor.ctor(252, 251, 154);
                        case ChessCompStompWithHacksLibrary.ColorTheme.Progress1: 
                            return new DTLibrary.DTColor.ctor(249, 231, 130);
                        case ChessCompStompWithHacksLibrary.ColorTheme.Progress2: 
                            return new DTLibrary.DTColor.ctor(246, 210, 106);
                        case ChessCompStompWithHacksLibrary.ColorTheme.Progress3: 
                            return new DTLibrary.DTColor.ctor(243, 190, 82);
                        case ChessCompStompWithHacksLibrary.ColorTheme.Final: 
                            return new DTLibrary.DTColor.ctor(240, 170, 58);
                        default: 
                            throw new System.Exception();
                    }
                },
                GetColorThemeIdMapping: function () {
                    var list = new (System.Collections.Generic.List$1(System.Tuple$2(ChessCompStompWithHacksLibrary.ColorTheme,System.Int32))).ctor();

                    list.add({ Item1: ChessCompStompWithHacksLibrary.ColorTheme.Initial, Item2: 1 });
                    list.add({ Item1: ChessCompStompWithHacksLibrary.ColorTheme.Progress1, Item2: 2 });
                    list.add({ Item1: ChessCompStompWithHacksLibrary.ColorTheme.Progress2, Item2: 3 });
                    list.add({ Item1: ChessCompStompWithHacksLibrary.ColorTheme.Progress3, Item2: 4 });
                    list.add({ Item1: ChessCompStompWithHacksLibrary.ColorTheme.Final, Item2: 5 });

                    return list;
                },
                /**
                 * Returns null if the colorThemeId isn't valid
                 *
                 * @static
                 * @public
                 * @this ChessCompStompWithHacksLibrary.ColorThemeUtil
                 * @memberof ChessCompStompWithHacksLibrary.ColorThemeUtil
                 * @param   {number}                                        colorThemeId
                 * @return  {?ChessCompStompWithHacksLibrary.ColorTheme}
                 */
                GetColorThemeFromColorThemeId: function (colorThemeId) {
                    var $t;
                    var mapping = ChessCompStompWithHacksLibrary.ColorThemeUtil.GetColorThemeIdMapping();

                    $t = Bridge.getEnumerator(mapping);
                    try {
                        while ($t.moveNext()) {
                            var tuple = $t.Current;
                            if (tuple.Item2 === colorThemeId) {
                                return tuple.Item1;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    return null;
                },
                /**
                 * Maps a color theme to an integer identifier (in a consistent but arbitrary way)
                 *
                 * @static
                 * @public
                 * @this ChessCompStompWithHacksLibrary.ColorThemeUtil
                 * @memberof ChessCompStompWithHacksLibrary.ColorThemeUtil
                 * @param   {ChessCompStompWithHacksLibrary.ColorTheme}    colorTheme
                 * @return  {number}
                 */
                GetColorThemeId: function (colorTheme) {
                    var $t;
                    var mapping = ChessCompStompWithHacksLibrary.ColorThemeUtil.GetColorThemeIdMapping();

                    $t = Bridge.getEnumerator(mapping);
                    try {
                        while ($t.moveNext()) {
                            var tuple = $t.Current;
                            if (tuple.Item1 === colorTheme) {
                                return tuple.Item2;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    throw new System.Exception();
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.Credits_DesignAndCoding_LicenseText", {
        statics: {
            methods: {
                GetLicenseTextForBridge: function () {
                    return System.String.replaceAll(System.String.replaceAll(("                                 Apache License\r\n                           Version 2.0, January 2004\r\n                        http://www.apache.org/licenses/\r\n\r\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\r\n\r\n   1. Definitions.\r\n\r\n      \"License\" shall mean the terms and conditions for use, reproduction,\r\n      and distribution as defined by Sections 1 through 9 of this document.\r\n\r\n      \"Licensor\" shall mean the copyright owner or entity authorized by\r\n      the copyright owner that is granting the License.\r\n\r\n      \"Legal Entity\" shall mean the union of the acting entity and all\r\n      other entities that control, are controlled by, or are under common\r\n      control with that entity. For the purposes of this definition,\r\n      \"control\" means (i) the power, direct or indirect, to cause the\r\n      direction or management of such entity, whether by contract or\r\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\r\n      outstanding shares, or (iii) beneficial ownership of such entity.\r\n\r\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\r\n      exercising permissions granted by this License.\r\n\r\n      \"Source\" form shall mean the preferred form for making modifications,\r\n      including but not limited to software source code, documentation\r\n      source, and configuration files.\r\n\r\n      \"Object\" form shall mean any form resulting from mechanical\r\n      transformation or translation of a Source form, including but\r\n      not limited to compiled object code, generated documentation,\r\n      and conversions to other media types.\r\n\r\n      \"Work\" shall mean the work of authorship, whether in Source or\r\n      Object form, made available under the License, as indicated by a\r\n      copyright notice that is included in or attached to the work\r\n      (an example is provided in the Appendix below).\r\n\r\n      \"Derivative Works\" shall mean any work, whether in Source or Object\r\n      form, that is based on (or derived from) the Work and for which the\r\n      editorial revisions, annotations, elaborations, or other modifications\r\n      represent, as a whole, an original work of authorship. For the purposes\r\n      of this License, Derivative Works shall not include works that remain\r\n      separable from, or merely link (or bind by name) to the interfaces of,\r\n      the Work and Derivative Works thereof.\r\n\r\n      \"Contribution\" shall mean any work of authorship, including\r\n      the original version of the Work and any modifications or additions\r\n      to that Work or Derivative Works thereof, that is intentionally\r\n      submitted to Licensor for inclusion in the Work by the copyright owner\r\n      or by an individual or Legal Entity authorized to submit on behalf of\r\n      the copyright owner. For the purposes of this definition, \"submitted\"\r\n      means any form of electronic, verbal, or written communication sent\r\n      to the Licensor or its representatives, including but not limited to\r\n      communication on electronic mailing lists, source code control systems,\r\n      and issue tracking systems that are managed by, or on behalf of, the\r\n      Licensor for the purpose of discussing and improving the Work, but\r\n      excluding communication that is conspicuously marked or otherwise\r\n      designated in writing by the copyright owner as \"Not a Contribution.\"\r\n\r\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\r\n      on behalf of whom a Contribution has been received by Licensor and\r\n      subsequently incorporated within the Work.\r\n\r\n   2. Grant of Copyright License. Subject to the terms and conditions of\r\n      this License, each Contributor hereby grants to You a perpetual,\r\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\r\n      copyright license to reproduce, prepare Derivative Works of,\r\n      publicly display, publicly perform, sublicense, and distribute the\r\n      Work and such Derivative Works in Source or Object form.\r\n\r\n   3. Grant of Patent License. Subject to the terms and conditions of\r\n      this License, each Contributor hereby grants to You a perpetual,\r\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\r\n      (except as stated in this section) patent license to make, have made,\r\n      use, offer to sell, sell, import, and otherwise transfer the Work,\r\n      where such license applies only to those patent claims licensable\r\n      by such Contributor that are necessarily infringed by their\r\n      Contribution(s) alone or by combination of their Contribution(s)\r\n      with the Work to which such Contribution(s) was submitted. If You\r\n      institute patent litigation against any entity (including a\r\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\r\n      or a Contribution incorporated within the Work constitutes direct\r\n      or contributory patent infringement, then any patent licenses\r\n      granted to You under this License for that Work shall terminate\r\n      as of the date such litigation is filed.\r\n\r\n   4. Redistribution. You may reproduce and distribute copies of the\r\n      Work or Derivative Works thereof in any medium, with or without\r\n      modifications, and in Source or Object form, provided that You\r\n      meet the following conditions:\r\n\r\n      (a) You must give any other recipients of the Work or\r\n          Derivative Works a copy of this License; and\r\n\r\n      (b) You must cause any modified files to carry prominent notices\r\n          stating that You changed the files; and\r\n\r\n      (c) You must retain, in the Source form of any Derivative Works\r\n          that You distribute, all copyright, patent, trademark, and\r\n          attribution notices from the Source form of the Work,\r\n          excluding those notices that do not pertain to any part of\r\n          the Derivative Works; and\r\n\r\n      (d) If the Work includes a \"NOTICE\" text file as part of its\r\n          distribution, then any Derivative Works that You distribute must\r\n          include a readable copy of the attribution notices contained\r\n          within such NOTICE file, excluding those notices that do not\r\n          pertain to any part of the Derivative Works, in at least one\r\n          of the following places: within a NOTICE text file distributed\r\n          as part of the Derivative Works; within the Source form or\r\n          documentation, if provided along with the Derivative Works; or,\r\n          within a display generated by the Derivative Works, if and\r\n          wherever such third-party notices normally appear. The contents\r\n          of the NOTICE file are for informational purposes only and\r\n          do not modify the License. You may add Your own attribution\r\n          notices within Derivative Works that You distribute, alongside\r\n          or as an addendum to the NOTICE text from the Work, provided\r\n          that such additional attribution notices cannot be construed\r\n          as modifying the License.\r\n\r\n      You may add Your own copyright statement to Your modifications and\r\n      may provide additional or different license terms and conditions\r\n      for use, reproduction, or distribution of Your modifications, or\r\n      for any such Derivative Works as a whole, provided Your use,\r\n      reproduction, and distribution of the Work otherwise complies with\r\n      the conditions stated in this License.\r\n\r\n   5. Submission of Contributions. Unless You explicitly state otherwise,\r\n      any Contribution intentionally submitted for inclusion in the Work\r\n      by You to the Licensor shall be under the terms and conditions of\r\n      this License, without any additional terms or conditions.\r\n      Notwithstanding the above, nothing herein shall supersede or modify\r\n      the terms of any separate license agreement you may have executed\r\n      with Licensor regarding such Contributions.\r\n\r\n   6. Trademarks. This License does not grant permission to use the trade\r\n      names, trademarks, service marks, or product names of the Licensor,\r\n      except as required for reasonable and customary use in describing the\r\n      origin of the Work and reproducing the content of the NOTICE file.\r\n\r\n   7. Disclaimer of Warranty. Unless required by applicable law or\r\n      agreed to in writing, Licensor provides the Work (and each\r\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\r\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\r\n      implied, including, without limitation, any warranties or conditions\r\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\r\n      PARTICULAR PURPOSE. You are solely responsible for determining the\r\n      appropriateness of using or redistributing the Work and assume any\r\n      risks associated with Your exercise of permissions under this License.\r\n\r\n   8. Limitation of Liability. In no event and under no legal theory,\r\n      whether in tort (including negligence), contract, or otherwise,\r\n      unless required by applicable law (such as deliberate and grossly\r\n      negligent acts) or agreed to in writing, shall any Contributor be\r\n      liable to You for damages, including any direct, indirect, special,\r\n      incidental, or consequential damages of any character arising as a\r\n      result of this License or out of the use or inability to use the\r\n      Work (including but not limited to damages for loss of goodwill,\r\n      work stoppage, computer failure or malfunction, or any and all\r\n      other commercial damages or losses), even if such Contributor\r\n      has been advised of the possibility of such damages.\r\n\r\n   9. Accepting Warranty or Additional Liability. While redistributing\r\n      the Work or Derivative Works thereof, You may choose to offer,\r\n      and charge a fee for, acceptance of support, warranty, indemnity,\r\n      or other liability obligations and/or rights consistent with this\r\n      License. However, in accepting such obligations, You may act only\r\n      on Your own behalf and on Your sole responsibility, not on behalf\r\n      of any other Contributor, and only if You agree to indemnify,\r\n      defend, and hold each Contributor harmless for any liability\r\n      incurred by, or claims asserted against, such Contributor by reason\r\n      of your accepting any such warranty or additional liability.\r\n\r\n   END OF TERMS AND CONDITIONS\r\n\r\n   APPENDIX: How to apply the Apache License to your work.\r\n\r\n      To apply the Apache License to your work, attach the following\r\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\r\n      replaced with your own identifying information. (Don't include\r\n      the brackets!)  The text should be enclosed in the appropriate\r\n      comment syntax for the file format. We also recommend that a\r\n      file or class name and description of purpose be included on the\r\n      same \"printed page\" as the copyright notice for easier\r\n      identification within third-party archives.\r\n\r\n   Copyright 2008-2017 Object.NET, Inc.\r\n\r\n   Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   you may not use this file except in compliance with the License.\r\n   You may obtain a copy of the License at\r\n\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n   Unless required by applicable law or agreed to in writing, software\r\n   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   See the License for the specific language governing permissions and\r\n   limitations under the License."), "\r", ""), "\t", "    ");
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.Credits_DesignAndCodingDesktop", {
        statics: {
            methods: {
                IsHoverOverGitHubUrl: function (mouseInput, height) {
                    var mouseX = mouseInput.DTLibrary$IMouse$GetX();
                    var mouseY = mouseInput.DTLibrary$IMouse$GetY();

                    return 107 <= mouseX && mouseX <= 460 && ((height - 265) | 0) <= mouseY && mouseY <= ((((height - 265) | 0) + 32) | 0);
                },
                GetWebStandAloneVersionText: function () {
                    return "Design and coding by dtsudo (https://github.com/dtsudo)\n\nThis game is open source, under the MIT license.\n\nThe source code is written in C#.\n\nBridge.NET is used to transpile the C# source code into javascript.\nBridge.NET is licensed under Apache License 2.0.\n(https://github.com/bridgedotnet/Bridge)";
                },
                GetWebEmbeddedVersionText: function () {
                    var returnValue = "Design and coding by dtsudo \n\nThe source code is written in C#. Bridge.NET is used to transpile the\nC# source code into javascript. Bridge.NET is licensed under Apache\nLicense 2.0.\n\n\n" + (ChessCompStompWithHacksLibrary.Credits_DesignAndCodingDesktop.GetInfo() || "");

                    return returnValue;
                },
                GetElectronVersionText: function () {
                    return "Design and coding by dtsudo (https://github.com/dtsudo)\n\nThis game is open source, under the MIT license.\n\nThe source code is written in C#.\n\nBridge.NET is used to transpile the C# source code into javascript.\nBridge.NET is licensed under Apache License 2.0.\n(https://github.com/bridgedotnet/Bridge)\n\n\n\nThis game uses Electron; for Electron's licensing, see";
                },
                GetInfo: function () {
                    var str = "ddit";

                    var str2 = "tsudo";

                    str = "Re" + (str || "");

                    return (str || "") + ": /u/d" + (str2 || "");
                }
            }
        },
        fields: {
            colorTheme: 0,
            viewLicenseButton: null,
            height: 0,
            buildType: 0,
            isHoverOverGitHubUrl: false
        },
        ctors: {
            ctor: function (colorTheme, height, buildType) {
                this.$initialize();
                this.colorTheme = colorTheme;

                this.height = height;

                this.buildType = buildType;

                this.isHoverOverGitHubUrl = false;

                if (buildType === DTLibrary.BuildType.WebStandAlone || buildType === DTLibrary.BuildType.Electron) {
                    this.viewLicenseButton = new ChessCompStompWithHacksLibrary.Button(10, ((height - 320) | 0), 400, 50, new DTLibrary.DTColor.ctor(235, 235, 235), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(colorTheme), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(colorTheme), "View Bridge.NET license text", 11, 11, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, false);
                } else if (buildType === DTLibrary.BuildType.WebEmbedded) {
                    this.viewLicenseButton = new ChessCompStompWithHacksLibrary.Button(170, ((height - 145) | 0), 235, 20, new DTLibrary.DTColor.ctor(235, 235, 235), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(colorTheme), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(colorTheme), "View Bridge.NET license text", 5, 3, ChessCompStompWithHacksLibrary.GameFont.GameFont12Pt, false);
                } else {
                    throw new System.Exception();
                }
            }
        },
        methods: {
            ProcessFrame: function (mouseInput, previousMouseInput, soundOutput) {
                var clickedButton = this.viewLicenseButton.ProcessFrame(mouseInput, previousMouseInput);

                if (this.buildType === DTLibrary.BuildType.WebEmbedded) {
                    this.isHoverOverGitHubUrl = ChessCompStompWithHacksLibrary.Credits_DesignAndCodingDesktop.IsHoverOverGitHubUrl(mouseInput, this.height);
                }

                var clickUrl = null;

                if (this.isHoverOverGitHubUrl) {
                    var a = "htt";
                    var b = "/githu";
                    var c = "udo";
                    var d = "ps:/";
                    var e = "dts";
                    var f = "b.com/";

                    clickUrl = (a || "") + (d || "") + (b || "") + (f || "") + (e || "") + (c || "");
                }

                return new ChessCompStompWithHacksLibrary.Credits_DesignAndCodingDesktop.Result(clickedButton, clickUrl);
            },
            Render: function (displayOutput) {
                if (this.buildType === DTLibrary.BuildType.WebStandAlone) {
                    var text = ChessCompStompWithHacksLibrary.Credits_DesignAndCodingDesktop.GetWebStandAloneVersionText();

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(10, ((this.height - 10) | 0), text, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());
                } else if (this.buildType === DTLibrary.BuildType.WebEmbedded) {
                    var text1 = ChessCompStompWithHacksLibrary.Credits_DesignAndCodingDesktop.GetWebEmbeddedVersionText();

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(10, ((this.height - 10) | 0), text1, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(10, ((((this.height - 10) | 0) - 226) | 0), "GitHub:", ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(109, ((((this.height - 10) | 0) - 226) | 0), "https://github.com/dtsudo", ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, this.isHoverOverGitHubUrl ? new DTLibrary.DTColor.ctor(0, 0, 255) : DTLibrary.DTColor.Black());
                } else if (this.buildType === DTLibrary.BuildType.Electron) {
                    var text2 = ChessCompStompWithHacksLibrary.Credits_DesignAndCodingDesktop.GetElectronVersionText();

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(10, ((this.height - 10) | 0), text2, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(10, ((((this.height - 10) | 0) - 370) | 0), "https://github.com/electron/electron/blob/69586684484c05a0078e3b916239186a5c3d749a/LICENSE", ChessCompStompWithHacksLibrary.GameFont.GameFont14Pt, DTLibrary.DTColor.Black());
                } else {
                    throw new System.Exception();
                }

                this.viewLicenseButton.Render(displayOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.Credits_DesignAndCodingDesktop.Result", {
        $kind: "nested class",
        fields: {
            ClickedButton: false,
            ClickUrl: null
        },
        ctors: {
            ctor: function (clickedButton, clickUrl) {
                this.$initialize();
                this.ClickedButton = clickedButton;
                this.ClickUrl = clickUrl;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.Credits_DesignAndCodingMobile", {
        statics: {
            methods: {
                GetWebVersionText: function (isLandscape) {
                    if (isLandscape) {
                        return "Design and coding by dtsudo (https://github.com/dtsudo)\n\nThis game is open source, under the MIT license.\n\nBridge.NET is used to transpile the C# source code into javascript.\nBridge.NET is licensed under Apache License 2.0.\n\nSee the source code for more information (including licensing details).";
                    } else {
                        return "Design and coding by dtsudo\n(https://github.com/dtsudo)\n\nThis game is open source, under the MIT license.\n\nBridge.NET is used to transpile the C# source\ncode into javascript. Bridge.NET is licensed\nunder Apache License 2.0.\n\nSee the source code for more information\n(including licensing details).";
                    }
                },
                GetElectronVersionText: function (isLandscape) {
                    if (isLandscape) {
                        return "Design and coding by dtsudo (https://github.com/dtsudo)\n\nThis game is open source, under the MIT license.\n\nBridge.NET is used to transpile the C# source code into javascript.\nBridge.NET is licensed under Apache License 2.0.\n\nThis game uses the Electron framework.\n\nSee the source code for more information (including licensing details).";
                    } else {
                        return "Design and coding by dtsudo\n(https://github.com/dtsudo)\n\nThis game is open source, under the MIT license.\n\nBridge.NET is used to transpile the C# source\ncode into javascript. Bridge.NET is licensed\nunder Apache License 2.0.\n\nThis game uses the Electron framework.\n\nSee the source code for more information\n(including licensing details).";
                    }
                },
                Render: function (displayOutput, buildType, width, height) {
                    var isLandscape = DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput);

                    if (buildType === DTLibrary.BuildType.WebStandAlone || buildType === DTLibrary.BuildType.WebEmbedded) {
                        var text = ChessCompStompWithHacksLibrary.Credits_DesignAndCodingMobile.GetWebVersionText(isLandscape);

                        displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(10, ((height - 10) | 0), text, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());
                    } else if (buildType === DTLibrary.BuildType.Electron) {
                        var text1 = ChessCompStompWithHacksLibrary.Credits_DesignAndCodingMobile.GetElectronVersionText(isLandscape);

                        displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(10, ((height - 10) | 0), text1, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());
                    } else {
                        throw new System.Exception();
                    }
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.Credits_Font_LicenseText", {
        statics: {
            methods: {
                GetLicenseText: function () {
                    return System.String.replaceAll(System.String.replaceAll(("dtchessfont.otf, dtchessfont.ttf, and dtchessfont.woff are licensed under the SIL Open Font License, Version 1.1.\r\nDtsudo created this font as a modified version of Fetamont.\r\n\r\nFetamont.otf, Fetamont.ttf, and Fetamont.woff are licensed under the SIL Open Font License, Version 1.1.\r\nThe copyright and license text for Fetamont is below.\r\n\r\n-----------------------------------------------------------\r\n\r\nCopyright (c), Metaflop (http://www.metaflop.com),\r\nCopyright (c), Simon Egli,\r\nCopyright (c), Marco Mueller,\r\nCopyright (c), Alexis Reigel,\r\nwith Reserved Font Name Fetamont.\r\n\r\nThis Font Software is licensed under the SIL Open Font License, Version 1.1.\r\nThis license is copied below, and is also available with a FAQ at:\r\nhttp://scripts.sil.org/OFL\r\n\r\n\r\n-----------------------------------------------------------\r\nSIL OPEN FONT LICENSE Version 1.1 - 26 February 2007\r\n-----------------------------------------------------------\r\n\r\nPREAMBLE\r\nThe goals of the Open Font License (OFL) are to stimulate worldwide\r\ndevelopment of collaborative font projects, to support the font creation\r\nefforts of academic and linguistic communities, and to provide a free and\r\nopen framework in which fonts may be shared and improved in partnership\r\nwith others.\r\n\r\nThe OFL allows the licensed fonts to be used, studied, modified and\r\nredistributed freely as long as they are not sold by themselves. The\r\nfonts, including any derivative works, can be bundled, embedded, \r\nredistributed and/or sold with any software provided that any reserved\r\nnames are not used by derivative works. The fonts and derivatives,\r\nhowever, cannot be released under any other type of license. The\r\nrequirement for fonts to remain under this license does not apply\r\nto any document created using the fonts or their derivatives.\r\n\r\nDEFINITIONS\r\n\"Font Software\" refers to the set of files released by the Copyright\r\nHolder(s) under this license and clearly marked as such. This may\r\ninclude source files, build scripts and documentation.\r\n\r\n\"Reserved Font Name\" refers to any names specified as such after the\r\ncopyright statement(s).\r\n\r\n\"Original Version\" refers to the collection of Font Software components as\r\ndistributed by the Copyright Holder(s).\r\n\r\n\"Modified Version\" refers to any derivative made by adding to, deleting,\r\nor substituting -- in part or in whole -- any of the components of the\r\nOriginal Version, by changing formats or by porting the Font Software to a\r\nnew environment.\r\n\r\n\"Author\" refers to any designer, engineer, programmer, technical\r\nwriter or other person who contributed to the Font Software.\r\n\r\nPERMISSION & CONDITIONS\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of the Font Software, to use, study, copy, merge, embed, modify,\r\nredistribute, and sell modified and unmodified copies of the Font\r\nSoftware, subject to the following conditions:\r\n\r\n1) Neither the Font Software nor any of its individual components,\r\nin Original or Modified Versions, may be sold by itself.\r\n\r\n2) Original or Modified Versions of the Font Software may be bundled,\r\nredistributed and/or sold with any software, provided that each copy\r\ncontains the above copyright notice and this license. These can be\r\nincluded either as stand-alone text files, human-readable headers or\r\nin the appropriate machine-readable metadata fields within text or\r\nbinary files as long as those fields can be easily viewed by the user.\r\n\r\n3) No Modified Version of the Font Software may use the Reserved Font\r\nName(s) unless explicit written permission is granted by the corresponding\r\nCopyright Holder. This restriction only applies to the primary font name as\r\npresented to the users.\r\n\r\n4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font\r\nSoftware shall not be used to promote, endorse or advertise any\r\nModified Version, except to acknowledge the contribution(s) of the\r\nCopyright Holder(s) and the Author(s) or with their explicit written\r\npermission.\r\n\r\n5) The Font Software, modified or unmodified, in part or in whole,\r\nmust be distributed entirely under this license, and must not be\r\ndistributed under any other license. The requirement for fonts to\r\nremain under this license does not apply to any document created\r\nusing the Font Software.\r\n\r\nTERMINATION\r\nThis license becomes null and void if any of the above conditions are\r\nnot met.\r\n\r\nDISCLAIMER\r\nTHE FONT SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT\r\nOF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE\r\nCOPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\nINCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL\r\nDAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\nFROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM\r\nOTHER DEALINGS IN THE FONT SOFTWARE."), "\r", ""), "\t", "    ");
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.Credits_FontDesktop", {
        fields: {
            colorTheme: 0,
            viewLicenseButton: null,
            height: 0
        },
        ctors: {
            ctor: function (colorTheme, height) {
                this.$initialize();
                this.colorTheme = colorTheme;

                this.height = height;

                this.viewLicenseButton = new ChessCompStompWithHacksLibrary.Button(10, ((height - 203) | 0), 250, 50, new DTLibrary.DTColor.ctor(235, 235, 235), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(colorTheme), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(colorTheme), "View license text", 10, 11, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, false);
            }
        },
        methods: {
            /**
             * Returns true iff the user clicked the "view license" button
             *
             * @instance
             * @public
             * @this ChessCompStompWithHacksLibrary.Credits_FontDesktop
             * @memberof ChessCompStompWithHacksLibrary.Credits_FontDesktop
             * @param   {DTLibrary.IMouse}            mouseInput            
             * @param   {DTLibrary.IMouse}            previousMouseInput    
             * @param   {DTLibrary.ISoundOutput$1}    soundOutput
             * @return  {boolean}
             */
            ProcessFrame: function (mouseInput, previousMouseInput, soundOutput) {
                var clickedButton = this.viewLicenseButton.ProcessFrame(mouseInput, previousMouseInput);

                return clickedButton;
            },
            Render: function (displayOutput) {
                var text = "The font used in this game was generated by metaflop and then\nslightly modified by dtsudo.\nhttps://www.metaflop.com/modulator\n\nThe font is licensed under SIL Open Font License v1.1";

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(10, ((this.height - 10) | 0), text, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                this.viewLicenseButton.Render(displayOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.Credits_FontMobile", {
        statics: {
            methods: {
                Render: function (displayOutput, width, height) {
                    var newline = "\n";

                    var text;

                    if (DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput)) {
                        text = "The font was created by metaflop and modified by dtsudo." + (newline || "") + (newline || "") + "See the source code for more information (including licensing details).";
                    } else {
                        text = "The font was created by metaflop and modified" + (newline || "") + "by dtsudo." + (newline || "") + (newline || "") + "See the source code for more information" + (newline || "") + "(including licensing details).";
                    }

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(10, ((height - 10) | 0), text, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.Credits_Images_LicenseText", {
        statics: {
            methods: {
                GetLicenseTextForChessPieceImages: function () {
                    return System.String.replaceAll(System.String.replaceAll(("Copyright Cburnett\r\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the\r\nfollowing conditions are met:\r\n\r\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following\r\ndisclaimer.\r\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following\r\ndisclaimer in the documentation and/or other materials provided with the distribution.\r\n3. Neither the name of the author nor the names of its contributors may be used to endorse or promote products\r\nderived from this software without specific prior written permission.\r\n\r\nTHIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\r\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\r\nPURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\r\nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."), "\r", ""), "\t", "    ");
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.Credits_ImagesDesktop", {
        fields: {
            colorTheme: 0,
            viewLicenseButton: null,
            height: 0
        },
        ctors: {
            ctor: function (colorTheme, height) {
                this.$initialize();
                this.colorTheme = colorTheme;

                this.height = height;

                this.viewLicenseButton = new ChessCompStompWithHacksLibrary.Button(10, ((height - 147) | 0), 250, 50, new DTLibrary.DTColor.ctor(235, 235, 235), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(colorTheme), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(colorTheme), "View license text", 10, 11, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, false);
            }
        },
        methods: {
            /**
             * Returns true iff the user clicked the "view license" button
             *
             * @instance
             * @public
             * @this ChessCompStompWithHacksLibrary.Credits_ImagesDesktop
             * @memberof ChessCompStompWithHacksLibrary.Credits_ImagesDesktop
             * @param   {DTLibrary.IMouse}            mouseInput            
             * @param   {DTLibrary.IMouse}            previousMouseInput    
             * @param   {DTLibrary.ISoundOutput$1}    soundOutput
             * @return  {boolean}
             */
            ProcessFrame: function (mouseInput, previousMouseInput, soundOutput) {
                var clickedButton = this.viewLicenseButton.ProcessFrame(mouseInput, previousMouseInput);

                return clickedButton;
            },
            Render: function (displayOutput) {
                var text = "The images of chess pieces were created by Cburnett\n(https://en.wikipedia.org/wiki/User:Cburnett) and are licensed under\nthe BSD license.\n\n\n\nThe game also uses sprites from Kenney Asset Pack.\nThese sprites are licensed under Creative Commons Zero.\n(https://www.kenney.nl)";

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(10, ((this.height - 10) | 0), text, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                this.viewLicenseButton.Render(displayOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.Credits_ImagesMobile", {
        statics: {
            methods: {
                Render: function (displayOutput, width, height) {
                    var newline = "\n";

                    var text;

                    if (DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput)) {
                        text = "Image files created by:" + (newline || "") + "* Cburnett" + (newline || "") + "* Kenney" + (newline || "") + (newline || "") + "See the source code for more information (including licensing details).";
                    } else {
                        text = "Image files created by:" + (newline || "") + "* Cburnett" + (newline || "") + "* Kenney" + (newline || "") + (newline || "") + "See the source code for more information" + (newline || "") + "(including licensing details).";
                    }

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(10, ((height - 10) | 0), text, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.Credits_MusicDesktop", {
        statics: {
            methods: {
                GetText: function () {
                    return "The music tracks were created by Juhani Junkala and are licensed\nunder the CC0 Creative Commons license.\n\n(https://opengameart.org/content/5-chiptunes-action)";
                },
                Render: function (displayOutput, width, height) {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(10, ((height - 10) | 0), ChessCompStompWithHacksLibrary.Credits_MusicDesktop.GetText(), ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.Credits_MusicMobile", {
        statics: {
            methods: {
                Render: function (displayOutput, width, height) {
                    var newline = "\n";

                    var text;

                    if (DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput)) {
                        text = "Music track authors:" + (newline || "") + "* Juhani Junkala" + (newline || "") + (newline || "") + "See the source code for more information (including licensing details).";
                    } else {
                        text = "Music track authors:" + (newline || "") + "* Juhani Junkala" + (newline || "") + (newline || "") + "See the source code for more information" + (newline || "") + "(including licensing details).";
                    }

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(10, ((height - 10) | 0), text, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.Credits_SoundDesktop", {
        statics: {
            methods: {
                GetText: function () {
                    return "The sound effects were created by Kenney (https://www.kenney.nl)\nand are licensed under Creative Commons Zero.";
                },
                Render: function (displayOutput, width, height) {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(10, ((height - 10) | 0), ChessCompStompWithHacksLibrary.Credits_SoundDesktop.GetText(), ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.Credits_SoundMobile", {
        statics: {
            methods: {
                Render: function (displayOutput, width, height) {
                    var newline = "\n";

                    var text;

                    if (DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput)) {
                        text = "Sound effects created by:" + (newline || "") + "* Kenney" + (newline || "") + (newline || "") + "See the source code for more information (including licensing details).";
                    } else {
                        text = "Sound effects created by:" + (newline || "") + "* Kenney" + (newline || "") + (newline || "") + "See the source code for more information" + (newline || "") + "(including licensing details).";
                    }

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(10, ((height - 10) | 0), text, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.CreditsDesktopFrame.Tab", {
        $kind: "nested enum",
        statics: {
            fields: {
                DesignAndCoding: 0,
                Images: 1,
                Font: 2,
                Sound: 3,
                Music: 4
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.CreditsDesktopFrame.TabButton", {
        $kind: "nested class",
        fields: {
            X: 0,
            Y: 0,
            Width: 0,
            Height: 0,
            Tab: 0,
            TabName: null
        },
        ctors: {
            ctor: function (x, y, width, height, tab, tabName) {
                this.$initialize();
                this.X = x;
                this.Y = y;
                this.Width = width;
                this.Height = height;
                this.Tab = tab;
                this.TabName = tabName;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.CreditsMobileFrame.Tab", {
        $kind: "nested enum",
        statics: {
            fields: {
                DesignAndCoding: 0,
                Images: 1,
                Font: 2,
                Sound: 3,
                Music: 4
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.CreditsMobileFrame.TabButton", {
        $kind: "nested class",
        fields: {
            X: 0,
            Y: 0,
            Width: 0,
            Height: 0,
            Tab: 0,
            TabName: null
        },
        ctors: {
            ctor: function (x, y, width, height, tab, tabName) {
                this.$initialize();
                this.X = x;
                this.Y = y;
                this.Width = width;
                this.Height = height;
                this.Tab = tab;
                this.TabName = tabName;
            }
        },
        methods: {
            SetX: function (x) {
                this.X = x;
            },
            SetY: function (y) {
                this.Y = y;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.FinalBattleVictoryPanel", {
        fields: {
            x: 0,
            y: 0,
            mouseDragXStart: null,
            mouseDragYStart: null,
            continueButton: null,
            previousMouseInput: null,
            previousScreenWidth: 0,
            previousScreenHeight: 0,
            width: 0,
            height: 0
        },
        ctors: {
            ctor: function (colorTheme, display, isMobileDisplayType) {
                this.$initialize();
                var screenWidth = isMobileDisplayType ? display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth() : ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH;

                var screenHeight = isMobileDisplayType ? display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenHeight() : ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT;

                this.mouseDragXStart = null;
                this.mouseDragYStart = null;

                this.previousMouseInput = null;
                this.previousScreenWidth = screenWidth;
                this.previousScreenHeight = screenHeight;

                this.continueButton = new ChessCompStompWithHacksLibrary.Button(0, 37, 150, 40, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(colorTheme), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(colorTheme), "OK", 57, 8, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, isMobileDisplayType);

                this.UpdateCoordinates(display, isMobileDisplayType);

                this.x = (((Bridge.Int.div(screenWidth, 2)) | 0) - ((Bridge.Int.div(this.width, 2)) | 0)) | 0;
                this.y = (((Bridge.Int.div(screenHeight, 2)) | 0) - ((Bridge.Int.div(this.height, 2)) | 0)) | 0;
            }
        },
        methods: {
            UpdateCoordinates: function (display, isMobileDisplayType) {
                if (isMobileDisplayType && !DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation(ChessCompStompWithHacksLibrary.GameImage, display)) {
                    this.width = 690;
                    this.height = 300;

                    this.continueButton.SetX(((Bridge.Int.div((((this.width - 150) | 0)), 2)) | 0));
                } else {
                    this.width = 850;
                    this.height = 300;

                    this.continueButton.SetX(((Bridge.Int.div((((this.width - 150) | 0)), 2)) | 0));
                }
            },
            ProcessFrame: function (mouseInput, previousMouseInput, display, isMobileDisplayType) {
                this.UpdateCoordinates(display, isMobileDisplayType);

                if (this.previousMouseInput != null) {
                    previousMouseInput = this.previousMouseInput;
                }

                this.previousMouseInput = new DTLibrary.CopiedMouse(mouseInput);

                this.continueButton.SetIsMobileDisplayType(isMobileDisplayType);

                var screenWidth = isMobileDisplayType ? display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth() : ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH;

                var screenHeight = isMobileDisplayType ? display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenHeight() : ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT;

                var mouseX = mouseInput.DTLibrary$IMouse$GetX();
                var mouseY = mouseInput.DTLibrary$IMouse$GetY();

                var translatedMouse = new DTLibrary.TranslatedMouse(mouseInput, ((-this.x) | 0), ((-this.y) | 0));

                var isHoverOverPanel = this.x <= mouseX && mouseX <= ((this.x + this.width) | 0) && this.y <= mouseY && mouseY <= ((this.y + this.height) | 0);

                if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && isHoverOverPanel && !this.continueButton.IsHover(translatedMouse)) {
                    this.mouseDragXStart = mouseX;
                    this.mouseDragYStart = mouseY;
                }

                if (this.mouseDragXStart != null && mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                    this.x = (this.x + (((mouseX - System.Nullable.getValue(this.mouseDragXStart)) | 0))) | 0;
                    this.y = (this.y + (((mouseY - System.Nullable.getValue(this.mouseDragYStart)) | 0))) | 0;

                    this.mouseDragXStart = mouseX;
                    this.mouseDragYStart = mouseY;
                }

                if (!mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                    this.mouseDragXStart = null;
                    this.mouseDragYStart = null;

                    if (this.x < 0) {
                        this.x = 0;
                    }

                    if (this.y < 0) {
                        this.y = 0;
                    }

                    if (this.x > ((screenWidth - this.width) | 0)) {
                        this.x = (screenWidth - this.width) | 0;
                    }

                    if (this.y > ((screenHeight - this.height) | 0)) {
                        this.y = (screenHeight - this.height) | 0;
                    }
                }

                if (screenWidth !== this.previousScreenWidth || screenHeight !== this.previousScreenHeight) {
                    var panelCenterX = (this.x + ((Bridge.Int.div(this.width, 2)) | 0)) | 0;
                    var panelCenterY = (this.y + ((Bridge.Int.div(this.height, 2)) | 0)) | 0;

                    var newPanelCenterX = (Bridge.Int.div(Bridge.Int.mul(panelCenterX, screenWidth), this.previousScreenWidth)) | 0;
                    var newPanelCenterY = (Bridge.Int.div(Bridge.Int.mul(panelCenterY, screenHeight), this.previousScreenHeight)) | 0;

                    this.x = (newPanelCenterX - ((Bridge.Int.div(this.width, 2)) | 0)) | 0;
                    this.y = (newPanelCenterY - ((Bridge.Int.div(this.height, 2)) | 0)) | 0;

                    this.previousScreenWidth = screenWidth;
                    this.previousScreenHeight = screenHeight;

                    if (this.x < 0) {
                        this.x = 0;
                    }

                    if (this.y < 0) {
                        this.y = 0;
                    }

                    if (this.x > ((screenWidth - this.width) | 0)) {
                        this.x = (screenWidth - this.width) | 0;
                    }

                    if (this.y > ((screenHeight - this.height) | 0)) {
                        this.y = (screenHeight - this.height) | 0;
                    }
                }

                var isClicked = this.continueButton.ProcessFrame(translatedMouse, new DTLibrary.TranslatedMouse(previousMouseInput, ((-this.x) | 0), ((-this.y) | 0)));

                return new ChessCompStompWithHacksLibrary.FinalBattleVictoryPanel.Result(isClicked, isHoverOverPanel || this.mouseDragXStart != null);
            },
            Render: function (displayOutput, isMobileDisplayType) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(this.x, this.y, this.width, this.height, DTLibrary.DTColor.White(), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(this.x, this.y, this.width, this.height, DTLibrary.DTColor.Black(), false);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((((this.x + ((Bridge.Int.div(this.width, 2)) | 0)) | 0) - 90) | 0), ((this.y + 270) | 0), "You Win!", ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt, DTLibrary.DTColor.Black());

                if (isMobileDisplayType && !DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput)) {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((this.x + 47) | 0), ((this.y + 193) | 0), "You've defeated the AI in the Final Battle.\nYou are an Elite Hacker and an Elite Chess\nGrandmaster!", ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());
                } else {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((this.x + 47) | 0), ((this.y + 183) | 0), "You've defeated the AI in the Final Battle.\nYou are an Elite Hacker and an Elite Chess Grandmaster!", ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());
                }

                this.continueButton.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, this.x, this.y));
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.FinalBattleVictoryPanel.Result", {
        $kind: "nested class",
        fields: {
            HasClickedContinueButton: false,
            IsHoverOverPanel: false
        },
        ctors: {
            ctor: function (hasClickedContinueButton, isHoverOverPanel) {
                this.$initialize();
                this.HasClickedContinueButton = hasClickedContinueButton;
                this.IsHoverOverPanel = isHoverOverPanel;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.GameFontUtil", {
        statics: {
            methods: {
                GetFontInfo: function (font) {
                    switch (font) {
                        case ChessCompStompWithHacksLibrary.GameFont.GameFont12Pt: 
                            return new ChessCompStompWithHacksLibrary.GameFontUtil.FontInfo("Metaflop/dtchessfont.ttf", "Metaflop/dtchessfont.woff", 12, "15.86", "15.5");
                        case ChessCompStompWithHacksLibrary.GameFont.GameFont14Pt: 
                            return new ChessCompStompWithHacksLibrary.GameFontUtil.FontInfo("Metaflop/dtchessfont.ttf", "Metaflop/dtchessfont.woff", 14, "19.31", "18.5");
                        case ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt: 
                            return new ChessCompStompWithHacksLibrary.GameFontUtil.FontInfo("Metaflop/dtchessfont.ttf", "Metaflop/dtchessfont.woff", 16, "21.85", "23");
                        case ChessCompStompWithHacksLibrary.GameFont.GameFont18Pt: 
                            return new ChessCompStompWithHacksLibrary.GameFontUtil.FontInfo("Metaflop/dtchessfont.ttf", "Metaflop/dtchessfont.woff", 18, "24.19", "24");
                        case ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt: 
                            return new ChessCompStompWithHacksLibrary.GameFontUtil.FontInfo("Metaflop/dtchessfont.ttf", "Metaflop/dtchessfont.woff", 20, "26.76", "28.2");
                        case ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt: 
                            return new ChessCompStompWithHacksLibrary.GameFontUtil.FontInfo("Metaflop/dtchessfont.ttf", "Metaflop/dtchessfont.woff", 32, "42.95", "44");
                        case ChessCompStompWithHacksLibrary.GameFont.GameFont48Pt: 
                            return new ChessCompStompWithHacksLibrary.GameFontUtil.FontInfo("Metaflop/dtchessfont.ttf", "Metaflop/dtchessfont.woff", 48, "64", "66");
                        default: 
                            throw new System.Exception();
                    }
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.GameFontUtil.FontInfo", {
        $kind: "nested class",
        fields: {
            TtfFontFilename: null,
            WoffFontFilename: null,
            FontSize: 0,
            JavascriptFontSize: null,
            LineHeight: null
        },
        ctors: {
            ctor: function (ttfFontFilename, woffFontFilename, fontSize, javascriptFontSize, lineHeight) {
                this.$initialize();
                this.TtfFontFilename = ttfFontFilename;
                this.WoffFontFilename = woffFontFilename;
                this.FontSize = fontSize;
                this.JavascriptFontSize = javascriptFontSize;
                this.LineHeight = lineHeight;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.GameImageUtil", {
        statics: {
            fields: {
                DesktopChessPieceScalingFactor: 0,
                MobileChessPieceScalingFactor: 0,
                HackExplanationChessPieceScalingFactor: 0
            },
            ctors: {
                init: function () {
                    this.DesktopChessPieceScalingFactor = 16;
                    this.MobileChessPieceScalingFactor = 22;
                    this.HackExplanationChessPieceScalingFactor = 16;
                }
            },
            methods: {
                GetImage: function (piece) {
                    switch (piece) {
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackPawn: 
                            return ChessCompStompWithHacksLibrary.GameImage.BlackPawn;
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKnight: 
                            return ChessCompStompWithHacksLibrary.GameImage.BlackKnight;
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackBishop: 
                            return ChessCompStompWithHacksLibrary.GameImage.BlackBishop;
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackRook: 
                            return ChessCompStompWithHacksLibrary.GameImage.BlackRook;
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackQueen: 
                            return ChessCompStompWithHacksLibrary.GameImage.BlackQueen;
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKing: 
                            return ChessCompStompWithHacksLibrary.GameImage.BlackKing;
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn: 
                            return ChessCompStompWithHacksLibrary.GameImage.WhitePawn;
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKnight: 
                            return ChessCompStompWithHacksLibrary.GameImage.WhiteKnight;
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteBishop: 
                            return ChessCompStompWithHacksLibrary.GameImage.WhiteBishop;
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook: 
                            return ChessCompStompWithHacksLibrary.GameImage.WhiteRook;
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteQueen: 
                            return ChessCompStompWithHacksLibrary.GameImage.WhiteQueen;
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKing: 
                            return ChessCompStompWithHacksLibrary.GameImage.WhiteKing;
                        case ChessCompStompWithHacksEngine.ChessSquarePiece.Empty: 
                            throw new System.Exception();
                        default: 
                            throw new System.Exception();
                    }
                },
                GetImageFilename: function (image) {
                    switch (image) {
                        case ChessCompStompWithHacksLibrary.GameImage.SoundOn: 
                            return "Kenney/SoundOn.png";
                        case ChessCompStompWithHacksLibrary.GameImage.SoundOff: 
                            return "Kenney/SoundOff.png";
                        case ChessCompStompWithHacksLibrary.GameImage.MusicOn: 
                            return "Kenney/MusicOn.png";
                        case ChessCompStompWithHacksLibrary.GameImage.MusicOff: 
                            return "Kenney/MusicOff.png";
                        case ChessCompStompWithHacksLibrary.GameImage.Gear: 
                            return "Kenney/Gear.png";
                        case ChessCompStompWithHacksLibrary.GameImage.GearHover: 
                            return "Kenney/Gear_Hover.png";
                        case ChessCompStompWithHacksLibrary.GameImage.GearSelected: 
                            return "Kenney/Gear_Selected.png";
                        case ChessCompStompWithHacksLibrary.GameImage.Cross: 
                            return "Kenney/cross.png";
                        case ChessCompStompWithHacksLibrary.GameImage.CrossHover: 
                            return "Kenney/cross_Hover.png";
                        case ChessCompStompWithHacksLibrary.GameImage.CrossSelected: 
                            return "Kenney/cross_Selected.png";
                        case ChessCompStompWithHacksLibrary.GameImage.Down: 
                            return "Kenney/down.png";
                        case ChessCompStompWithHacksLibrary.GameImage.Up: 
                            return "Kenney/up.png";
                        case ChessCompStompWithHacksLibrary.GameImage.BlackPawn: 
                            return "Cburnett/BlackPawn.png";
                        case ChessCompStompWithHacksLibrary.GameImage.BlackRook: 
                            return "Cburnett/BlackRook.png";
                        case ChessCompStompWithHacksLibrary.GameImage.BlackKnight: 
                            return "Cburnett/BlackKnight.png";
                        case ChessCompStompWithHacksLibrary.GameImage.BlackBishop: 
                            return "Cburnett/BlackBishop.png";
                        case ChessCompStompWithHacksLibrary.GameImage.BlackQueen: 
                            return "Cburnett/BlackQueen.png";
                        case ChessCompStompWithHacksLibrary.GameImage.BlackKing: 
                            return "Cburnett/BlackKing.png";
                        case ChessCompStompWithHacksLibrary.GameImage.WhitePawn: 
                            return "Cburnett/WhitePawn.png";
                        case ChessCompStompWithHacksLibrary.GameImage.WhiteRook: 
                            return "Cburnett/WhiteRook.png";
                        case ChessCompStompWithHacksLibrary.GameImage.WhiteKnight: 
                            return "Cburnett/WhiteKnight.png";
                        case ChessCompStompWithHacksLibrary.GameImage.WhiteBishop: 
                            return "Cburnett/WhiteBishop.png";
                        case ChessCompStompWithHacksLibrary.GameImage.WhiteQueen: 
                            return "Cburnett/WhiteQueen.png";
                        case ChessCompStompWithHacksLibrary.GameImage.WhiteKing: 
                            return "Cburnett/WhiteKing.png";
                        case ChessCompStompWithHacksLibrary.GameImage.Nuke_NotReady: 
                            return "Kenney/spaceRockets_004.png";
                        case ChessCompStompWithHacksLibrary.GameImage.Nuke_Ready: 
                            return "Kenney/spaceRockets_004_green.png";
                        case ChessCompStompWithHacksLibrary.GameImage.Nuke_Hover: 
                            return "Kenney/spaceRockets_004_highlighted.png";
                        case ChessCompStompWithHacksLibrary.GameImage.Nuke_Selected: 
                            return "Kenney/spaceRockets_004_yellow.png";
                        case ChessCompStompWithHacksLibrary.GameImage.Nuke_RocketFire: 
                            return "Kenney/spaceEffects_004.png";
                        case ChessCompStompWithHacksLibrary.GameImage.Nuke_Explosion1: 
                            return "Kenney/regularExplosion00.png";
                        case ChessCompStompWithHacksLibrary.GameImage.Nuke_Explosion2: 
                            return "Kenney/regularExplosion01.png";
                        case ChessCompStompWithHacksLibrary.GameImage.Nuke_Explosion3: 
                            return "Kenney/regularExplosion02.png";
                        case ChessCompStompWithHacksLibrary.GameImage.Nuke_Explosion4: 
                            return "Kenney/regularExplosion03.png";
                        case ChessCompStompWithHacksLibrary.GameImage.Nuke_Explosion5: 
                            return "Kenney/regularExplosion04.png";
                        case ChessCompStompWithHacksLibrary.GameImage.Nuke_Explosion6: 
                            return "Kenney/regularExplosion05.png";
                        case ChessCompStompWithHacksLibrary.GameImage.Nuke_Explosion7: 
                            return "Kenney/regularExplosion06.png";
                        case ChessCompStompWithHacksLibrary.GameImage.Nuke_Explosion8: 
                            return "Kenney/regularExplosion07.png";
                        case ChessCompStompWithHacksLibrary.GameImage.Nuke_Explosion9: 
                            return "Kenney/regularExplosion08.png";
                        default: 
                            throw new System.Exception();
                    }
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.GameInitialization", {
        statics: {
            methods: {
                GetFirstFrame: function (globalState) {
                    var versionInfo = ChessCompStompWithHacksLibrary.VersionHistory.GetVersionInfo();

                    if (Bridge.referenceEquals(versionInfo.Version, "1.03")) {
                        ChessCompStompWithHacksLibrary.SavedDataMigration_ToV1_03.MigrateAllDataFromOlderVersionsToV1_03IfNeeded(globalState.FileIO);
                    } else {
                        throw new System.Exception();
                    }

                    var frame = new ChessCompStompWithHacksLibrary.InitialLoadingScreenFrame(globalState);
                    return frame;
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.GameLogic", {
        statics: {
            methods: {
                GetPlayerMove: function (mouseInput, previousMouseInput, isPromotionPanelOpen, clickedPromotionPiece, possibleMoves, promotionMoves, isPlayerWhite, isNukeInFlight, promotionPanelX, promotionPanelY, clickedSquare, clickedAndHeldSquare, hasClickedOnNuke, hasClickedAndHeldOnNuke, displayProcessing, isMobileDisplayType, coordinates) {
                    var hoverSquare = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetHoverSquare(new ChessCompStompWithHacksLibrary.GameLogic.ChessPiecesRendererMouse(mouseInput, coordinates), isPlayerWhite, coordinates.ChessPieceScalingFactor, displayProcessing);

                    if (isNukeInFlight) {
                        return new ChessCompStompWithHacksLibrary.GameLogic.PlayerMoveInfo(null, false);
                    }

                    if (isPromotionPanelOpen) {
                        if (!mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                            if (clickedPromotionPiece != null) {
                                var hoverOverSquare = ChessCompStompWithHacksLibrary.PromotionPanel.IsHoverOverSquare(promotionPanelX, promotionPanelY, mouseInput, displayProcessing, isMobileDisplayType);

                                if (hoverOverSquare != null && System.Nullable.getValue(clickedPromotionPiece) === System.Nullable.getValue(hoverOverSquare)) {
                                    return new ChessCompStompWithHacksLibrary.GameLogic.PlayerMoveInfo(System.Linq.Enumerable.from(promotionMoves).single(function (x) {
                                            return System.Nullable.getValue(x.Promotion) === System.Nullable.getValue(hoverOverSquare);
                                        }), false);
                                }
                            }
                        }
                        return new ChessCompStompWithHacksLibrary.GameLogic.PlayerMoveInfo(null, false);
                    }

                    if (!mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                        if (clickedSquare == null && clickedAndHeldSquare != null && hoverSquare != null && !hasClickedOnNuke) {
                            var moves = System.Linq.Enumerable.from(possibleMoves).where(function (x) {
                                    return !x.IsNuke && System.Nullable.getValue(x.StartingFile) === clickedAndHeldSquare.File && System.Nullable.getValue(x.StartingRank) === clickedAndHeldSquare.Rank && x.EndingFile === hoverSquare.File && x.EndingRank === hoverSquare.Rank;
                                }).toList(ChessCompStompWithHacksEngine.DisplayMove);

                            if (moves.Count === 1) {
                                return new ChessCompStompWithHacksLibrary.GameLogic.PlayerMoveInfo(moves.getItem(0), true);
                            }
                        }

                        if (clickedSquare != null && clickedAndHeldSquare != null && hoverSquare != null && hoverSquare.equalsT(clickedAndHeldSquare)) {
                            var moves1 = System.Linq.Enumerable.from(possibleMoves).where(function (x) {
                                    return !x.IsNuke && System.Nullable.getValue(x.StartingFile) === clickedSquare.File && System.Nullable.getValue(x.StartingRank) === clickedSquare.Rank && x.EndingFile === hoverSquare.File && x.EndingRank === hoverSquare.Rank;
                                }).toList(ChessCompStompWithHacksEngine.DisplayMove);

                            if (moves1.Count === 1) {
                                return new ChessCompStompWithHacksLibrary.GameLogic.PlayerMoveInfo(moves1.getItem(0), false);
                            }
                        }

                        if (clickedSquare != null && clickedAndHeldSquare != null && hoverSquare != null && clickedSquare.equalsT(clickedAndHeldSquare)) {
                            var moves2 = System.Linq.Enumerable.from(possibleMoves).where(function (x) {
                                    return !x.IsNuke && System.Nullable.getValue(x.StartingFile) === clickedAndHeldSquare.File && System.Nullable.getValue(x.StartingRank) === clickedAndHeldSquare.Rank && x.EndingFile === hoverSquare.File && x.EndingRank === hoverSquare.Rank;
                                }).toList(ChessCompStompWithHacksEngine.DisplayMove);

                            if (moves2.Count === 1) {
                                return new ChessCompStompWithHacksLibrary.GameLogic.PlayerMoveInfo(moves2.getItem(0), true);
                            }
                        }

                        if (hasClickedOnNuke && clickedAndHeldSquare != null && hoverSquare != null && (hoverSquare.equalsT(clickedAndHeldSquare) || isMobileDisplayType)) {
                            var moves3 = System.Linq.Enumerable.from(possibleMoves).where(function (x) {
                                    return x.IsNuke && x.EndingFile === hoverSquare.File && x.EndingRank === hoverSquare.Rank;
                                }).toList(ChessCompStompWithHacksEngine.DisplayMove);
                            if (moves3.Count === 1) {
                                return new ChessCompStompWithHacksLibrary.GameLogic.PlayerMoveInfo(moves3.getItem(0), false);
                            }
                        }

                        if (hasClickedAndHeldOnNuke && hoverSquare != null) {
                            var moves4 = System.Linq.Enumerable.from(possibleMoves).where(function (x) {
                                    return x.IsNuke && x.EndingFile === hoverSquare.File && x.EndingRank === hoverSquare.Rank;
                                }).toList(ChessCompStompWithHacksEngine.DisplayMove);
                            if (moves4.Count === 1) {
                                return new ChessCompStompWithHacksLibrary.GameLogic.PlayerMoveInfo(moves4.getItem(0), false);
                            }
                        }
                    }

                    return new ChessCompStompWithHacksLibrary.GameLogic.PlayerMoveInfo(null, false);
                },
                GetClickedSquare: function (mouseInput, previousMouseInput, board, isPlayerWhite, displayProcessing, possibleMoves, clickedSquare, clickedAndHeldSquare, hasNukeAbility, hasUsedNuke, isNukeInFlight, coordinates) {
                    var hoverSquare = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetHoverSquare(new ChessCompStompWithHacksLibrary.GameLogic.ChessPiecesRendererMouse(mouseInput, coordinates), isPlayerWhite, coordinates.ChessPieceScalingFactor, displayProcessing);

                    if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                        if (hoverSquare != null) {
                            var piece = board.GetPiece(hoverSquare);
                            if (piece !== ChessCompStompWithHacksEngine.ChessSquarePiece.Empty && ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsWhite(piece) === isPlayerWhite) {
                                if (clickedSquare != null && !clickedSquare.equalsT(hoverSquare)) {
                                    var moves = System.Linq.Enumerable.from(possibleMoves).where(function (x) {
                                            return !x.IsNuke && System.Nullable.getValue(x.StartingFile) === clickedSquare.File && System.Nullable.getValue(x.StartingRank) === clickedSquare.Rank && x.EndingFile === hoverSquare.File && x.EndingRank === hoverSquare.Rank;
                                        }).toList(ChessCompStompWithHacksEngine.DisplayMove);

                                    if (moves.Count === 0) {
                                        return null;
                                    }
                                }
                            }
                        }

                        if (hasNukeAbility && !hasUsedNuke && !isNukeInFlight) {
                            if (ChessCompStompWithHacksLibrary.NukeRenderer.IsHoverOverNuke(new ChessCompStompWithHacksLibrary.GameLogic.NukeRendererMouse(mouseInput, coordinates), coordinates.NukeRendererScalingFactorScaled)) {
                                return null;
                            }
                        }
                    }

                    if (!mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                        if (clickedSquare == null && clickedAndHeldSquare != null && hoverSquare != null && hoverSquare.equalsT(clickedAndHeldSquare)) {
                            var piece1 = board.GetPiece(hoverSquare);
                            if (piece1 !== ChessCompStompWithHacksEngine.ChessSquarePiece.Empty && ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsWhite(piece1) === isPlayerWhite) {
                                return hoverSquare;
                            }
                        }

                        if (clickedSquare != null && clickedAndHeldSquare != null && hoverSquare != null && hoverSquare.equalsT(clickedAndHeldSquare) && !clickedSquare.equalsT(hoverSquare)) {
                            var moves1 = System.Linq.Enumerable.from(possibleMoves).where(function (x) {
                                    return !x.IsNuke && System.Nullable.getValue(x.StartingFile) === clickedSquare.File && System.Nullable.getValue(x.StartingRank) === clickedSquare.Rank && x.EndingFile === hoverSquare.File && x.EndingRank === hoverSquare.Rank;
                                }).toList(ChessCompStompWithHacksEngine.DisplayMove);

                            if (moves1.Count === 0) {
                                var piece2 = board.GetPiece(hoverSquare);
                                if (piece2 !== ChessCompStompWithHacksEngine.ChessSquarePiece.Empty && ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsWhite(piece2) === isPlayerWhite) {
                                    return hoverSquare;
                                }
                            }
                        }

                        return null;
                    }

                    return clickedSquare;
                },
                GetClickedAndHeldSquare: function (mouseInput, previousMouseInput, isPlayerWhite, displayProcessing, clickedAndHeldSquare, isPromotionPanelOpen, promotionPanelX, promotionPanelY, coordinates, isMobileDisplayType) {
                    var hoverSquare = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetHoverSquare(new ChessCompStompWithHacksLibrary.GameLogic.ChessPiecesRendererMouse(mouseInput, coordinates), isPlayerWhite, coordinates.ChessPieceScalingFactor, displayProcessing);

                    if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                        if (hoverSquare != null) {
                            var isHoverOverPanel = ChessCompStompWithHacksLibrary.PromotionPanel.IsHoverOverPanel(promotionPanelX, promotionPanelY, mouseInput, isMobileDisplayType);
                            if (!isPromotionPanelOpen || !isHoverOverPanel) {
                                return hoverSquare;
                            }
                        }
                    }

                    if (!mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                        return null;
                    }

                    return clickedAndHeldSquare;
                },
                GetPromotionPanelX: function (mouseX, coordinates, displayProcessing, isMobileDisplayType) {
                    var panelWidth = isMobileDisplayType ? ChessCompStompWithHacksLibrary.PromotionPanel.PROMOTION_PANEL_WIDTH_MOBILE : ChessCompStompWithHacksLibrary.PromotionPanel.PROMOTION_PANEL_WIDTH_DESKTOP;
                    var imageWidth = (Bridge.Int.div(Bridge.Int.mul(displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetWidth(ChessCompStompWithHacksLibrary.GameImage.WhitePawn), coordinates.ChessPieceScalingFactor), 128)) | 0;

                    var returnValue = mouseX;

                    var panelRightEdge = (returnValue + panelWidth) | 0;

                    var chessboardRightEdge = (coordinates.ChessPiecesRendererX + Bridge.Int.mul(8, imageWidth)) | 0;

                    if (((panelRightEdge + 5) | 0) > chessboardRightEdge) {
                        var offset = (((panelRightEdge + 5) | 0) - chessboardRightEdge) | 0;
                        returnValue = (returnValue - offset) | 0;
                    }

                    return returnValue;
                },
                GetPromotionPanelInfo: function (isPromotionPanelOpen, promotionPanelX, promotionPanelY, promotionMoves, mouseInput, previousMouseInput, clickedSquare, clickedAndHeldSquare, isPlayerWhite, displayProcessing, possibleMoves, isNukeInFlight, hasClickedOnNuke, coordinates, isMobileDisplayType) {
                    if (isNukeInFlight || hasClickedOnNuke) {
                        return new ChessCompStompWithHacksLibrary.GameLogic.PromotionPanelInfo(false, 0, 0, null);
                    }

                    var hoverSquare = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetHoverSquare(new ChessCompStompWithHacksLibrary.GameLogic.ChessPiecesRendererMouse(mouseInput, coordinates), isPlayerWhite, coordinates.ChessPieceScalingFactor, displayProcessing);

                    if (isPromotionPanelOpen) {
                        if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                            var isHoverOverPanel = ChessCompStompWithHacksLibrary.PromotionPanel.IsHoverOverPanel(promotionPanelX, promotionPanelY, mouseInput, isMobileDisplayType);
                            if (!isHoverOverPanel) {
                                return new ChessCompStompWithHacksLibrary.GameLogic.PromotionPanelInfo(false, 0, 0, null);
                            }
                        }
                    }

                    if (!mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                        if (clickedSquare == null && clickedAndHeldSquare != null && hoverSquare != null && !hoverSquare.equalsT(clickedAndHeldSquare)) {
                            var moves = System.Linq.Enumerable.from(possibleMoves).where(function (x) {
                                    return !x.IsNuke && System.Nullable.getValue(x.StartingFile) === clickedAndHeldSquare.File && System.Nullable.getValue(x.StartingRank) === clickedAndHeldSquare.Rank && x.EndingFile === hoverSquare.File && x.EndingRank === hoverSquare.Rank;
                                }).toList(ChessCompStompWithHacksEngine.DisplayMove);

                            if (moves.Count > 0 && moves.getItem(0).Promotion != null) {
                                return new ChessCompStompWithHacksLibrary.GameLogic.PromotionPanelInfo(true, ChessCompStompWithHacksLibrary.GameLogic.GetPromotionPanelX(mouseInput.DTLibrary$IMouse$GetX(), coordinates, displayProcessing, isMobileDisplayType), mouseInput.DTLibrary$IMouse$GetY(), moves);
                            }
                        } else if (clickedSquare != null && clickedAndHeldSquare != null && hoverSquare != null && hoverSquare.equalsT(clickedAndHeldSquare) && !clickedSquare.equalsT(hoverSquare)) {
                            var moves1 = System.Linq.Enumerable.from(possibleMoves).where(function (x) {
                                    return !x.IsNuke && System.Nullable.getValue(x.StartingFile) === clickedSquare.File && System.Nullable.getValue(x.StartingRank) === clickedSquare.Rank && x.EndingFile === hoverSquare.File && x.EndingRank === hoverSquare.Rank;
                                }).toList(ChessCompStompWithHacksEngine.DisplayMove);

                            if (moves1.Count > 0 && moves1.getItem(0).Promotion != null) {
                                return new ChessCompStompWithHacksLibrary.GameLogic.PromotionPanelInfo(true, ChessCompStompWithHacksLibrary.GameLogic.GetPromotionPanelX(mouseInput.DTLibrary$IMouse$GetX(), coordinates, displayProcessing, isMobileDisplayType), mouseInput.DTLibrary$IMouse$GetY(), moves1);
                            }
                        } else if (clickedSquare != null && clickedAndHeldSquare != null && hoverSquare != null && clickedSquare.equalsT(clickedAndHeldSquare)) {
                            var moves2 = System.Linq.Enumerable.from(possibleMoves).where(function (x) {
                                    return !x.IsNuke && System.Nullable.getValue(x.StartingFile) === clickedAndHeldSquare.File && System.Nullable.getValue(x.StartingRank) === clickedAndHeldSquare.Rank && x.EndingFile === hoverSquare.File && x.EndingRank === hoverSquare.Rank;
                                }).toList(ChessCompStompWithHacksEngine.DisplayMove);

                            if (moves2.Count > 0 && moves2.getItem(0).Promotion != null) {
                                return new ChessCompStompWithHacksLibrary.GameLogic.PromotionPanelInfo(true, ChessCompStompWithHacksLibrary.GameLogic.GetPromotionPanelX(mouseInput.DTLibrary$IMouse$GetX(), coordinates, displayProcessing, isMobileDisplayType), mouseInput.DTLibrary$IMouse$GetY(), moves2);
                            }
                        }
                    }

                    return new ChessCompStompWithHacksLibrary.GameLogic.PromotionPanelInfo(isPromotionPanelOpen, promotionPanelX, promotionPanelY, promotionMoves);
                },
                GetClickedPromotionPiece: function (isPromotionPanelOpen, promotionPanelX, promotionPanelY, mouseInput, previousMouseInput, clickedPromotionPiece, isMobileDisplayType, displayProcessing) {
                    if (isPromotionPanelOpen) {
                        if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                            var hoverOverSquare = ChessCompStompWithHacksLibrary.PromotionPanel.IsHoverOverSquare(promotionPanelX, promotionPanelY, mouseInput, displayProcessing, isMobileDisplayType);

                            return hoverOverSquare;
                        }

                        if (!mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                            return null;
                        }

                        return clickedPromotionPiece;
                    }

                    return null;
                },
                GetHasClickedOnNuke: function (board, possibleMoves, isPromotionPanelOpen, mouseInput, previousMouseInput, hasNukeAbility, hasUsedNuke, isNukeInFlight, hasClickedOnNuke, hasClickedAndHeldOnNuke, promotionPanelX, promotionPanelY, isPlayerWhite, displayProcessing, coordinates, isMobileDisplayType) {
                    if (!hasNukeAbility) {
                        return false;
                    }

                    if (hasUsedNuke) {
                        return false;
                    }

                    if (isNukeInFlight) {
                        return false;
                    }

                    if (!mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                        if (isPromotionPanelOpen && ChessCompStompWithHacksLibrary.PromotionPanel.IsHoverOverPanel(promotionPanelX, promotionPanelY, mouseInput, isMobileDisplayType)) {
                            return false;
                        }

                        if (!hasClickedOnNuke && hasClickedAndHeldOnNuke && ChessCompStompWithHacksLibrary.NukeRenderer.IsHoverOverNuke(new ChessCompStompWithHacksLibrary.GameLogic.NukeRendererMouse(mouseInput, coordinates), coordinates.NukeRendererScalingFactorScaled)) {
                            return true;
                        }

                        return false;
                    }

                    if (hasClickedOnNuke && mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                        var hoverSquare = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetHoverSquare(new ChessCompStompWithHacksLibrary.GameLogic.ChessPiecesRendererMouse(mouseInput, coordinates), isPlayerWhite, coordinates.ChessPieceScalingFactor, displayProcessing);

                        if (hoverSquare != null && !System.Linq.Enumerable.from(possibleMoves).any(function (x) {
                                return x.IsNuke && x.EndingFile === hoverSquare.File && x.EndingRank === hoverSquare.Rank;
                            })) {
                            var piece = board.GetPiece(hoverSquare);
                            if (piece !== ChessCompStompWithHacksEngine.ChessSquarePiece.Empty && ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsWhite(piece) === isPlayerWhite) {
                                return false;
                            }
                        }
                    }

                    return hasClickedOnNuke;
                },
                GetHasClickedAndHeldOnNuke: function (mouseInput, previousMouseInput, isPromotionPanelOpen, promotionPanelX, promotionPanelY, hasClickedAndHeldOnNuke, hasNukeAbility, hasUsedNuke, isNukeInFlight, coordinates, isMobileDisplayType) {
                    if (!hasNukeAbility) {
                        return false;
                    }

                    if (hasUsedNuke) {
                        return false;
                    }

                    if (isNukeInFlight) {
                        return false;
                    }

                    if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                        if (ChessCompStompWithHacksLibrary.NukeRenderer.IsHoverOverNuke(new ChessCompStompWithHacksLibrary.GameLogic.NukeRendererMouse(mouseInput, coordinates), coordinates.NukeRendererScalingFactorScaled)) {
                            var isHoverOverPanel = ChessCompStompWithHacksLibrary.PromotionPanel.IsHoverOverPanel(promotionPanelX, promotionPanelY, mouseInput, isMobileDisplayType);
                            if (!isPromotionPanelOpen || !isHoverOverPanel) {
                                return true;
                            }
                        }
                    }

                    if (!mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                        return false;
                    }

                    return hasClickedAndHeldOnNuke;
                },
                UpdateChessPiecesRenderer: function (chessPiecesRenderer, gameState, turnCount, isPlayerWhite, isPlayerTurn, clickedSquare, clickedAndHeldSquare, moves, mouseInput, displayProcessing, mostRecentMove, isPromotionPanelOpen, promotionPanelX, promotionPanelY, elapsedMicrosPerFrame, hasClickedOnNuke, hasClickedAndHeldOnNuke, isNukeInFlight, coordinates, displayType) {
                    var $t, $t1;
                    var selectedPiece;
                    if (clickedSquare != null) {
                        selectedPiece = clickedSquare;
                    } else {
                        if (clickedAndHeldSquare != null) {
                            var piece = gameState.Board.GetPiece(clickedAndHeldSquare);
                            if (piece !== ChessCompStompWithHacksEngine.ChessSquarePiece.Empty && ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsWhite(piece) === isPlayerWhite) {
                                selectedPiece = clickedAndHeldSquare;
                            } else {
                                selectedPiece = null;
                            }
                        } else {
                            selectedPiece = null;
                        }
                    }

                    var possibleMoves = new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor();
                    if (isPlayerTurn && !isNukeInFlight) {
                        if (clickedSquare != null) {
                            var movesAtThisSquare = System.Linq.Enumerable.from(moves).where(function (m) {
                                    return !m.IsNuke && System.Nullable.getValue(m.StartingFile) === clickedSquare.File && System.Nullable.getValue(m.StartingRank) === clickedSquare.Rank;
                                }).toList(ChessCompStompWithHacksEngine.DisplayMove);

                            $t = Bridge.getEnumerator(movesAtThisSquare);
                            try {
                                while ($t.moveNext()) {
                                    var move = $t.Current;
                                    possibleMoves.add(new ChessCompStompWithHacksEngine.ChessSquare(move.EndingFile, move.EndingRank));
                                }
                            } finally {
                                if (Bridge.is($t, System.IDisposable)) {
                                    $t.System$IDisposable$Dispose();
                                }
                            }
                        } else if (clickedAndHeldSquare != null) {
                            var movesAtThisSquare1 = System.Linq.Enumerable.from(moves).where(function (m) {
                                    return !m.IsNuke && System.Nullable.getValue(m.StartingFile) === clickedAndHeldSquare.File && System.Nullable.getValue(m.StartingRank) === clickedAndHeldSquare.Rank;
                                }).toList(ChessCompStompWithHacksEngine.DisplayMove);

                            $t1 = Bridge.getEnumerator(movesAtThisSquare1);
                            try {
                                while ($t1.moveNext()) {
                                    var move1 = $t1.Current;
                                    possibleMoves.add(new ChessCompStompWithHacksEngine.ChessSquare(move1.EndingFile, move1.EndingRank));
                                }
                            } finally {
                                if (Bridge.is($t1, System.IDisposable)) {
                                    $t1.System$IDisposable$Dispose();
                                }
                            }
                        }
                    }

                    var hoverSquare = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetHoverSquare(new ChessCompStompWithHacksLibrary.GameLogic.ChessPiecesRendererMouse(mouseInput, coordinates), isPlayerWhite, coordinates.ChessPieceScalingFactor, displayProcessing);
                    var isHoverOverPanel = ChessCompStompWithHacksLibrary.PromotionPanel.IsHoverOverPanel(promotionPanelX, promotionPanelY, mouseInput, displayType !== DTLibrary.DisplayType.Desktop);

                    var hoverPiece = null;
                    if (!hasClickedOnNuke) {
                        if (clickedSquare == null && clickedAndHeldSquare != null) {
                            var piece1 = gameState.Board.GetPiece(clickedAndHeldSquare);
                            if (piece1 !== ChessCompStompWithHacksEngine.ChessSquarePiece.Empty && ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsWhite(piece1) === isPlayerWhite) {
                                hoverPiece = new ChessCompStompWithHacksLibrary.ChessPiecesRenderer.HoverPieceInfo(piece1, (new ChessCompStompWithHacksLibrary.GameLogic.ChessPiecesRendererMouse(mouseInput, coordinates)).GetX(), (new ChessCompStompWithHacksLibrary.GameLogic.ChessPiecesRendererMouse(mouseInput, coordinates)).GetY());
                            }
                        } else if (clickedSquare != null && clickedAndHeldSquare != null && clickedSquare.equalsT(clickedAndHeldSquare)) {
                            var piece2 = gameState.Board.GetPiece(clickedAndHeldSquare);
                            if (piece2 !== ChessCompStompWithHacksEngine.ChessSquarePiece.Empty && ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsWhite(piece2) === isPlayerWhite) {
                                hoverPiece = new ChessCompStompWithHacksLibrary.ChessPiecesRenderer.HoverPieceInfo(piece2, (new ChessCompStompWithHacksLibrary.GameLogic.ChessPiecesRendererMouse(mouseInput, coordinates)).GetX(), (new ChessCompStompWithHacksLibrary.GameLogic.ChessPiecesRendererMouse(mouseInput, coordinates)).GetY());
                            }
                        }
                    }

                    var potentialNukeSquaresInfo = null;
                    if ((hasClickedOnNuke || hasClickedAndHeldOnNuke) && hoverSquare != null && turnCount > ChessCompStompWithHacksEngine.TacticalNukeUtil.NumberOfMovesPlayedBeforeNukeIsAvailable && isPlayerTurn) {
                        if (displayType === DTLibrary.DisplayType.Desktop || mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                            var isValidSquare = System.Linq.Enumerable.from(moves).any(function (x) {
                                    return x.IsNuke && x.EndingFile === hoverSquare.File && x.EndingRank === hoverSquare.Rank;
                                });
                            potentialNukeSquaresInfo = new ChessCompStompWithHacksLibrary.ChessPiecesRenderer.PotentialNukeSquaresInfo(hoverSquare, isValidSquare);
                        }
                    }

                    return chessPiecesRenderer.ProcessFrame(gameState.Board, ChessCompStompWithHacksLibrary.ChessPiecesRendererUtil.GetKingInDangerSquare(gameState), mostRecentMove != null ? ChessCompStompWithHacksLibrary.ChessPiecesRendererUtil.GetPreviousMoveSquares$1(mostRecentMove.OriginalGameState, mostRecentMove.Move) : DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList(), selectedPiece, new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor1(possibleMoves), potentialNukeSquaresInfo, (!isPromotionPanelOpen || !isHoverOverPanel) && (displayType === DTLibrary.DisplayType.Desktop || mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) ? hoverSquare : null, hoverPiece, elapsedMicrosPerFrame);
                }
            }
        },
        fields: {
            globalState: null,
            gameState: null,
            moveTracker: null,
            moveTrackerRenderer: null,
            moveTrackerRendererPositionIndex: null,
            chessPiecesRenderer: null,
            chessPiecesRendererPieceAnimation: null,
            promotionPanel: null,
            promotionPanelX: 0,
            promotionPanelY: 0,
            nukeRenderer: null,
            promotionMoves: null,
            nukeLaunchSoundCooldown: 0,
            clickedSquare: null,
            clickedAndHeldSquare: null,
            isNukeInProgress: false,
            isNukeLiftingOff: false,
            isNukeInFlight: false,
            nukeMove: null,
            hasClickedOnNuke: false,
            hasClickedAndHeldOnNuke: false,
            isPromotionPanelOpen: false,
            chessAI: null,
            aiPondering: null,
            gameStatus: 0,
            possibleMoves: null,
            aiElapsedTimeThinking: 0,
            clickedPromotionPiece: null,
            isFinalBattle: false,
            previousMouseInput: null,
            previousCoordinates: null
        },
        ctors: {
            ctor: function (globalState, isPlayerWhite, researchedHacks, aiHackLevel, colorTheme, displayType) {
                this.$initialize();
                var coordinates = new ChessCompStompWithHacksLibrary.GameLogic.Coordinates(displayType);
                this.previousCoordinates = coordinates;

                this.globalState = globalState;
                this.gameState = ChessCompStompWithHacksLibrary.NewGameCreation.CreateNewGame(isPlayerWhite, researchedHacks, aiHackLevel);
                this.moveTracker = new ChessCompStompWithHacksLibrary.MoveTracker(colorTheme);
                this.moveTrackerRenderer = ChessCompStompWithHacksLibrary.MoveTrackerRenderer.GetMoveTrackerRenderer(this.moveTracker, colorTheme);
                this.moveTrackerRendererPositionIndex = null;

                this.chessPiecesRenderer = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetChessPiecesRenderer(this.gameState.Board, null, DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList(), this.gameState.IsPlayerWhite, colorTheme);
                this.chessPiecesRendererPieceAnimation = ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.GetChessPiecesRendererPieceAnimation();
                this.promotionPanel = ChessCompStompWithHacksLibrary.PromotionPanel.GetPromotionPanel(this.gameState.IsPlayerWhite, colorTheme);
                this.promotionPanelX = 0;
                this.promotionPanelY = 0;
                this.nukeRenderer = ChessCompStompWithHacksLibrary.NukeRenderer.GetNukeRenderer(this.gameState.Abilities.HasTacticalNuke, this.gameState.HasUsedNuke, false, null, this.gameState.TurnCount, globalState.Timer, colorTheme, false);
                this.promotionMoves = null;

                this.clickedSquare = null;
                this.clickedAndHeldSquare = null;

                this.isNukeInProgress = false;
                this.isNukeLiftingOff = false;
                this.isNukeInFlight = false;
                this.nukeMove = null;

                this.hasClickedOnNuke = false;
                this.hasClickedAndHeldOnNuke = false;

                this.isPromotionPanelOpen = false;

                this.chessAI = null;
                this.aiPondering = null;

                var result = ChessCompStompWithHacksEngine.ComputeMoves.GetMoves(this.gameState);
                this.gameStatus = result.GameStatus;
                this.possibleMoves = ChessCompStompWithHacksEngine.DisplayMove.GetDisplayMoves(result.Moves, this.gameState);

                this.aiElapsedTimeThinking = 0;

                this.clickedPromotionPiece = null;

                this.isFinalBattle = aiHackLevel === ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.FinalBattle;

                this.previousMouseInput = new DTLibrary.EmptyMouse();

                this.nukeLaunchSoundCooldown = 0;
            }
        },
        methods: {
            ProcessExtraTime: function (milliseconds) {
                if (this.chessAI != null) {
                    this.chessAI.ChessCompStompWithHacksEngine$IChessAI$CalculateBestMove(milliseconds);
                } else {
                    if (this.aiPondering != null) {
                        this.aiPondering.CalculateBestMove(milliseconds);
                    }
                }
            },
            ProcessNextFrame: function (mouseInput, displayProcessing, soundOutput, elapsedMicrosPerFrame, isMobileDisplayType) {
                var $t, $t1, $t2;
                var previousMouseInput = this.previousMouseInput;
                this.previousMouseInput = new DTLibrary.CopiedMouse(mouseInput);

                var displayType = new DTLibrary.DisplayType();

                if (!isMobileDisplayType) {
                    displayType = DTLibrary.DisplayType.Desktop;
                } else {
                    if (DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation(ChessCompStompWithHacksLibrary.GameImage, displayProcessing)) {
                        displayType = DTLibrary.DisplayType.MobileLandscape;
                    } else {
                        displayType = DTLibrary.DisplayType.MobilePortrait;
                    }
                }

                var coordinates = new ChessCompStompWithHacksLibrary.GameLogic.Coordinates(displayType);

                if (this.isPromotionPanelOpen) {
                    if (coordinates.ChessPiecesRendererX !== this.previousCoordinates.ChessPiecesRendererX || coordinates.ChessPiecesRendererY !== this.previousCoordinates.ChessPiecesRendererY || coordinates.ChessPieceScalingFactor !== this.previousCoordinates.ChessPieceScalingFactor) {
                        var xOffset = (this.promotionPanelX - this.previousCoordinates.ChessPiecesRendererX) | 0;
                        var yOffset = (this.promotionPanelY - this.previousCoordinates.ChessPiecesRendererY) | 0;

                        this.promotionPanelX = (coordinates.ChessPiecesRendererX + ((Bridge.Int.div(Bridge.Int.mul(xOffset, coordinates.ChessPieceScalingFactor), this.previousCoordinates.ChessPieceScalingFactor)) | 0)) | 0;
                        this.promotionPanelY = (coordinates.ChessPiecesRendererY + ((Bridge.Int.div(Bridge.Int.mul(yOffset, coordinates.ChessPieceScalingFactor), this.previousCoordinates.ChessPieceScalingFactor)) | 0)) | 0;

                        var promotionPanelWidth = isMobileDisplayType ? ChessCompStompWithHacksLibrary.PromotionPanel.PROMOTION_PANEL_WIDTH_MOBILE : ChessCompStompWithHacksLibrary.PromotionPanel.PROMOTION_PANEL_WIDTH_DESKTOP;
                        var imageWidth = (Bridge.Int.div(Bridge.Int.mul(displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetWidth(ChessCompStompWithHacksLibrary.GameImage.WhitePawn), coordinates.ChessPieceScalingFactor), 128)) | 0;

                        var promotionPanelRightEdge = (this.promotionPanelX + promotionPanelWidth) | 0;

                        var chessboardRightEdge = (coordinates.ChessPiecesRendererX + Bridge.Int.mul(8, imageWidth)) | 0;

                        if (((promotionPanelRightEdge + 5) | 0) > chessboardRightEdge) {
                            var offset = (((promotionPanelRightEdge + 5) | 0) - chessboardRightEdge) | 0;
                            this.promotionPanelX = (this.promotionPanelX - offset) | 0;
                        }
                    }
                }

                this.previousCoordinates = coordinates;

                if (this.gameStatus !== ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.InProgress) {
                    this.chessPiecesRenderer = ChessCompStompWithHacksLibrary.GameLogic.UpdateChessPiecesRenderer(this.chessPiecesRenderer, this.gameState, this.gameState.TurnCount, this.gameState.IsPlayerWhite, this.gameState.IsPlayerTurn(), null, null, this.possibleMoves, mouseInput, displayProcessing, this.moveTracker.GetMostRecentMove(), this.isPromotionPanelOpen, this.promotionPanelX, this.promotionPanelY, elapsedMicrosPerFrame, false, false, this.isNukeInFlight, coordinates, displayType);

                    this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.ProcessFrame(elapsedMicrosPerFrame);

                    this.nukeRenderer = this.nukeRenderer.ProcessFrame(this.gameState.HasUsedNuke, false, null, this.gameState.TurnCount, elapsedMicrosPerFrame, new DTLibrary.EmptyMouse());

                    var originalMoveTrackerRendererPositionIndex = this.moveTrackerRendererPositionIndex;

                    this.moveTrackerRendererPositionIndex = ChessCompStompWithHacksLibrary.MoveTrackerRenderer.GetHoverOverMove(new ChessCompStompWithHacksLibrary.GameLogic.MoveTrackerRendererMouse(mouseInput, coordinates), isMobileDisplayType);
                    this.moveTrackerRenderer = this.moveTrackerRenderer.ProcessFrame(this.moveTracker, this.moveTrackerRendererPositionIndex, elapsedMicrosPerFrame);

                    if (System.Nullable.hasValue(this.moveTrackerRendererPositionIndex)) {
                        if (originalMoveTrackerRendererPositionIndex == null || System.Nullable.getValue(this.moveTrackerRendererPositionIndex) !== System.Nullable.getValue(originalMoveTrackerRendererPositionIndex)) {
                            var moveTrackerMoveInfo = ChessCompStompWithHacksLibrary.MoveTrackerRenderer.GetMoveInfoForHover(System.Nullable.getValue(this.moveTrackerRendererPositionIndex), this.moveTracker, isMobileDisplayType);
                            if (moveTrackerMoveInfo != null) {
                                soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Woosh);
                            }
                        }
                    }

                    return new ChessCompStompWithHacksLibrary.GameLogic.Result(this.gameStatus, new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.Objective)).ctor(), this.gameState.IsPlayerWhite, this.isFinalBattle);
                }

                if (this.aiPondering != null) {
                    this.aiPondering.CalculateBestMove(5);
                }

                var hasPlayerJustMoved = false;

                var completedObjectives = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.Objective)).ctor();

                if (this.isNukeInFlight === false && this.isNukeInProgress) {
                    if (this.chessPiecesRenderer.HasNukeFinished()) {
                        this.isNukeInProgress = false;
                    }
                }

                if (this.isNukeInFlight) {
                    if (this.isNukeLiftingOff) {
                        this.nukeLaunchSoundCooldown = (this.nukeLaunchSoundCooldown - elapsedMicrosPerFrame) | 0;

                        if (this.nukeLaunchSoundCooldown <= 0) {
                            this.nukeLaunchSoundCooldown = (this.nukeLaunchSoundCooldown + (200000)) | 0;
                            if (this.nukeLaunchSoundCooldown <= 0) {
                                this.nukeLaunchSoundCooldown = 0;
                            }

                            soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.NukeLaunch);
                        }
                    }

                    if (this.isNukeLiftingOff && this.nukeRenderer.HasNukeFlownOffScreen()) {
                        this.isNukeLiftingOff = false;
                        this.chessPiecesRenderer = this.chessPiecesRenderer.LandNuke(new ChessCompStompWithHacksEngine.ChessSquare(this.nukeMove.EndingFile, this.nukeMove.EndingRank));
                    }

                    if (this.chessPiecesRenderer.HasNukeLanded()) {
                        this.isNukeInFlight = false;

                        this.moveTracker = this.moveTracker.AddMove(this.gameState, this.nukeMove.Move, this.globalState.Timer);
                        var newlyCompletedObjectives = ChessCompStompWithHacksEngine.ObjectiveChecker.GetCompletedObjectives(this.gameState, this.nukeMove.Move, this.isFinalBattle);
                        $t = Bridge.getEnumerator(newlyCompletedObjectives);
                        try {
                            while ($t.moveNext()) {
                                var objective = $t.Current;
                                completedObjectives.add(objective);
                            }
                        } finally {
                            if (Bridge.is($t, System.IDisposable)) {
                                $t.System$IDisposable$Dispose();
                            }
                        }
                        this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.AddMove(this.gameState, this.nukeMove, true);
                        this.gameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(this.gameState, this.nukeMove.Move);
                        var result = ChessCompStompWithHacksEngine.ComputeMoves.GetMoves(this.gameState);
                        this.gameStatus = result.GameStatus;
                        this.possibleMoves = ChessCompStompWithHacksEngine.DisplayMove.GetDisplayMoves(result.Moves, this.gameState);
                        this.nukeMove = null;

                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.NukeExplosion);

                        if (this.clickedSquare != null) {
                            var piece = this.gameState.Board.GetPiece(this.clickedSquare);
                            if (piece === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty || ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsWhite(piece) !== this.gameState.IsPlayerWhite) {
                                this.clickedSquare = null;
                            }
                        }
                    }
                } else if (!this.gameState.IsPlayerTurn()) {
                    if (!this.isNukeInProgress) {
                        if (this.chessAI == null) {
                            if (this.aiPondering != null) {
                                this.chessAI = this.aiPondering.GetAIForGameState(this.gameState);
                            } else {
                                this.chessAI = new ChessCompStompWithHacksEngine.CompositeAI(this.gameState, this.globalState.Timer, this.globalState.Rng, this.globalState.Logger, this.globalState.UseDebugAI);
                            }
                            this.aiPondering = null;
                            this.aiElapsedTimeThinking = 0;
                        }

                        this.aiElapsedTimeThinking = (this.aiElapsedTimeThinking + elapsedMicrosPerFrame) | 0;

                        var amountOfTimeElapsedMillis = (Bridge.Int.div(this.aiElapsedTimeThinking, 1000)) | 0;

                        if (!this.chessAI.ChessCompStompWithHacksEngine$IChessAI$HasFinishedCalculation() && this.chessAI.ChessCompStompWithHacksEngine$IChessAI$GetDepthOfBestMoveFoundSoFar() < 4 && amountOfTimeElapsedMillis > 250) {
                            this.chessAI.ChessCompStompWithHacksEngine$IChessAI$CalculateBestMove(10);
                        }

                        var shouldAIMove;
                        if (this.globalState.UseDebugAI) {
                            shouldAIMove = this.chessAI.ChessCompStompWithHacksEngine$IChessAI$HasFinishedCalculation() && amountOfTimeElapsedMillis > 10 || amountOfTimeElapsedMillis > 1500;
                        } else {
                            shouldAIMove = this.chessAI.ChessCompStompWithHacksEngine$IChessAI$HasFinishedCalculation() && amountOfTimeElapsedMillis > 500 || amountOfTimeElapsedMillis > 1500;
                        }

                        if (shouldAIMove) {
                            var move = this.chessAI.ChessCompStompWithHacksEngine$IChessAI$GetBestMoveFoundSoFar();
                            this.moveTracker = this.moveTracker.AddMove(this.gameState, move, this.globalState.Timer);
                            var newlyCompletedObjectives1 = ChessCompStompWithHacksEngine.ObjectiveChecker.GetCompletedObjectives(this.gameState, move, this.isFinalBattle);
                            $t1 = Bridge.getEnumerator(newlyCompletedObjectives1);
                            try {
                                while ($t1.moveNext()) {
                                    var objective1 = $t1.Current;
                                    completedObjectives.add(objective1);
                                }
                            } finally {
                                if (Bridge.is($t1, System.IDisposable)) {
                                    $t1.System$IDisposable$Dispose();
                                }
                            }
                            this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.AddMove$1(this.gameState, move, false);
                            this.gameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(this.gameState, move);
                            var result1 = ChessCompStompWithHacksEngine.ComputeMoves.GetMoves(this.gameState);
                            this.gameStatus = result1.GameStatus;
                            this.possibleMoves = ChessCompStompWithHacksEngine.DisplayMove.GetDisplayMoves(result1.Moves, this.gameState);

                            soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.AIMove);

                            if (this.clickedSquare != null) {
                                var piece1 = this.gameState.Board.GetPiece(this.clickedSquare);
                                if (piece1 === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty || ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsWhite(piece1) !== this.gameState.IsPlayerWhite) {
                                    this.clickedSquare = null;
                                }
                            }

                            this.chessAI = null;
                            this.aiPondering = new ChessCompStompWithHacksEngine.AIPondering(this.gameState, this.globalState.Timer, this.globalState.Rng, this.globalState.Logger, this.globalState.UseDebugAI);
                        }
                    }
                } else {
                    var playerMoveInfo = ChessCompStompWithHacksLibrary.GameLogic.GetPlayerMove(mouseInput, previousMouseInput, this.isPromotionPanelOpen, this.clickedPromotionPiece, this.possibleMoves, this.promotionMoves, this.gameState.IsPlayerWhite, this.isNukeInFlight, this.promotionPanelX, this.promotionPanelY, this.clickedSquare, this.clickedAndHeldSquare, this.hasClickedOnNuke, this.hasClickedAndHeldOnNuke, displayProcessing, isMobileDisplayType, coordinates);

                    var playerMove = playerMoveInfo.DisplayMove;

                    if (playerMove != null) {
                        if (playerMove.IsNuke) {
                            this.isNukeInProgress = true;
                            this.isNukeInFlight = true;
                            this.isNukeLiftingOff = true;
                            this.nukeMove = playerMove;
                            this.nukeRenderer = this.nukeRenderer.LaunchNuke();
                        } else {
                            this.moveTracker = this.moveTracker.AddMove(this.gameState, playerMove.Move, this.globalState.Timer);
                            var newlyCompletedObjectives2 = ChessCompStompWithHacksEngine.ObjectiveChecker.GetCompletedObjectives(this.gameState, playerMove.Move, this.isFinalBattle);
                            $t2 = Bridge.getEnumerator(newlyCompletedObjectives2);
                            try {
                                while ($t2.moveNext()) {
                                    var objective2 = $t2.Current;
                                    completedObjectives.add(objective2);
                                }
                            } finally {
                                if (Bridge.is($t2, System.IDisposable)) {
                                    $t2.System$IDisposable$Dispose();
                                }
                            }
                            this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.AddMove(this.gameState, playerMove, playerMoveInfo.ShouldMoveBeInstant);
                            this.gameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove(this.gameState, playerMove);
                            var result2 = ChessCompStompWithHacksEngine.ComputeMoves.GetMoves(this.gameState);
                            this.gameStatus = result2.GameStatus;
                            this.possibleMoves = ChessCompStompWithHacksEngine.DisplayMove.GetDisplayMoves(result2.Moves, this.gameState);
                            hasPlayerJustMoved = true;
                            this.clickedSquare = null;
                            this.clickedAndHeldSquare = null;
                            this.isNukeInProgress = false;
                            this.isNukeLiftingOff = false;
                            this.isNukeInFlight = false;
                            this.nukeMove = null;
                            this.hasClickedOnNuke = false;
                            this.hasClickedAndHeldOnNuke = false;
                            this.isPromotionPanelOpen = false;
                            this.clickedPromotionPiece = null;
                            this.promotionMoves = null;
                            this.chessAI = null;

                            soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.PlayerMove);
                        }
                    }
                }

                if (!hasPlayerJustMoved) {
                    var newClickedSquare = ChessCompStompWithHacksLibrary.GameLogic.GetClickedSquare(mouseInput, previousMouseInput, this.gameState.Board, this.gameState.IsPlayerWhite, displayProcessing, this.possibleMoves, this.clickedSquare, this.clickedAndHeldSquare, this.gameState.Abilities.HasTacticalNuke, this.gameState.HasUsedNuke, this.isNukeInFlight, coordinates);

                    var newClickedAndHeldSquare = ChessCompStompWithHacksLibrary.GameLogic.GetClickedAndHeldSquare(mouseInput, previousMouseInput, this.gameState.IsPlayerWhite, displayProcessing, this.clickedAndHeldSquare, this.isPromotionPanelOpen, this.promotionPanelX, this.promotionPanelY, coordinates, isMobileDisplayType);

                    var promotionPanelInfo = ChessCompStompWithHacksLibrary.GameLogic.GetPromotionPanelInfo(this.isPromotionPanelOpen, this.promotionPanelX, this.promotionPanelY, this.promotionMoves, mouseInput, previousMouseInput, this.clickedSquare, this.clickedAndHeldSquare, this.gameState.IsPlayerWhite, displayProcessing, this.possibleMoves, this.isNukeInFlight, this.hasClickedOnNuke, coordinates, isMobileDisplayType);

                    var newClickedPromotionPiece = ChessCompStompWithHacksLibrary.GameLogic.GetClickedPromotionPiece(this.isPromotionPanelOpen, this.promotionPanelX, this.promotionPanelY, mouseInput, previousMouseInput, this.clickedPromotionPiece, isMobileDisplayType, displayProcessing);

                    var newHasClickedOnNuke = ChessCompStompWithHacksLibrary.GameLogic.GetHasClickedOnNuke(this.gameState.Board, this.possibleMoves, this.isPromotionPanelOpen, mouseInput, previousMouseInput, this.gameState.Abilities.HasTacticalNuke, this.gameState.HasUsedNuke, this.isNukeInFlight, this.hasClickedOnNuke, this.hasClickedAndHeldOnNuke, this.promotionPanelX, this.promotionPanelY, this.gameState.IsPlayerWhite, displayProcessing, coordinates, isMobileDisplayType);

                    var newHasClickedAndHeldOnNuke = ChessCompStompWithHacksLibrary.GameLogic.GetHasClickedAndHeldOnNuke(mouseInput, previousMouseInput, this.isPromotionPanelOpen, this.promotionPanelX, this.promotionPanelY, this.hasClickedAndHeldOnNuke, this.gameState.Abilities.HasTacticalNuke, this.gameState.HasUsedNuke, this.isNukeInFlight, coordinates, isMobileDisplayType);

                    this.clickedSquare = newClickedSquare;
                    this.clickedAndHeldSquare = newClickedAndHeldSquare;
                    this.isPromotionPanelOpen = promotionPanelInfo.IsPromotionPanelOpen;
                    this.promotionPanelX = promotionPanelInfo.PromotionPanelX;
                    this.promotionPanelY = promotionPanelInfo.PromotionPanelY;
                    this.promotionMoves = promotionPanelInfo.PromotionMoves;
                    this.clickedPromotionPiece = newClickedPromotionPiece;
                    this.hasClickedOnNuke = newHasClickedOnNuke;
                    this.hasClickedAndHeldOnNuke = newHasClickedAndHeldOnNuke;
                }

                this.chessPiecesRenderer = ChessCompStompWithHacksLibrary.GameLogic.UpdateChessPiecesRenderer(this.chessPiecesRenderer, this.gameState, this.gameState.TurnCount, this.gameState.IsPlayerWhite, this.gameState.IsPlayerTurn(), this.clickedSquare, this.clickedAndHeldSquare, this.possibleMoves, mouseInput, displayProcessing, this.moveTracker.GetMostRecentMove(), this.isPromotionPanelOpen, this.promotionPanelX, this.promotionPanelY, elapsedMicrosPerFrame, this.hasClickedOnNuke, this.hasClickedAndHeldOnNuke, this.isNukeInFlight, coordinates, displayType);

                this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.ProcessFrame(elapsedMicrosPerFrame);

                var promotionPanelHoverSquare = ChessCompStompWithHacksLibrary.PromotionPanel.IsHoverOverSquare(this.promotionPanelX, this.promotionPanelY, mouseInput, displayProcessing, isMobileDisplayType);
                this.promotionPanel = this.promotionPanel.ProcessFrame(this.isPromotionPanelOpen, this.promotionPanelX, this.promotionPanelY, promotionPanelHoverSquare, this.clickedPromotionPiece);

                this.nukeRenderer = this.nukeRenderer.ProcessFrame(this.gameState.HasUsedNuke, this.hasClickedOnNuke || this.hasClickedAndHeldOnNuke, ChessCompStompWithHacksLibrary.NukeRenderer.IsHoverOverNuke(new ChessCompStompWithHacksLibrary.GameLogic.NukeRendererMouse(mouseInput, coordinates), coordinates.NukeRendererScalingFactorScaled) ? { Item1: (new ChessCompStompWithHacksLibrary.GameLogic.NukeRendererMouse(mouseInput, coordinates)).GetX(), Item2: (new ChessCompStompWithHacksLibrary.GameLogic.NukeRendererMouse(mouseInput, coordinates)).GetY() } : null, this.gameState.TurnCount, elapsedMicrosPerFrame, new ChessCompStompWithHacksLibrary.GameLogic.NukeRendererMouse(mouseInput, coordinates));

                var isHoverOverPromotionPanel = this.isPromotionPanelOpen && ChessCompStompWithHacksLibrary.PromotionPanel.IsHoverOverPanel(this.promotionPanelX, this.promotionPanelY, mouseInput, isMobileDisplayType);

                var oldMoveTrackerRendererPositionIndex = this.moveTrackerRendererPositionIndex;

                this.moveTrackerRendererPositionIndex = isHoverOverPromotionPanel ? null : ChessCompStompWithHacksLibrary.MoveTrackerRenderer.GetHoverOverMove(new ChessCompStompWithHacksLibrary.GameLogic.MoveTrackerRendererMouse(mouseInput, coordinates), isMobileDisplayType);
                this.moveTrackerRenderer = this.moveTrackerRenderer.ProcessFrame(this.moveTracker, this.moveTrackerRendererPositionIndex, elapsedMicrosPerFrame);

                if (System.Nullable.hasValue(this.moveTrackerRendererPositionIndex)) {
                    if (oldMoveTrackerRendererPositionIndex == null || System.Nullable.getValue(this.moveTrackerRendererPositionIndex) !== System.Nullable.getValue(oldMoveTrackerRendererPositionIndex)) {
                        var moveTrackerMoveInfo1 = ChessCompStompWithHacksLibrary.MoveTrackerRenderer.GetMoveInfoForHover(System.Nullable.getValue(this.moveTrackerRendererPositionIndex), this.moveTracker, isMobileDisplayType);
                        if (moveTrackerMoveInfo1 != null) {
                            soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Woosh);
                        }
                    }
                }

                return new ChessCompStompWithHacksLibrary.GameLogic.Result(this.gameStatus, new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.Objective)).$ctor1(completedObjectives), this.gameState.IsPlayerWhite, this.isFinalBattle);
            },
            Render: function (displayOutput, isMobileDisplayType) {
                var displayType = new DTLibrary.DisplayType();

                if (!isMobileDisplayType) {
                    displayType = DTLibrary.DisplayType.Desktop;
                } else {
                    if (DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput)) {
                        displayType = DTLibrary.DisplayType.MobileLandscape;
                    } else {
                        displayType = DTLibrary.DisplayType.MobilePortrait;
                    }
                }

                var coordinates = new ChessCompStompWithHacksLibrary.GameLogic.Coordinates(displayType);

                this.moveTrackerRenderer.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, coordinates.MoveTrackerRendererX, coordinates.MoveTrackerRendererY), isMobileDisplayType);

                var moveInfo;

                if (System.Nullable.hasValue(this.moveTrackerRendererPositionIndex)) {
                    moveInfo = ChessCompStompWithHacksLibrary.MoveTrackerRenderer.GetMoveInfoForHover(System.Nullable.getValue(this.moveTrackerRendererPositionIndex), this.moveTracker, isMobileDisplayType);
                } else {
                    moveInfo = null;
                }

                var nukeRendererEndingY;
                var nukeRendererScalingFactorScaled;

                switch (displayType) {
                    case DTLibrary.DisplayType.Desktop: 
                        nukeRendererEndingY = (ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT + ((Bridge.Int.div(Bridge.Int.mul(Bridge.Int.mul(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetHeight(ChessCompStompWithHacksLibrary.GameImage.Nuke_RocketFire), 2), coordinates.NukeRendererScalingFactorScaled), 128)) | 0)) | 0;
                        nukeRendererScalingFactorScaled = coordinates.NukeRendererScalingFactorScaled;
                        break;
                    case DTLibrary.DisplayType.MobileLandscape: 
                        nukeRendererEndingY = (displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight() + ((Bridge.Int.div(Bridge.Int.mul(Bridge.Int.mul(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetHeight(ChessCompStompWithHacksLibrary.GameImage.Nuke_RocketFire), 2), coordinates.NukeRendererScalingFactorScaled), 128)) | 0)) | 0;
                        nukeRendererScalingFactorScaled = coordinates.NukeRendererScalingFactorScaled;
                        break;
                    case DTLibrary.DisplayType.MobilePortrait: 
                        nukeRendererEndingY = (displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight() + ((Bridge.Int.div(Bridge.Int.mul(Bridge.Int.mul(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetHeight(ChessCompStompWithHacksLibrary.GameImage.Nuke_RocketFire), 2), coordinates.NukeRendererScalingFactorScaled), 128)) | 0)) | 0;
                        nukeRendererScalingFactorScaled = coordinates.NukeRendererScalingFactorScaled;
                        break;
                    default: 
                        throw new System.Exception();
                }

                if (moveInfo == null || moveInfo.NewGameState.TurnCount === this.gameState.TurnCount) {
                    this.chessPiecesRenderer.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, coordinates.ChessPiecesRendererX, coordinates.ChessPiecesRendererY), this.chessPiecesRendererPieceAnimation, coordinates.ChessPieceScalingFactor, isMobileDisplayType);
                    this.nukeRenderer.Render(nukeRendererEndingY, nukeRendererScalingFactorScaled, new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, coordinates.NukeRendererX, coordinates.NukeRendererY), isMobileDisplayType);
                    this.promotionPanel.Render(displayOutput, isMobileDisplayType);
                } else {
                    moveInfo.NewStateChessPiecesRenderer.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, coordinates.ChessPiecesRendererX, coordinates.ChessPiecesRendererY), ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.EmptyChessPiecesRendererPieceAnimation(), coordinates.ChessPieceScalingFactor, isMobileDisplayType);
                    moveInfo.NewStateNukeRenderer.Render(nukeRendererEndingY, nukeRendererScalingFactorScaled, new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, coordinates.NukeRendererX, coordinates.NukeRendererY), isMobileDisplayType);
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.GameLogic.Coordinates", {
        $kind: "nested class",
        fields: {
            ChessPiecesRendererX: 0,
            ChessPiecesRendererY: 0,
            ChessPieceScalingFactor: 0,
            NukeRendererX: 0,
            NukeRendererY: 0,
            MoveTrackerRendererX: 0,
            MoveTrackerRendererY: 0,
            NukeRendererScalingFactorScaled: 0
        },
        ctors: {
            ctor: function (displayType) {
                this.$initialize();
                switch (displayType) {
                    case DTLibrary.DisplayType.Desktop: 
                        this.ChessPiecesRendererX = 186;
                        this.ChessPiecesRendererY = 50;
                        this.ChessPieceScalingFactor = ChessCompStompWithHacksLibrary.GameImageUtil.DesktopChessPieceScalingFactor;
                        this.NukeRendererX = 25;
                        this.NukeRendererY = 50;
                        this.MoveTrackerRendererX = 720;
                        this.MoveTrackerRendererY = 208;
                        this.NukeRendererScalingFactorScaled = 128;
                        break;
                    case DTLibrary.DisplayType.MobileLandscape: 
                        this.ChessPiecesRendererX = 160;
                        this.ChessPiecesRendererY = 10;
                        this.ChessPieceScalingFactor = ChessCompStompWithHacksLibrary.GameImageUtil.MobileChessPieceScalingFactor;
                        this.NukeRendererX = 10;
                        this.NukeRendererY = 10;
                        this.MoveTrackerRendererX = 850;
                        this.MoveTrackerRendererY = 383;
                        this.NukeRendererScalingFactorScaled = 128;
                        break;
                    case DTLibrary.DisplayType.MobilePortrait: 
                        this.ChessPiecesRendererX = 10;
                        this.ChessPiecesRendererY = 210;
                        this.ChessPieceScalingFactor = ChessCompStompWithHacksLibrary.GameImageUtil.MobileChessPieceScalingFactor;
                        this.NukeRendererX = 160;
                        this.NukeRendererY = 10;
                        this.MoveTrackerRendererX = 10;
                        this.MoveTrackerRendererY = 10;
                        this.NukeRendererScalingFactorScaled = 64;
                        break;
                    default: 
                        throw new System.Exception();
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.GameLogic.PlayerMoveInfo", {
        $kind: "nested class",
        fields: {
            DisplayMove: null,
            ShouldMoveBeInstant: false
        },
        ctors: {
            ctor: function (displayMove, shouldMoveBeInstant) {
                this.$initialize();
                this.DisplayMove = displayMove;
                this.ShouldMoveBeInstant = shouldMoveBeInstant;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.GameLogic.PromotionPanelInfo", {
        $kind: "nested class",
        fields: {
            IsPromotionPanelOpen: false,
            PromotionPanelX: 0,
            PromotionPanelY: 0,
            PromotionMoves: null
        },
        ctors: {
            ctor: function (isPromotionPanelOpen, promotionPanelX, promotionPanelY, promotionMoves) {
                this.$initialize();
                this.IsPromotionPanelOpen = isPromotionPanelOpen;
                this.PromotionPanelX = promotionPanelX;
                this.PromotionPanelY = promotionPanelY;
                this.PromotionMoves = promotionMoves;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.GameLogic.Result", {
        $kind: "nested class",
        fields: {
            GameStatus: 0,
            CompletedObjectives: null,
            IsPlayerWhite: false,
            IsFinalBattle: false
        },
        ctors: {
            ctor: function (gameStatus, completedObjectives, isPlayerWhite, isFinalBattle) {
                this.$initialize();
                this.GameStatus = gameStatus;
                this.CompletedObjectives = completedObjectives;
                this.IsPlayerWhite = isPlayerWhite;
                this.IsFinalBattle = isFinalBattle;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.GameMusicUtil", {
        statics: {
            methods: {
                GetGameMusic: function (colorTheme) {
                    switch (colorTheme) {
                        case ChessCompStompWithHacksLibrary.ColorTheme.Initial: 
                            return ChessCompStompWithHacksLibrary.GameMusic.Level1;
                        case ChessCompStompWithHacksLibrary.ColorTheme.Progress1: 
                            return ChessCompStompWithHacksLibrary.GameMusic.Level2;
                        case ChessCompStompWithHacksLibrary.ColorTheme.Progress2: 
                            return ChessCompStompWithHacksLibrary.GameMusic.Level2;
                        case ChessCompStompWithHacksLibrary.ColorTheme.Progress3: 
                            return ChessCompStompWithHacksLibrary.GameMusic.Level2;
                        case ChessCompStompWithHacksLibrary.ColorTheme.Final: 
                            return ChessCompStompWithHacksLibrary.GameMusic.Level3;
                        default: 
                            throw new System.Exception();
                    }
                },
                GetMusicFilename: function (music) {
                    switch (music) {
                        case ChessCompStompWithHacksLibrary.GameMusic.TitleScreen: 
                            return new ChessCompStompWithHacksLibrary.GameMusicUtil.MusicFilenameInfo("JuhaniJunkala/TitleScreen.ogg", "JuhaniJunkala/TitleScreen.flac");
                        case ChessCompStompWithHacksLibrary.GameMusic.Level1: 
                            return new ChessCompStompWithHacksLibrary.GameMusicUtil.MusicFilenameInfo("JuhaniJunkala/Level1.ogg", "JuhaniJunkala/Level1.flac");
                        case ChessCompStompWithHacksLibrary.GameMusic.Level2: 
                            return new ChessCompStompWithHacksLibrary.GameMusicUtil.MusicFilenameInfo("JuhaniJunkala/Level2.ogg", "JuhaniJunkala/Level2.flac");
                        case ChessCompStompWithHacksLibrary.GameMusic.Level3: 
                            return new ChessCompStompWithHacksLibrary.GameMusicUtil.MusicFilenameInfo("JuhaniJunkala/Level3.ogg", "JuhaniJunkala/Level3.flac");
                        case ChessCompStompWithHacksLibrary.GameMusic.Ending: 
                            return new ChessCompStompWithHacksLibrary.GameMusicUtil.MusicFilenameInfo("JuhaniJunkala/Ending.ogg", "JuhaniJunkala/Ending.flac");
                        default: 
                            throw new System.Exception();
                    }
                },
                GetMusicVolume: function (music) {
                    switch (music) {
                        case ChessCompStompWithHacksLibrary.GameMusic.TitleScreen: 
                            return 7;
                        case ChessCompStompWithHacksLibrary.GameMusic.Level1: 
                            return 7;
                        case ChessCompStompWithHacksLibrary.GameMusic.Level2: 
                            return 7;
                        case ChessCompStompWithHacksLibrary.GameMusic.Level3: 
                            return 7;
                        case ChessCompStompWithHacksLibrary.GameMusic.Ending: 
                            return 10;
                        default: 
                            throw new System.Exception();
                    }
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.GameMusicUtil.MusicFilenameInfo", {
        $kind: "nested class",
        fields: {
            OggFilename: null,
            FlacFilename: null
        },
        ctors: {
            ctor: function (oggFilename, flacFilename) {
                this.$initialize();
                this.OggFilename = oggFilename;
                this.FlacFilename = flacFilename;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.GameSoundUtil", {
        statics: {
            methods: {
                GetSoundFilename: function (sound) {
                    switch (sound) {
                        case ChessCompStompWithHacksLibrary.GameSound.PlayerMove: 
                            return new ChessCompStompWithHacksLibrary.GameSoundUtil.SoundFilenameInfo("Kenney/jingles_STEEL16.ogg", "Kenney/jingles_STEEL16.flac");
                        case ChessCompStompWithHacksLibrary.GameSound.AIMove: 
                            return new ChessCompStompWithHacksLibrary.GameSoundUtil.SoundFilenameInfo("Kenney/jingles_STEEL00.ogg", "Kenney/jingles_STEEL00.flac");
                        case ChessCompStompWithHacksLibrary.GameSound.Win: 
                            return new ChessCompStompWithHacksLibrary.GameSoundUtil.SoundFilenameInfo("Kenney/jingles_STEEL10.ogg", "Kenney/jingles_STEEL10.flac");
                        case ChessCompStompWithHacksLibrary.GameSound.StalemateOrDefeat: 
                            return new ChessCompStompWithHacksLibrary.GameSoundUtil.SoundFilenameInfo("Kenney/jingles_STEEL14.ogg", "Kenney/jingles_STEEL14.flac");
                        case ChessCompStompWithHacksLibrary.GameSound.NukeLaunch: 
                            return new ChessCompStompWithHacksLibrary.GameSoundUtil.SoundFilenameInfo("Kenney/rumble3.ogg", "Kenney/rumble3.flac");
                        case ChessCompStompWithHacksLibrary.GameSound.NukeExplosion: 
                            return new ChessCompStompWithHacksLibrary.GameSoundUtil.SoundFilenameInfo("Kenney/rumble1.ogg", "Kenney/rumble1.flac");
                        case ChessCompStompWithHacksLibrary.GameSound.Click: 
                            return new ChessCompStompWithHacksLibrary.GameSoundUtil.SoundFilenameInfo("Kenney/click3_Modified.ogg", "Kenney/click3_Modified.flac");
                        case ChessCompStompWithHacksLibrary.GameSound.Woosh: 
                            return new ChessCompStompWithHacksLibrary.GameSoundUtil.SoundFilenameInfo("Kenney/woosh2_Modified.ogg", "Kenney/woosh2_Modified.flac");
                        default: 
                            throw new System.Exception();
                    }
                },
                GetSoundVolume: function (sound) {
                    switch (sound) {
                        case ChessCompStompWithHacksLibrary.GameSound.PlayerMove: 
                            return 10;
                        case ChessCompStompWithHacksLibrary.GameSound.AIMove: 
                            return 10;
                        case ChessCompStompWithHacksLibrary.GameSound.Win: 
                            return 10;
                        case ChessCompStompWithHacksLibrary.GameSound.StalemateOrDefeat: 
                            return 10;
                        case ChessCompStompWithHacksLibrary.GameSound.NukeLaunch: 
                            return 20;
                        case ChessCompStompWithHacksLibrary.GameSound.NukeExplosion: 
                            return 20;
                        case ChessCompStompWithHacksLibrary.GameSound.Click: 
                            return 30;
                        case ChessCompStompWithHacksLibrary.GameSound.Woosh: 
                            return 20;
                        default: 
                            throw new System.Exception();
                    }
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.GameSoundUtil.SoundFilenameInfo", {
        $kind: "nested class",
        fields: {
            OggFilename: null,
            FlacFilename: null
        },
        ctors: {
            ctor: function (oggFilename, flacFilename) {
                this.$initialize();
                this.OggFilename = oggFilename;
                this.FlacFilename = flacFilename;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.GlobalConstants", {
        statics: {
            fields: {
                /**
                 * The width in pixels, when the display type is "desktop"
                 When the display type is mobile, the width may vary.
                 *
                 * @static
                 * @public
                 * @memberof ChessCompStompWithHacksLibrary.GlobalConstants
                 * @constant
                 * @default 1000
                 * @type number
                 */
                DESKTOP_WINDOW_WIDTH: 0,
                /**
                 * The height in pixels, when the display type is "desktop"
                 When the display type is mobile, the height may vary.
                 *
                 * @static
                 * @public
                 * @memberof ChessCompStompWithHacksLibrary.GlobalConstants
                 * @constant
                 * @default 700
                 * @type number
                 */
                DESKTOP_WINDOW_HEIGHT: 0,
                FILE_ID_FOR_GLOBAL_CONFIGURATION: 0,
                FILE_ID_FOR_SESSION_STATE: 0,
                FILE_ID_FOR_SOUND_AND_MUSIC_VOLUME: 0
            },
            ctors: {
                init: function () {
                    this.DESKTOP_WINDOW_WIDTH = 1000;
                    this.DESKTOP_WINDOW_HEIGHT = 700;
                    this.FILE_ID_FOR_GLOBAL_CONFIGURATION = 1;
                    this.FILE_ID_FOR_SESSION_STATE = 2;
                    this.FILE_ID_FOR_SOUND_AND_MUSIC_VOLUME = 3;
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.GlobalState", {
        statics: {
            fields: {
                DEFAULT_VOLUME: 0
            },
            ctors: {
                init: function () {
                    this.DEFAULT_VOLUME = 50;
                }
            }
        },
        fields: {
            Fps: 0,
            Rng: null,
            GuidGenerator: null,
            Logger: null,
            Timer: null,
            FileIO: null,
            BuildType: 0,
            DebugMode: false,
            saveAndLoadData: null,
            UseDebugAI: false,
            desiredMusicVolume: 0,
            currentMusicVolume: 0,
            MusicPlayer: null,
            ElapsedMicrosPerFrame: 0
        },
        props: {
            MusicVolume: {
                get: function () {
                    return this.desiredMusicVolume;
                },
                set: function (value) {
                    this.desiredMusicVolume = value;
                }
            }
        },
        ctors: {
            ctor: function (fps, rng, guidGenerator, logger, timer, fileIO, buildType, debugMode, useDebugAI, initialMusicVolume) {
                var $t;
                this.$initialize();
                this.Fps = fps;
                this.Rng = rng;
                this.GuidGenerator = guidGenerator;
                this.Logger = logger;
                this.Timer = timer;
                this.FileIO = fileIO;
                this.BuildType = buildType;
                this.DebugMode = debugMode;
                this.desiredMusicVolume = ($t = initialMusicVolume, $t != null ? $t : ChessCompStompWithHacksLibrary.GlobalState.DEFAULT_VOLUME);
                this.currentMusicVolume = this.desiredMusicVolume;

                var elapsedMicrosPerFrame = (Bridge.Int.div(1000000, fps)) | 0;

                this.MusicPlayer = new ChessCompStompWithHacksLibrary.MusicPlayer(elapsedMicrosPerFrame);
                this.ElapsedMicrosPerFrame = elapsedMicrosPerFrame;

                this.saveAndLoadData = new ChessCompStompWithHacksLibrary.SaveAndLoadData(fileIO, ChessCompStompWithHacksLibrary.VersionHistory.GetVersionInfo());

                this.UseDebugAI = useDebugAI;
            }
        },
        methods: {
            ProcessMusic: function () {
                this.MusicPlayer.ProcessFrame();
                this.currentMusicVolume = DTLibrary.VolumeUtil.GetVolumeSmoothed(this.ElapsedMicrosPerFrame, this.currentMusicVolume, this.desiredMusicVolume);
            },
            RenderMusic: function (musicOutput) {
                this.MusicPlayer.RenderMusic(musicOutput, this.currentMusicVolume);
            },
            SaveData: function (sessionState, soundVolume) {
                this.saveAndLoadData.SaveData(sessionState, soundVolume, this.desiredMusicVolume);
            },
            LoadSessionState: function (sessionState) {
                this.saveAndLoadData.LoadSessionState(sessionState);
            },
            LoadSoundVolume: function () {
                return this.saveAndLoadData.LoadSoundVolume();
            },
            LoadMusicVolume: function () {
                var musicVolume = this.saveAndLoadData.LoadMusicVolume();

                if (System.Nullable.hasValue(musicVolume)) {
                    this.desiredMusicVolume = System.Nullable.getValue(musicVolume);
                    this.currentMusicVolume = System.Nullable.getValue(musicVolume);
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackDisplay", {
        statics: {
            methods: {
                GetResearchedHackBackgroundColor: function (theme) {
                    switch (theme) {
                        case ChessCompStompWithHacksLibrary.HackDisplay.Theme.Blue: 
                            return new DTLibrary.DTColor.ctor(196, 234, 255);
                        case ChessCompStompWithHacksLibrary.HackDisplay.Theme.Green: 
                            return new DTLibrary.DTColor.ctor(201, 255, 196);
                        case ChessCompStompWithHacksLibrary.HackDisplay.Theme.Purple: 
                            return new DTLibrary.DTColor.ctor(202, 196, 255);
                        default: 
                            throw new System.Exception();
                    }
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackDisplay.Theme", {
        $kind: "nested enum",
        statics: {
            fields: {
                Blue: 0,
                Green: 1,
                Purple: 2
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackDisplayDesktop", {
        statics: {
            fields: {
                WIDTH: 0,
                HEIGHT: 0
            },
            ctors: {
                init: function () {
                    this.WIDTH = 155;
                    this.HEIGHT = 100;
                }
            }
        },
        fields: {
            hack: 0,
            x: 0,
            y: 0,
            sessionState: null,
            isHover: false,
            isLeftClick: false,
            isRightClick: false,
            mouseX: 0,
            mouseY: 0,
            previousMouseInput: null,
            allowResearchingHacks: false,
            theme: 0
        },
        ctors: {
            ctor: function (hack, x, y, allowResearchingHacks, sessionState, theme) {
                this.$initialize();
                this.hack = hack;
                this.x = x;
                this.y = y;
                this.allowResearchingHacks = allowResearchingHacks;
                this.sessionState = sessionState;
                this.theme = theme;

                this.mouseX = 0;
                this.mouseY = 0;

                this.isHover = false;
                this.isLeftClick = false;
                this.isRightClick = false;

                this.previousMouseInput = null;
            }
        },
        methods: {
            GetHack: function () {
                return this.hack;
            },
            /**
             * Returns true iff the player right-clicked the hack
             *
             * @instance
             * @public
             * @this ChessCompStompWithHacksLibrary.HackDisplayDesktop
             * @memberof ChessCompStompWithHacksLibrary.HackDisplayDesktop
             * @param   {DTLibrary.IMouse}                  mouseInput            
             * @param   {DTLibrary.IMouse}                  previousMouseInput    
             * @param   {DTLibrary.ISoundOutput$1}          soundOutput           
             * @param   {DTLibrary.IDisplayProcessing$1}    displayProcessing
             * @return  {boolean}
             */
            ProcessFrame: function (mouseInput, previousMouseInput, soundOutput, displayProcessing) {
                if (this.previousMouseInput != null) {
                    previousMouseInput = this.previousMouseInput;
                }

                this.previousMouseInput = new DTLibrary.CopiedMouse(mouseInput);

                var mouseX = mouseInput.DTLibrary$IMouse$GetX();
                var mouseY = mouseInput.DTLibrary$IMouse$GetY();

                this.mouseX = mouseX;
                this.mouseY = mouseY;

                var isHover = this.x <= mouseX && mouseX <= ((this.x + ChessCompStompWithHacksLibrary.HackDisplayDesktop.WIDTH) | 0) && this.y <= mouseY && mouseY <= ((this.y + ChessCompStompWithHacksLibrary.HackDisplayDesktop.HEIGHT) | 0);

                this.isHover = isHover;
                if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && isHover) {
                    this.isLeftClick = true;
                }

                if (mouseInput.DTLibrary$IMouse$IsRightMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsRightMouseButtonPressed() && isHover) {
                    this.isRightClick = true;
                }

                if (this.isLeftClick && !mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                    this.isLeftClick = false;

                    if (this.allowResearchingHacks) {
                        if (isHover) {
                            soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        }

                        if (isHover && this.CanAffordHack()) {
                            this.sessionState.AddResearchedHack(this.hack);
                        }
                    }
                }

                var returnValue = false;

                if (this.isRightClick && !mouseInput.DTLibrary$IMouse$IsRightMouseButtonPressed() && previousMouseInput.DTLibrary$IMouse$IsRightMouseButtonPressed()) {
                    this.isRightClick = false;

                    if (isHover) {
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        returnValue = true;
                    }
                }

                return returnValue;
            },
            CanAffordHack: function () {
                return this.sessionState.GetUnusedHackPoints() >= ChessCompStompWithHacksLibrary.HackUtil.GetHackCost(this.hack);
            },
            RenderHoverDisplay: function (displayOutput) {
                if (this.isHover) {
                    var hackDescription = ChessCompStompWithHacksLibrary.HackUtil.GetHackDescriptionForHackSelectionScreen(this.hack);
                    var text = (hackDescription.Description || "") + "\n\n" + "Right click for more details";

                    var numberOfNewLines = 0;
                    for (var i = 0; i < text.length; i = (i + 1) | 0) {
                        if (text.charCodeAt(i) === 10) {
                            numberOfNewLines = (numberOfNewLines + 1) | 0;
                        }
                    }

                    var width = Math.max(hackDescription.Width, 320);
                    var height = (Bridge.Int.mul(19, (((numberOfNewLines + 1) | 0))) + 20) | 0;

                    var x;
                    if (((this.mouseX + width) | 0) > ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH) {
                        x = (this.mouseX - width) | 0;
                    } else {
                        x = this.mouseX;
                    }

                    var y;
                    if (((this.mouseY - height) | 0) < 0) {
                        y = this.mouseY;
                    } else {
                        y = (this.mouseY - height) | 0;
                    }

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(x, y, ((width - 1) | 0), ((height - 1) | 0), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetTextBackgroundColor(this.sessionState.GetColorTheme()), true);
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(x, y, width, height, DTLibrary.DTColor.Black(), false);

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((x + 25) | 0), ((((y + height) | 0) - 10) | 0), text, ChessCompStompWithHacksLibrary.GameFont.GameFont14Pt, DTLibrary.DTColor.Black());
                }
            },
            RenderButtonDisplay: function (displayOutput) {
                var backgroundColor;

                var hasResearchedHack = this.sessionState.GetResearchedHacks().contains(this.hack);
                var canAffordHack = this.CanAffordHack();

                if (hasResearchedHack) {
                    backgroundColor = ChessCompStompWithHacksLibrary.HackDisplay.GetResearchedHackBackgroundColor(this.theme);
                } else {
                    if (canAffordHack && this.isLeftClick && this.allowResearchingHacks) {
                        backgroundColor = ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(this.sessionState.GetColorTheme());
                    } else {
                        if (canAffordHack && this.isHover && this.allowResearchingHacks) {
                            backgroundColor = ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(this.sessionState.GetColorTheme());
                        } else {
                            if (canAffordHack && this.allowResearchingHacks) {
                                backgroundColor = new DTLibrary.DTColor.ctor(235, 235, 235);
                            } else {
                                backgroundColor = new DTLibrary.DTColor.ctor(200, 200, 200);
                            }
                        }
                    }
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(this.x, this.y, 154, 99, backgroundColor, true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(this.x, this.y, ChessCompStompWithHacksLibrary.HackDisplayDesktop.WIDTH, ChessCompStompWithHacksLibrary.HackDisplayDesktop.HEIGHT, DTLibrary.DTColor.Black(), false);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((this.x + 3) | 0), ((this.y + 90) | 0), ChessCompStompWithHacksLibrary.HackUtil.GetHackNameForHackSelectionScreen(this.hack), ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, DTLibrary.DTColor.Black());

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((this.x + 3) | 0), ((this.y + 39) | 0), "Cost: " + (DTLibrary.StringUtil.ToStringCultureInvariant(ChessCompStompWithHacksLibrary.HackUtil.GetHackCost(this.hack)) || "") + " points", ChessCompStompWithHacksLibrary.GameFont.GameFont12Pt, new DTLibrary.DTColor.ctor(128, 128, 128));

                if (hasResearchedHack) {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((this.x + 3) | 0), ((this.y + 20) | 0), "Hack implemented", ChessCompStompWithHacksLibrary.GameFont.GameFont12Pt, new DTLibrary.DTColor.ctor(128, 128, 128));
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackDisplayMobile", {
        statics: {
            fields: {
                HACK_DISPLAY_WIDTH: 0,
                MORE_DETAILS_WIDTH: 0,
                HEIGHT: 0
            },
            ctors: {
                init: function () {
                    this.HACK_DISPLAY_WIDTH = 155;
                    this.MORE_DETAILS_WIDTH = 100;
                    this.HEIGHT = 100;
                }
            }
        },
        fields: {
            hack: 0,
            x: 0,
            y: 0,
            sessionState: null,
            hasClickedOnHack: false,
            hasClickedOnMoreDetails: false,
            previousMouseInput: null,
            allowResearchingHacks: false,
            theme: 0
        },
        ctors: {
            ctor: function (hack, x, y, allowResearchingHacks, sessionState, theme) {
                this.$initialize();
                this.hack = hack;
                this.x = x;
                this.y = y;
                this.allowResearchingHacks = allowResearchingHacks;
                this.sessionState = sessionState;
                this.theme = theme;

                this.hasClickedOnHack = false;
                this.hasClickedOnMoreDetails = false;

                this.previousMouseInput = null;
            }
        },
        methods: {
            GetHack: function () {
                return this.hack;
            },
            SetX: function (x) {
                this.x = x;
            },
            SetY: function (y) {
                this.y = y;
            },
            /**
             * Returns true iff the player clicked "More Details"
             *
             * @instance
             * @public
             * @this ChessCompStompWithHacksLibrary.HackDisplayMobile
             * @memberof ChessCompStompWithHacksLibrary.HackDisplayMobile
             * @param   {DTLibrary.IMouse}                  mouseInput            
             * @param   {DTLibrary.IMouse}                  previousMouseInput    
             * @param   {DTLibrary.ISoundOutput$1}          soundOutput           
             * @param   {DTLibrary.IDisplayProcessing$1}    displayProcessing
             * @return  {boolean}
             */
            ProcessFrame: function (mouseInput, previousMouseInput, soundOutput, displayProcessing) {
                if (this.previousMouseInput != null) {
                    previousMouseInput = this.previousMouseInput;
                }

                this.previousMouseInput = new DTLibrary.CopiedMouse(mouseInput);

                var mouseX = mouseInput.DTLibrary$IMouse$GetX();
                var mouseY = mouseInput.DTLibrary$IMouse$GetY();

                var isHoverOverHack = this.x <= mouseX && mouseX <= ((this.x + ChessCompStompWithHacksLibrary.HackDisplayMobile.HACK_DISPLAY_WIDTH) | 0) && this.y <= mouseY && mouseY <= ((this.y + ChessCompStompWithHacksLibrary.HackDisplayMobile.HEIGHT) | 0);
                var isHoverOverMoreDetails = ((this.x + ChessCompStompWithHacksLibrary.HackDisplayMobile.HACK_DISPLAY_WIDTH) | 0) < mouseX && mouseX <= ((((this.x + ChessCompStompWithHacksLibrary.HackDisplayMobile.HACK_DISPLAY_WIDTH) | 0) + ChessCompStompWithHacksLibrary.HackDisplayMobile.MORE_DETAILS_WIDTH) | 0) && this.y <= mouseY && mouseY <= ((this.y + ChessCompStompWithHacksLibrary.HackDisplayMobile.HEIGHT) | 0);

                if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && isHoverOverHack) {
                    this.hasClickedOnHack = true;
                }

                if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && isHoverOverMoreDetails) {
                    this.hasClickedOnMoreDetails = true;
                }

                if (this.hasClickedOnHack && !mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                    this.hasClickedOnHack = false;

                    if (this.allowResearchingHacks) {
                        if (isHoverOverHack) {
                            soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        }

                        if (isHoverOverHack && this.CanAffordHack()) {
                            this.sessionState.AddResearchedHack(this.hack);
                        }
                    }
                }

                var returnValue = false;

                if (this.hasClickedOnMoreDetails && !mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                    this.hasClickedOnMoreDetails = false;

                    if (isHoverOverMoreDetails) {
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        returnValue = true;
                    }
                }

                return returnValue;
            },
            CanAffordHack: function () {
                return this.sessionState.GetUnusedHackPoints() >= ChessCompStompWithHacksLibrary.HackUtil.GetHackCost(this.hack);
            },
            RenderButtonDisplay: function (displayOutput) {
                var hackDisplayBackgroundColor;
                var moreDetailsBackgroundColor;

                var hasResearchedHack = this.sessionState.GetResearchedHacks().contains(this.hack);
                var canAffordHack = this.CanAffordHack();

                if (hasResearchedHack) {
                    hackDisplayBackgroundColor = ChessCompStompWithHacksLibrary.HackDisplay.GetResearchedHackBackgroundColor(this.theme);
                } else {
                    if (canAffordHack && this.hasClickedOnHack && this.allowResearchingHacks) {
                        hackDisplayBackgroundColor = ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(this.sessionState.GetColorTheme());
                    } else {
                        if (canAffordHack && this.allowResearchingHacks) {
                            hackDisplayBackgroundColor = new DTLibrary.DTColor.ctor(235, 235, 235);
                        } else {
                            hackDisplayBackgroundColor = new DTLibrary.DTColor.ctor(200, 200, 200);
                        }
                    }
                }

                if (this.hasClickedOnMoreDetails) {
                    moreDetailsBackgroundColor = ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(this.sessionState.GetColorTheme());
                } else {
                    moreDetailsBackgroundColor = hackDisplayBackgroundColor;
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(this.x, this.y, ChessCompStompWithHacksLibrary.HackDisplayMobile.HACK_DISPLAY_WIDTH, ChessCompStompWithHacksLibrary.HackDisplayMobile.HEIGHT, hackDisplayBackgroundColor, true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(this.x, this.y, ChessCompStompWithHacksLibrary.HackDisplayMobile.HACK_DISPLAY_WIDTH, ChessCompStompWithHacksLibrary.HackDisplayMobile.HEIGHT, DTLibrary.DTColor.Black(), false);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((this.x + 3) | 0), ((this.y + 90) | 0), ChessCompStompWithHacksLibrary.HackUtil.GetHackNameForHackSelectionScreen(this.hack), ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, DTLibrary.DTColor.Black());

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((this.x + 3) | 0), ((this.y + 39) | 0), "Cost: " + (DTLibrary.StringUtil.ToStringCultureInvariant(ChessCompStompWithHacksLibrary.HackUtil.GetHackCost(this.hack)) || "") + " points", ChessCompStompWithHacksLibrary.GameFont.GameFont12Pt, new DTLibrary.DTColor.ctor(128, 128, 128));

                if (hasResearchedHack) {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((this.x + 3) | 0), ((this.y + 20) | 0), "Hack implemented", ChessCompStompWithHacksLibrary.GameFont.GameFont12Pt, new DTLibrary.DTColor.ctor(128, 128, 128));
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(((this.x + ChessCompStompWithHacksLibrary.HackDisplayMobile.HACK_DISPLAY_WIDTH) | 0), this.y, ChessCompStompWithHacksLibrary.HackDisplayMobile.MORE_DETAILS_WIDTH, ChessCompStompWithHacksLibrary.HackDisplayMobile.HEIGHT, moreDetailsBackgroundColor, true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(((this.x + ChessCompStompWithHacksLibrary.HackDisplayMobile.HACK_DISPLAY_WIDTH) | 0), this.y, ChessCompStompWithHacksLibrary.HackDisplayMobile.MORE_DETAILS_WIDTH, ChessCompStompWithHacksLibrary.HackDisplayMobile.HEIGHT, DTLibrary.DTColor.Black(), false);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((((this.x + ChessCompStompWithHacksLibrary.HackDisplayMobile.HACK_DISPLAY_WIDTH) | 0) + 3) | 0), ((this.y + 90) | 0), "More\nDetails", ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, DTLibrary.DTColor.Black());
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.IHackExplanation", {
        $kind: "nested interface"
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackExplanation_OpponentMustCaptureWhenPossible.Status", {
        $kind: "nested enum",
        statics: {
            fields: {
                PlayerAboutToClickFirstPiece: 0,
                PlayerAboutToMakeFirstMove: 1,
                OpponentAboutToClickPiece: 2,
                OpponentAboutToMakeMove: 3,
                PlayerAboutToClickSecondPiece: 4,
                PlayerAboutToMakeSecondMove: 5,
                Finished: 6
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackExplanation_PawnsDestroyCapturingPiece.Status", {
        $kind: "nested enum",
        statics: {
            fields: {
                PlayerAboutToClickPiece: 0,
                PlayerAboutToMakeMove: 1,
                OpponentAboutToClickPiece: 2,
                OpponentAboutToMakeMove: 3,
                Finished: 4
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackExplanation_StalemateIsVictory.Status", {
        $kind: "nested enum",
        statics: {
            fields: {
                PlayerAboutToClickFirstPiece: 0,
                PlayerAboutToMakeFirstMove: 1,
                OpponentAboutToClickPiece: 2,
                OpponentAboutToMakeMove: 3,
                PlayerAboutToClickSecondPiece: 4,
                PlayerAboutToMakeSecondMove: 5,
                AboutToShowVictoryPanel: 6,
                Finished: 7
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackExplanationFrameUtil", {
        statics: {
            fields: {
                CHESS_PIECES_RENDERER_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE: 0,
                CHESS_PIECES_RENDERER_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE: 0,
                CHESS_PIECES_RENDERER_X_OFFSET_MOBILE_PORTRAIT: 0,
                CHESS_PIECES_RENDERER_Y_OFFSET_MOBILE_PORTRAIT: 0,
                TITLE_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE: 0,
                TITLE_TEXT_Y_OFFSET_MOBILE_PORTRAIT: 0,
                EXPLANATION_TEXT_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE: 0,
                EXPLANATION_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE: 0,
                EXPLANATION_TEXT_X_OFFSET_MOBILE_PORTRAIT: 0,
                EXPLANATION_TEXT_Y_OFFSET_MOBILE_PORTRAIT: 0,
                ELAPSED_MICROS_BEFORE_PIECE_MOVES: 0
            },
            ctors: {
                init: function () {
                    this.CHESS_PIECES_RENDERER_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE = 350;
                    this.CHESS_PIECES_RENDERER_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE = 25;
                    this.CHESS_PIECES_RENDERER_X_OFFSET_MOBILE_PORTRAIT = 52;
                    this.CHESS_PIECES_RENDERER_Y_OFFSET_MOBILE_PORTRAIT = 325;
                    this.TITLE_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE = 580;
                    this.TITLE_TEXT_Y_OFFSET_MOBILE_PORTRAIT = 880;
                    this.EXPLANATION_TEXT_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE = 15;
                    this.EXPLANATION_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE = 519;
                    this.EXPLANATION_TEXT_X_OFFSET_MOBILE_PORTRAIT = 52;
                    this.EXPLANATION_TEXT_Y_OFFSET_MOBILE_PORTRAIT = 300;
                    this.ELAPSED_MICROS_BEFORE_PIECE_MOVES = 1500000;
                }
            },
            methods: {
                GetHackExplanation: function (hack, colorTheme, random, hasExtraPawnFirstHack, timer, elapsedMicrosPerFrame) {
                    switch (hack) {
                        case ChessCompStompWithHacksEngine.Hack.ExtraPawnFirst: 
                            return new ChessCompStompWithHacksLibrary.HackExplanation_ExtraPawnFirst(colorTheme, elapsedMicrosPerFrame);
                        case ChessCompStompWithHacksEngine.Hack.ExtraPawnSecond: 
                            return new ChessCompStompWithHacksLibrary.HackExplanation_ExtraPawnSecond(colorTheme, hasExtraPawnFirstHack, elapsedMicrosPerFrame);
                        case ChessCompStompWithHacksEngine.Hack.ExtraQueen: 
                            return new ChessCompStompWithHacksLibrary.HackExplanation_ExtraQueen(colorTheme, elapsedMicrosPerFrame);
                        case ChessCompStompWithHacksEngine.Hack.QueensCanMoveLikeKnights: 
                            return new ChessCompStompWithHacksLibrary.HackExplanation_QueensCanMoveLikeKnights(colorTheme, random);
                        case ChessCompStompWithHacksEngine.Hack.RooksCanMoveLikeBishops: 
                            return new ChessCompStompWithHacksLibrary.HackExplanation_RooksCanMoveLikeBishops(colorTheme, random);
                        case ChessCompStompWithHacksEngine.Hack.TacticalNuke: 
                            return new ChessCompStompWithHacksLibrary.HackExplanation_TacticalNuke(colorTheme, timer, elapsedMicrosPerFrame);
                        case ChessCompStompWithHacksEngine.Hack.PawnsCanMoveThreeSpacesInitially: 
                            return new ChessCompStompWithHacksLibrary.HackExplanation_PawnsCanMoveThreeSpacesInitially(colorTheme, random);
                        case ChessCompStompWithHacksEngine.Hack.KnightsCanMakeLargeKnightsMove: 
                            return new ChessCompStompWithHacksLibrary.HackExplanation_KnightsCanMakeLargeKnightsMove(colorTheme, random);
                        case ChessCompStompWithHacksEngine.Hack.SuperCastling: 
                            return new ChessCompStompWithHacksLibrary.HackExplanation_SuperCastling(colorTheme, random);
                        case ChessCompStompWithHacksEngine.Hack.RooksCanCaptureLikeCannons: 
                            return new ChessCompStompWithHacksLibrary.HackExplanation_RooksCanCaptureLikeCannons(colorTheme, random);
                        case ChessCompStompWithHacksEngine.Hack.AnyPieceCanPromote: 
                            return new ChessCompStompWithHacksLibrary.HackExplanation_AnyPieceCanPromote(colorTheme, random);
                        case ChessCompStompWithHacksEngine.Hack.OpponentMustCaptureWhenPossible: 
                            return new ChessCompStompWithHacksLibrary.HackExplanation_OpponentMustCaptureWhenPossible(colorTheme, random);
                        case ChessCompStompWithHacksEngine.Hack.PawnsDestroyCapturingPiece: 
                            return new ChessCompStompWithHacksLibrary.HackExplanation_PawnsDestroyCapturingPiece(colorTheme, random);
                        case ChessCompStompWithHacksEngine.Hack.SuperEnPassant: 
                            return new ChessCompStompWithHacksLibrary.HackExplanation_SuperEnPassant(colorTheme, random);
                        case ChessCompStompWithHacksEngine.Hack.StalemateIsVictory: 
                            return new ChessCompStompWithHacksLibrary.HackExplanation_StalemateIsVictory(colorTheme, random);
                        default: 
                            throw new System.Exception();
                    }
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackSelectionScreenDisplayDesktop", {
        statics: {
            fields: {
                FIRST_SET_OF_HACKS_X: 0,
                SECOND_SET_OF_HACKS_X: 0,
                THIRD_SET_OF_HACKS_X: 0
            },
            ctors: {
                init: function () {
                    this.FIRST_SET_OF_HACKS_X = 8;
                    this.SECOND_SET_OF_HACKS_X = 336;
                    this.THIRD_SET_OF_HACKS_X = 664;
                }
            }
        },
        fields: {
            sessionState: null,
            hackDisplays: null,
            resetHacksButton: null,
            allowResearchingHacks: false
        },
        ctors: {
            ctor: function (sessionState, allowResearchingHacks) {
                this.$initialize();
                this.sessionState = sessionState;

                this.allowResearchingHacks = allowResearchingHacks;

                this.resetHacksButton = new ChessCompStompWithHacksLibrary.Button(8, 70, 170, 40, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Reset hacks", 18, 9, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, false);

                this.hackDisplays = new (System.Collections.Generic.List$1(ChessCompStompWithHacksLibrary.HackDisplayDesktop)).ctor();

                var addHackDisplay = Bridge.fn.bind(this, function (hack, x, y, theme) {
                    this.hackDisplays.add(new ChessCompStompWithHacksLibrary.HackDisplayDesktop(hack, x, y, allowResearchingHacks, sessionState, theme));
                });

                var addHackDisplayInFirstSet = function (hack, x, y) {
                    addHackDisplay(hack, ((ChessCompStompWithHacksLibrary.HackSelectionScreenDisplayDesktop.FIRST_SET_OF_HACKS_X + x) | 0), y, ChessCompStompWithHacksLibrary.HackDisplay.Theme.Green);
                };

                var addHackDisplayInSecondSet = function (hack, x, y) {
                    addHackDisplay(hack, ((ChessCompStompWithHacksLibrary.HackSelectionScreenDisplayDesktop.SECOND_SET_OF_HACKS_X + x) | 0), y, ChessCompStompWithHacksLibrary.HackDisplay.Theme.Blue);
                };

                var addHackDisplayInThirdSet = function (hack, x, y) {
                    addHackDisplay(hack, ((ChessCompStompWithHacksLibrary.HackSelectionScreenDisplayDesktop.THIRD_SET_OF_HACKS_X + x) | 0), y, ChessCompStompWithHacksLibrary.HackDisplay.Theme.Purple);
                };

                var firstXOffset = 6;
                var secondXOffset = 167;

                var firstRow = 431;
                var secondRow = (firstRow - 127) | 0;
                var thirdRow = (secondRow - 126) | 0;

                addHackDisplayInFirstSet(ChessCompStompWithHacksEngine.Hack.PawnsCanMoveThreeSpacesInitially, firstXOffset, firstRow);
                addHackDisplayInFirstSet(ChessCompStompWithHacksEngine.Hack.KnightsCanMakeLargeKnightsMove, firstXOffset, secondRow);
                addHackDisplayInFirstSet(ChessCompStompWithHacksEngine.Hack.RooksCanCaptureLikeCannons, secondXOffset, secondRow);
                addHackDisplayInFirstSet(ChessCompStompWithHacksEngine.Hack.TacticalNuke, firstXOffset, thirdRow);

                addHackDisplayInSecondSet(ChessCompStompWithHacksEngine.Hack.ExtraPawnFirst, firstXOffset, firstRow);
                addHackDisplayInSecondSet(ChessCompStompWithHacksEngine.Hack.ExtraPawnSecond, secondXOffset, firstRow);
                addHackDisplayInSecondSet(ChessCompStompWithHacksEngine.Hack.ExtraQueen, firstXOffset, secondRow);
                addHackDisplayInSecondSet(ChessCompStompWithHacksEngine.Hack.OpponentMustCaptureWhenPossible, firstXOffset, thirdRow);
                addHackDisplayInSecondSet(ChessCompStompWithHacksEngine.Hack.PawnsDestroyCapturingPiece, secondXOffset, thirdRow);

                addHackDisplayInThirdSet(ChessCompStompWithHacksEngine.Hack.SuperCastling, firstXOffset, firstRow);
                addHackDisplayInThirdSet(ChessCompStompWithHacksEngine.Hack.StalemateIsVictory, secondXOffset, firstRow);
                addHackDisplayInThirdSet(ChessCompStompWithHacksEngine.Hack.RooksCanMoveLikeBishops, firstXOffset, secondRow);
                addHackDisplayInThirdSet(ChessCompStompWithHacksEngine.Hack.QueensCanMoveLikeKnights, secondXOffset, secondRow);
                addHackDisplayInThirdSet(ChessCompStompWithHacksEngine.Hack.SuperEnPassant, firstXOffset, thirdRow);
                addHackDisplayInThirdSet(ChessCompStompWithHacksEngine.Hack.AnyPieceCanPromote, secondXOffset, thirdRow);
            }
        },
        methods: {
            /**
             * Returns the hack that the player right-clicked (or null if the player didn't right-click any hacks)
             *
             * @instance
             * @public
             * @this ChessCompStompWithHacksLibrary.HackSelectionScreenDisplayDesktop
             * @memberof ChessCompStompWithHacksLibrary.HackSelectionScreenDisplayDesktop
             * @param   {DTLibrary.IMouse}                       mouseInput            
             * @param   {DTLibrary.IMouse}                       previousMouseInput    
             * @param   {DTLibrary.IDisplayProcessing$1}         displayProcessing     
             * @param   {DTLibrary.ISoundOutput$1}               soundOutput
             * @return  {?ChessCompStompWithHacksEngine.Hack}
             */
            ProcessFrame: function (mouseInput, previousMouseInput, displayProcessing, soundOutput) {
                var $t;
                var rightClickedHack = null;

                $t = Bridge.getEnumerator(this.hackDisplays);
                try {
                    while ($t.moveNext()) {
                        var hackDisplay = $t.Current;
                        var hasRightClicked = hackDisplay.ProcessFrame(mouseInput, previousMouseInput, soundOutput, displayProcessing);

                        if (hasRightClicked) {
                            rightClickedHack = hackDisplay.GetHack();
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                if (this.allowResearchingHacks) {
                    var clickedResetHacksButton = this.resetHacksButton.ProcessFrame(mouseInput, previousMouseInput);
                    if (clickedResetHacksButton) {
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        this.sessionState.ResetResearchedHacks();
                    }
                }

                return rightClickedHack;
            },
            RenderButtons: function (displayOutput) {
                var $t;
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(436, 675, "Hacks", ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt, DTLibrary.DTColor.Black());

                var gray = new DTLibrary.DTColor.ctor(150, 150, 150);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(ChessCompStompWithHacksLibrary.HackSelectionScreenDisplayDesktop.FIRST_SET_OF_HACKS_X, 150, 329, 450, gray, false);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(ChessCompStompWithHacksLibrary.HackSelectionScreenDisplayDesktop.SECOND_SET_OF_HACKS_X, 150, 329, 450, gray, false);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(ChessCompStompWithHacksLibrary.HackSelectionScreenDisplayDesktop.THIRD_SET_OF_HACKS_X, 150, 329, 450, gray, false);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(122, 590, "Tactics", ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(435, 590, "Eliteness", ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(740, 590, "Rule warping", ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                $t = Bridge.getEnumerator(this.hackDisplays);
                try {
                    while ($t.moveNext()) {
                        var hackDisplay = $t.Current;
                        hackDisplay.RenderButtonDisplay(displayOutput);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                if (this.allowResearchingHacks) {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(250, 122, "Hack points remaining: " + (DTLibrary.StringUtil.ToStringCultureInvariant(this.sessionState.GetUnusedHackPoints()) || "") + "\n" + "Get more hack points by winning games" + "\n" + "and completing objectives!", ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, DTLibrary.DTColor.Black());

                    this.resetHacksButton.Render(displayOutput);
                }
            },
            RenderHoverDisplay: function (displayOutput) {
                var $t;
                $t = Bridge.getEnumerator(this.hackDisplays);
                try {
                    while ($t.moveNext()) {
                        var hackDisplay = $t.Current;
                        hackDisplay.RenderHoverDisplay(displayOutput);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackSelectionScreenDisplayMobile", {
        fields: {
            sessionState: null,
            hackDisplays: null,
            tabButtons: null,
            clickTab: null,
            resetHacksButton: null,
            allowResearchingHacks: false
        },
        ctors: {
            ctor: function (sessionState, allowResearchingHacks, display) {
                this.$initialize();
                this.tabButtons = function (_o1) {
                        _o1.add(new ChessCompStompWithHacksLibrary.HackSelectionScreenDisplayMobile.TabButton(0, 0, 10, 10, ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTab.Tactics, "Tactics", 97, 27));
                        _o1.add(new ChessCompStompWithHacksLibrary.HackSelectionScreenDisplayMobile.TabButton(0, 0, 10, 10, ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTab.Eliteness, "Eliteness", 124, 27));
                        _o1.add(new ChessCompStompWithHacksLibrary.HackSelectionScreenDisplayMobile.TabButton(0, 0, 10, 10, ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTab.RuleWarping, "Rule Warping", 173, 27));
                        return _o1;
                    }(new (System.Collections.Generic.List$1(ChessCompStompWithHacksLibrary.HackSelectionScreenDisplayMobile.TabButton)).ctor());

                this.clickTab = null;

                this.sessionState = sessionState;

                this.allowResearchingHacks = allowResearchingHacks;

                this.resetHacksButton = new ChessCompStompWithHacksLibrary.Button(20, 50, 10, 70, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Reset hacks", 0, 23, ChessCompStompWithHacksLibrary.GameFont.GameFont18Pt, true);

                this.hackDisplays = new (System.Collections.Generic.Dictionary$2(ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTab,System.Collections.Generic.List$1(System.Collections.Generic.List$1(ChessCompStompWithHacksLibrary.HackDisplayMobile))))();
                this.hackDisplays.set(ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTab.Tactics, function (_o2) {
                        _o2.add(new (System.Collections.Generic.List$1(ChessCompStompWithHacksLibrary.HackDisplayMobile)).ctor());
                        _o2.add(new (System.Collections.Generic.List$1(ChessCompStompWithHacksLibrary.HackDisplayMobile)).ctor());
                        _o2.add(new (System.Collections.Generic.List$1(ChessCompStompWithHacksLibrary.HackDisplayMobile)).ctor());
                        return _o2;
                    }(new (System.Collections.Generic.List$1(System.Collections.Generic.List$1(ChessCompStompWithHacksLibrary.HackDisplayMobile))).ctor()));
                this.hackDisplays.set(ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTab.Eliteness, function (_o3) {
                        _o3.add(new (System.Collections.Generic.List$1(ChessCompStompWithHacksLibrary.HackDisplayMobile)).ctor());
                        _o3.add(new (System.Collections.Generic.List$1(ChessCompStompWithHacksLibrary.HackDisplayMobile)).ctor());
                        _o3.add(new (System.Collections.Generic.List$1(ChessCompStompWithHacksLibrary.HackDisplayMobile)).ctor());
                        return _o3;
                    }(new (System.Collections.Generic.List$1(System.Collections.Generic.List$1(ChessCompStompWithHacksLibrary.HackDisplayMobile))).ctor()));
                this.hackDisplays.set(ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTab.RuleWarping, function (_o4) {
                        _o4.add(new (System.Collections.Generic.List$1(ChessCompStompWithHacksLibrary.HackDisplayMobile)).ctor());
                        _o4.add(new (System.Collections.Generic.List$1(ChessCompStompWithHacksLibrary.HackDisplayMobile)).ctor());
                        _o4.add(new (System.Collections.Generic.List$1(ChessCompStompWithHacksLibrary.HackDisplayMobile)).ctor());
                        return _o4;
                    }(new (System.Collections.Generic.List$1(System.Collections.Generic.List$1(ChessCompStompWithHacksLibrary.HackDisplayMobile))).ctor()));

                var addHackDisplay = Bridge.fn.bind(this, function (tab, hack, row, theme) {
                    this.hackDisplays.get(tab).getItem(row).add(new ChessCompStompWithHacksLibrary.HackDisplayMobile(hack, 0, 0, allowResearchingHacks, sessionState, theme));
                });

                var addHackDisplayInFirstSet = function (hack, row) {
                    addHackDisplay(ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTab.Tactics, hack, row, ChessCompStompWithHacksLibrary.HackDisplay.Theme.Green);
                };

                var addHackDisplayInSecondSet = function (hack, row) {
                    addHackDisplay(ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTab.Eliteness, hack, row, ChessCompStompWithHacksLibrary.HackDisplay.Theme.Blue);
                };

                var addHackDisplayInThirdSet = function (hack, row) {
                    addHackDisplay(ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTab.RuleWarping, hack, row, ChessCompStompWithHacksLibrary.HackDisplay.Theme.Purple);
                };

                addHackDisplayInFirstSet(ChessCompStompWithHacksEngine.Hack.PawnsCanMoveThreeSpacesInitially, 0);
                addHackDisplayInFirstSet(ChessCompStompWithHacksEngine.Hack.KnightsCanMakeLargeKnightsMove, 1);
                addHackDisplayInFirstSet(ChessCompStompWithHacksEngine.Hack.RooksCanCaptureLikeCannons, 1);
                addHackDisplayInFirstSet(ChessCompStompWithHacksEngine.Hack.TacticalNuke, 2);

                addHackDisplayInSecondSet(ChessCompStompWithHacksEngine.Hack.ExtraPawnFirst, 0);
                addHackDisplayInSecondSet(ChessCompStompWithHacksEngine.Hack.ExtraPawnSecond, 0);
                addHackDisplayInSecondSet(ChessCompStompWithHacksEngine.Hack.ExtraQueen, 1);
                addHackDisplayInSecondSet(ChessCompStompWithHacksEngine.Hack.OpponentMustCaptureWhenPossible, 2);
                addHackDisplayInSecondSet(ChessCompStompWithHacksEngine.Hack.PawnsDestroyCapturingPiece, 2);

                addHackDisplayInThirdSet(ChessCompStompWithHacksEngine.Hack.SuperCastling, 0);
                addHackDisplayInThirdSet(ChessCompStompWithHacksEngine.Hack.StalemateIsVictory, 0);
                addHackDisplayInThirdSet(ChessCompStompWithHacksEngine.Hack.RooksCanMoveLikeBishops, 1);
                addHackDisplayInThirdSet(ChessCompStompWithHacksEngine.Hack.QueensCanMoveLikeKnights, 1);
                addHackDisplayInThirdSet(ChessCompStompWithHacksEngine.Hack.SuperEnPassant, 2);
                addHackDisplayInThirdSet(ChessCompStompWithHacksEngine.Hack.AnyPieceCanPromote, 2);

                this.UpdateCoordinates(display);
            }
        },
        methods: {
            UpdateCoordinates: function (display) {
                var $t, $t1;
                var isLandscape = DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation(ChessCompStompWithHacksLibrary.GameImage, display);

                if (isLandscape) {
                    this.resetHacksButton.SetWidth(200);
                    this.resetHacksButton.SetTextXOffset(27);

                    this.tabButtons.getItem(0).SetX(50);
                    this.tabButtons.getItem(1).SetX(50);
                    this.tabButtons.getItem(2).SetX(50);

                    this.tabButtons.getItem(0).SetY(440);
                    this.tabButtons.getItem(1).SetY(340);
                    this.tabButtons.getItem(2).SetY(240);

                    var tabButtonWidth = (Bridge.Int.div(display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth(), 4)) | 0;
                    this.tabButtons.getItem(0).SetWidth(tabButtonWidth);
                    this.tabButtons.getItem(1).SetWidth(tabButtonWidth);
                    this.tabButtons.getItem(2).SetWidth(tabButtonWidth);

                    this.tabButtons.getItem(0).SetHeight(100);
                    this.tabButtons.getItem(1).SetHeight(100);
                    this.tabButtons.getItem(2).SetHeight(100);

                    var xStartOfTabContent = (50 + tabButtonWidth) | 0;

                    var widthOfTabContent = (((((display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth() - 50) | 0) - 50) | 0) - tabButtonWidth) | 0;

                    var amountOfWhitespace = (((widthOfTabContent - 255) | 0) - 255) | 0;

                    var xColumn0 = (xStartOfTabContent + ((Bridge.Int.div(amountOfWhitespace, 3)) | 0)) | 0;
                    var xColumn1 = (((((xStartOfTabContent + ((Bridge.Int.div(amountOfWhitespace, 3)) | 0)) | 0) + 255) | 0) + ((Bridge.Int.div(amountOfWhitespace, 3)) | 0)) | 0;

                    $t = Bridge.getEnumerator(this.hackDisplays.getValues(), System.Collections.Generic.List$1(System.Collections.Generic.List$1(ChessCompStompWithHacksLibrary.HackDisplayMobile)));
                    try {
                        while ($t.moveNext()) {
                            var hackDisplaysInTab = $t.Current;
                            for (var row = 0; row < 3; row = (row + 1) | 0) {
                                for (var column = 0; column < hackDisplaysInTab.getItem(row).Count; column = (column + 1) | 0) {
                                    var hackDisplay = hackDisplaysInTab.getItem(row).getItem(column);

                                    hackDisplay.SetX(column === 0 ? xColumn0 : xColumn1);
                                    hackDisplay.SetY(row === 0 ? 431 : (row === 1 ? 304 : 178));
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                } else {
                    this.resetHacksButton.SetWidth(160);
                    this.resetHacksButton.SetTextXOffset(7);

                    var tabButtonWidth1 = 190;

                    this.tabButtons.getItem(0).SetX(60);
                    this.tabButtons.getItem(1).SetX(((60 + tabButtonWidth1) | 0));
                    this.tabButtons.getItem(2).SetX(((60 + Bridge.Int.mul(tabButtonWidth1, 2)) | 0));

                    var tabButtonY = (display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenHeight() - 270) | 0;

                    this.tabButtons.getItem(0).SetY(tabButtonY);
                    this.tabButtons.getItem(1).SetY(tabButtonY);
                    this.tabButtons.getItem(2).SetY(tabButtonY);

                    this.tabButtons.getItem(0).SetWidth(tabButtonWidth1);
                    this.tabButtons.getItem(1).SetWidth(tabButtonWidth1);
                    this.tabButtons.getItem(2).SetWidth(tabButtonWidth1);

                    this.tabButtons.getItem(0).SetHeight(70);
                    this.tabButtons.getItem(1).SetHeight(70);
                    this.tabButtons.getItem(2).SetHeight(70);

                    var amountOfWhitespace1 = ((((((((tabButtonY - 158) | 0)) - 100) | 0) - 100) | 0) - 100) | 0;

                    var yRow2 = (158 + ((Bridge.Int.div(amountOfWhitespace1, 4)) | 0)) | 0;
                    var yRow1 = (((yRow2 + 100) | 0) + ((Bridge.Int.div(amountOfWhitespace1, 4)) | 0)) | 0;
                    var yRow0 = (((yRow1 + 100) | 0) + ((Bridge.Int.div(amountOfWhitespace1, 4)) | 0)) | 0;

                    $t1 = Bridge.getEnumerator(this.hackDisplays.getValues(), System.Collections.Generic.List$1(System.Collections.Generic.List$1(ChessCompStompWithHacksLibrary.HackDisplayMobile)));
                    try {
                        while ($t1.moveNext()) {
                            var hackDisplaysInTab1 = $t1.Current;
                            for (var row1 = 0; row1 < 3; row1 = (row1 + 1) | 0) {
                                for (var column1 = 0; column1 < hackDisplaysInTab1.getItem(row1).Count; column1 = (column1 + 1) | 0) {
                                    var hackDisplay1 = hackDisplaysInTab1.getItem(row1).getItem(column1);

                                    hackDisplay1.SetX(column1 === 0 ? 80 : 365);
                                    hackDisplay1.SetY(row1 === 0 ? yRow0 : (row1 === 1 ? yRow1 : yRow2));
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }
            },
            /**
             * Returns the hack that the player clicked "More Details" on (or null if the player didn't click "More Details" on any hacks)
             *
             * @instance
             * @public
             * @this ChessCompStompWithHacksLibrary.HackSelectionScreenDisplayMobile
             * @memberof ChessCompStompWithHacksLibrary.HackSelectionScreenDisplayMobile
             * @param   {DTLibrary.IMouse}                       mouseInput            
             * @param   {DTLibrary.IMouse}                       previousMouseInput    
             * @param   {DTLibrary.IDisplayProcessing$1}         displayProcessing     
             * @param   {DTLibrary.ISoundOutput$1}               soundOutput
             * @return  {?ChessCompStompWithHacksEngine.Hack}
             */
            ProcessFrame: function (mouseInput, previousMouseInput, displayProcessing, soundOutput) {
                var $t, $t1, $t2;
                this.UpdateCoordinates(displayProcessing);

                var clickedOnMoreDetailsHack = null;

                var mouseX = mouseInput.DTLibrary$IMouse$GetX();
                var mouseY = mouseInput.DTLibrary$IMouse$GetY();

                var hoverTab = null;
                $t = Bridge.getEnumerator(this.tabButtons);
                try {
                    while ($t.moveNext()) {
                        var tabButton = $t.Current;
                        if (tabButton.X <= mouseX && mouseX <= ((tabButton.X + tabButton.Width) | 0) && tabButton.Y <= mouseY && mouseY <= ((tabButton.Y + tabButton.Height) | 0)) {
                            hoverTab = tabButton.Tab;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                    if (hoverTab != null) {
                        this.clickTab = hoverTab;
                    }
                }

                if (this.clickTab != null && !mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                    if (System.Nullable.hasValue(hoverTab) && System.Nullable.getValue(hoverTab) === System.Nullable.getValue(this.clickTab)) {
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        this.sessionState.SetHackSelectionScreenMobileTab(System.Nullable.getValue(this.clickTab));
                    }

                    this.clickTab = null;
                }

                $t1 = Bridge.getEnumerator(this.hackDisplays.get(this.sessionState.GetHackSelectionScreenMobileTab()));
                try {
                    while ($t1.moveNext()) {
                        var hackDisplayList = $t1.Current;
                        $t2 = Bridge.getEnumerator(hackDisplayList);
                        try {
                            while ($t2.moveNext()) {
                                var hackDisplay = $t2.Current;
                                var hasClickedOnMoreDetails = hackDisplay.ProcessFrame(mouseInput, previousMouseInput, soundOutput, displayProcessing);

                                if (hasClickedOnMoreDetails) {
                                    clickedOnMoreDetailsHack = hackDisplay.GetHack();
                                }
                            }
                        } finally {
                            if (Bridge.is($t2, System.IDisposable)) {
                                $t2.System$IDisposable$Dispose();
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                if (this.allowResearchingHacks) {
                    var clickedResetHacksButton = this.resetHacksButton.ProcessFrame(mouseInput, previousMouseInput);
                    if (clickedResetHacksButton) {
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        this.sessionState.ResetResearchedHacks();
                    }
                }

                return clickedOnMoreDetailsHack;
            },
            RenderButtons: function (displayOutput) {
                var $t, $t1, $t2;
                var isLandscape = DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput);

                var gray = new DTLibrary.DTColor.ctor(150, 150, 150);

                if (isLandscape) {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((((Bridge.Int.div(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth(), 2)) | 0) - 90) | 0), 675, "Hacks", ChessCompStompWithHacksLibrary.GameFont.GameFont48Pt, DTLibrary.DTColor.Black());

                    var xStartOfTabContent = (this.tabButtons.getItem(0).X + this.tabButtons.getItem(0).Width) | 0;

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(xStartOfTabContent, 158, ((((displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth() - xStartOfTabContent) | 0) - 50) | 0), 400, new DTLibrary.DTColor.ctor(235, 235, 235), true);

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(xStartOfTabContent, 158, ((((displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth() - xStartOfTabContent) | 0) - 50) | 0), 400, gray, false);
                } else {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(260, ((displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight() - 100) | 0), "Hacks", ChessCompStompWithHacksLibrary.GameFont.GameFont48Pt, DTLibrary.DTColor.Black());

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(50, 158, 600, ((this.tabButtons.getItem(0).Y - 158) | 0), new DTLibrary.DTColor.ctor(235, 235, 235), true);

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(50, 158, 600, ((this.tabButtons.getItem(0).Y - 158) | 0), gray, false);
                }

                $t = Bridge.getEnumerator(this.tabButtons);
                try {
                    while ($t.moveNext()) {
                        var tabButton = $t.Current;
                        var isSelectedTab = this.sessionState.GetHackSelectionScreenMobileTab() === tabButton.Tab;

                        displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(tabButton.X, tabButton.Y, tabButton.Width, tabButton.Height, isSelectedTab ? new DTLibrary.DTColor.ctor(235, 235, 235) : (System.Nullable.hasValue(this.clickTab) && System.Nullable.getValue(this.clickTab) === tabButton.Tab ? ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(this.sessionState.GetColorTheme()) : new DTLibrary.DTColor.ctor(200, 200, 200)), true);

                        displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(tabButton.X, tabButton.Y, tabButton.Width, tabButton.Height, gray, false);

                        displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((((tabButton.X + ((Bridge.Int.div(tabButton.Width, 2)) | 0)) | 0) - ((Bridge.Int.div(tabButton.TextWidth, 2)) | 0)) | 0), ((((tabButton.Y + ((Bridge.Int.div(tabButton.Height, 2)) | 0)) | 0) + ((Bridge.Int.div(tabButton.TextHeight, 2)) | 0)) | 0), tabButton.TabName, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                        if (isSelectedTab) {
                            if (isLandscape) {
                                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(((((tabButton.X + tabButton.Width) | 0) - 2) | 0), ((tabButton.Y + 1) | 0), 5, ((tabButton.Height - 2) | 0), new DTLibrary.DTColor.ctor(235, 235, 235), true);
                            } else {
                                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(((tabButton.X + 1) | 0), ((tabButton.Y - 2) | 0), ((tabButton.Width - 2) | 0), 5, new DTLibrary.DTColor.ctor(235, 235, 235), true);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                $t1 = Bridge.getEnumerator(this.hackDisplays.get(this.sessionState.GetHackSelectionScreenMobileTab()));
                try {
                    while ($t1.moveNext()) {
                        var hackDisplayList = $t1.Current;
                        $t2 = Bridge.getEnumerator(hackDisplayList);
                        try {
                            while ($t2.moveNext()) {
                                var hackDisplay = $t2.Current;
                                hackDisplay.RenderButtonDisplay(displayOutput);
                            }
                        } finally {
                            if (Bridge.is($t2, System.IDisposable)) {
                                $t2.System$IDisposable$Dispose();
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                if (this.allowResearchingHacks) {
                    if (isLandscape) {
                        displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((((Bridge.Int.div(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth(), 2)) | 0) - 250) | 0), 122, "Hack points remaining: " + (DTLibrary.StringUtil.ToStringCultureInvariant(this.sessionState.GetUnusedHackPoints()) || "") + "\n" + "Get more hack points by winning games" + "\n" + "and completing objectives!", ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, DTLibrary.DTColor.Black());
                    } else {
                        displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(200, 122, "Hack points remaining: " + (DTLibrary.StringUtil.ToStringCultureInvariant(this.sessionState.GetUnusedHackPoints()) || "") + "\n" + "Get more hack points by winning" + "\n" + "games and completing" + "\n" + "objectives!", ChessCompStompWithHacksLibrary.GameFont.GameFont14Pt, DTLibrary.DTColor.Black());
                    }

                    this.resetHacksButton.Render(displayOutput);
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackSelectionScreenDisplayMobile.TabButton", {
        $kind: "nested class",
        fields: {
            X: 0,
            Y: 0,
            Width: 0,
            Height: 0,
            Tab: 0,
            TabName: null,
            TextWidth: 0,
            TextHeight: 0
        },
        ctors: {
            ctor: function (x, y, width, height, tab, tabName, textWidth, textHeight) {
                this.$initialize();
                this.X = x;
                this.Y = y;
                this.Width = width;
                this.Height = height;
                this.Tab = tab;
                this.TabName = tabName;
                this.TextWidth = textWidth;
                this.TextHeight = textHeight;
            }
        },
        methods: {
            SetX: function (x) {
                this.X = x;
            },
            SetY: function (y) {
                this.Y = y;
            },
            SetWidth: function (width) {
                this.Width = width;
            },
            SetHeight: function (height) {
                this.Height = height;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTab", {
        $kind: "enum",
        statics: {
            fields: {
                Tactics: 0,
                Eliteness: 1,
                RuleWarping: 2
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTabUtil", {
        statics: {
            methods: {
                GetTabIdMapping: function () {
                    var list = new (System.Collections.Generic.List$1(System.Tuple$2(ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTab,System.Int32))).ctor();

                    list.add({ Item1: ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTab.Tactics, Item2: 1 });
                    list.add({ Item1: ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTab.Eliteness, Item2: 2 });
                    list.add({ Item1: ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTab.RuleWarping, Item2: 3 });

                    return list;
                },
                /**
                 * Returns null if the tabId isn't valid
                 *
                 * @static
                 * @public
                 * @this ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTabUtil
                 * @memberof ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTabUtil
                 * @param   {number}                                                          tabId
                 * @return  {?ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTab}
                 */
                GetTabFromTabId: function (tabId) {
                    var $t;
                    var mapping = ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTabUtil.GetTabIdMapping();

                    $t = Bridge.getEnumerator(mapping);
                    try {
                        while ($t.moveNext()) {
                            var tuple = $t.Current;
                            if (tuple.Item2 === tabId) {
                                return tuple.Item1;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    return null;
                },
                /**
                 * Maps a tab to an integer identifier (in a consistent but arbitrary way)
                 *
                 * @static
                 * @public
                 * @this ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTabUtil
                 * @memberof ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTabUtil
                 * @param   {ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTab}    tab
                 * @return  {number}
                 */
                GetTabId: function (tab) {
                    var $t;
                    var mapping = ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTabUtil.GetTabIdMapping();

                    $t = Bridge.getEnumerator(mapping);
                    try {
                        while ($t.moveNext()) {
                            var tuple = $t.Current;
                            if (tuple.Item1 === tab) {
                                return tuple.Item2;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    throw new System.Exception();
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackUtil", {
        statics: {
            methods: {
                GetHackCost: function (hack) {
                    switch (hack) {
                        case ChessCompStompWithHacksEngine.Hack.ExtraPawnFirst: 
                        case ChessCompStompWithHacksEngine.Hack.ExtraPawnSecond: 
                        case ChessCompStompWithHacksEngine.Hack.StalemateIsVictory: 
                        case ChessCompStompWithHacksEngine.Hack.SuperCastling: 
                        case ChessCompStompWithHacksEngine.Hack.PawnsCanMoveThreeSpacesInitially: 
                            return 3;
                        case ChessCompStompWithHacksEngine.Hack.RooksCanMoveLikeBishops: 
                        case ChessCompStompWithHacksEngine.Hack.ExtraQueen: 
                        case ChessCompStompWithHacksEngine.Hack.RooksCanCaptureLikeCannons: 
                        case ChessCompStompWithHacksEngine.Hack.KnightsCanMakeLargeKnightsMove: 
                        case ChessCompStompWithHacksEngine.Hack.QueensCanMoveLikeKnights: 
                            return 5;
                        case ChessCompStompWithHacksEngine.Hack.SuperEnPassant: 
                        case ChessCompStompWithHacksEngine.Hack.AnyPieceCanPromote: 
                        case ChessCompStompWithHacksEngine.Hack.OpponentMustCaptureWhenPossible: 
                            return 10;
                        case ChessCompStompWithHacksEngine.Hack.PawnsDestroyCapturingPiece: 
                        case ChessCompStompWithHacksEngine.Hack.TacticalNuke: 
                            return 20;
                        default: 
                            throw new System.Exception();
                    }
                },
                GetHackIdMapping: function () {
                    var list = new (System.Collections.Generic.List$1(System.Tuple$2(ChessCompStompWithHacksEngine.Hack,System.Int32))).ctor();

                    list.add({ Item1: ChessCompStompWithHacksEngine.Hack.ExtraPawnFirst, Item2: 1 });
                    list.add({ Item1: ChessCompStompWithHacksEngine.Hack.ExtraPawnSecond, Item2: 2 });
                    list.add({ Item1: ChessCompStompWithHacksEngine.Hack.ExtraQueen, Item2: 3 });
                    list.add({ Item1: ChessCompStompWithHacksEngine.Hack.PawnsCanMoveThreeSpacesInitially, Item2: 4 });
                    list.add({ Item1: ChessCompStompWithHacksEngine.Hack.SuperEnPassant, Item2: 5 });
                    list.add({ Item1: ChessCompStompWithHacksEngine.Hack.RooksCanMoveLikeBishops, Item2: 6 });
                    list.add({ Item1: ChessCompStompWithHacksEngine.Hack.SuperCastling, Item2: 7 });
                    list.add({ Item1: ChessCompStompWithHacksEngine.Hack.RooksCanCaptureLikeCannons, Item2: 8 });
                    list.add({ Item1: ChessCompStompWithHacksEngine.Hack.KnightsCanMakeLargeKnightsMove, Item2: 9 });
                    list.add({ Item1: ChessCompStompWithHacksEngine.Hack.QueensCanMoveLikeKnights, Item2: 10 });
                    list.add({ Item1: ChessCompStompWithHacksEngine.Hack.TacticalNuke, Item2: 11 });
                    list.add({ Item1: ChessCompStompWithHacksEngine.Hack.AnyPieceCanPromote, Item2: 12 });
                    list.add({ Item1: ChessCompStompWithHacksEngine.Hack.StalemateIsVictory, Item2: 13 });
                    list.add({ Item1: ChessCompStompWithHacksEngine.Hack.OpponentMustCaptureWhenPossible, Item2: 14 });
                    list.add({ Item1: ChessCompStompWithHacksEngine.Hack.PawnsDestroyCapturingPiece, Item2: 15 });

                    return list;
                },
                /**
                 * Returns null if the hackId isn't valid
                 *
                 * @static
                 * @public
                 * @this ChessCompStompWithHacksLibrary.HackUtil
                 * @memberof ChessCompStompWithHacksLibrary.HackUtil
                 * @param   {number}                                 hackId
                 * @return  {?ChessCompStompWithHacksEngine.Hack}
                 */
                GetHackFromHackId: function (hackId) {
                    var $t;
                    var mapping = ChessCompStompWithHacksLibrary.HackUtil.GetHackIdMapping();

                    $t = Bridge.getEnumerator(mapping);
                    try {
                        while ($t.moveNext()) {
                            var tuple = $t.Current;
                            if (tuple.Item2 === hackId) {
                                return tuple.Item1;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    return null;
                },
                /**
                 * Maps a hack to an integer identifier (in a consistent but arbitrary way)
                 *
                 * @static
                 * @public
                 * @this ChessCompStompWithHacksLibrary.HackUtil
                 * @memberof ChessCompStompWithHacksLibrary.HackUtil
                 * @param   {ChessCompStompWithHacksEngine.Hack}    hack
                 * @return  {number}
                 */
                GetHackId: function (hack) {
                    var $t;
                    var mapping = ChessCompStompWithHacksLibrary.HackUtil.GetHackIdMapping();

                    $t = Bridge.getEnumerator(mapping);
                    try {
                        while ($t.moveNext()) {
                            var tuple = $t.Current;
                            if (tuple.Item1 === hack) {
                                return tuple.Item2;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    throw new System.Exception();
                },
                GetHackName: function (hack) {
                    var hackNameForHackSelectionScreen;

                    switch (hack) {
                        case ChessCompStompWithHacksEngine.Hack.ExtraPawnFirst: 
                            hackNameForHackSelectionScreen = "Extra pawn";
                            break;
                        case ChessCompStompWithHacksEngine.Hack.ExtraPawnSecond: 
                            hackNameForHackSelectionScreen = "Another\nextra pawn";
                            break;
                        case ChessCompStompWithHacksEngine.Hack.ExtraQueen: 
                            hackNameForHackSelectionScreen = "Extra queen";
                            break;
                        case ChessCompStompWithHacksEngine.Hack.PawnsCanMoveThreeSpacesInitially: 
                            hackNameForHackSelectionScreen = "Pawn boost";
                            break;
                        case ChessCompStompWithHacksEngine.Hack.SuperEnPassant: 
                            hackNameForHackSelectionScreen = "Super\nen passant";
                            break;
                        case ChessCompStompWithHacksEngine.Hack.RooksCanMoveLikeBishops: 
                            hackNameForHackSelectionScreen = "Diagonal\nrooks";
                            break;
                        case ChessCompStompWithHacksEngine.Hack.SuperCastling: 
                            hackNameForHackSelectionScreen = "Super\ncastling";
                            break;
                        case ChessCompStompWithHacksEngine.Hack.RooksCanCaptureLikeCannons: 
                            hackNameForHackSelectionScreen = "Cannoning";
                            break;
                        case ChessCompStompWithHacksEngine.Hack.KnightsCanMakeLargeKnightsMove: 
                            hackNameForHackSelectionScreen = "Upgraded\nknights";
                            break;
                        case ChessCompStompWithHacksEngine.Hack.QueensCanMoveLikeKnights: 
                            hackNameForHackSelectionScreen = "Upgraded\nqueen";
                            break;
                        case ChessCompStompWithHacksEngine.Hack.TacticalNuke: 
                            hackNameForHackSelectionScreen = "Tactical nuke";
                            break;
                        case ChessCompStompWithHacksEngine.Hack.AnyPieceCanPromote: 
                            hackNameForHackSelectionScreen = "Equitable\npromotions";
                            break;
                        case ChessCompStompWithHacksEngine.Hack.StalemateIsVictory: 
                            hackNameForHackSelectionScreen = "Anti\nstalemate";
                            break;
                        case ChessCompStompWithHacksEngine.Hack.OpponentMustCaptureWhenPossible: 
                            hackNameForHackSelectionScreen = "Mandatory\ncaptures";
                            break;
                        case ChessCompStompWithHacksEngine.Hack.PawnsDestroyCapturingPiece: 
                            hackNameForHackSelectionScreen = "Sacrificial\npawns";
                            break;
                        default: 
                            throw new System.Exception();
                    }

                    var hackNameForHackExplanationPanel;

                    switch (hack) {
                        case ChessCompStompWithHacksEngine.Hack.ExtraPawnFirst: 
                            hackNameForHackExplanationPanel = "Extra pawn";
                            break;
                        case ChessCompStompWithHacksEngine.Hack.ExtraPawnSecond: 
                            hackNameForHackExplanationPanel = "Another extra pawn";
                            break;
                        case ChessCompStompWithHacksEngine.Hack.ExtraQueen: 
                            hackNameForHackExplanationPanel = "Extra queen";
                            break;
                        case ChessCompStompWithHacksEngine.Hack.PawnsCanMoveThreeSpacesInitially: 
                            hackNameForHackExplanationPanel = "Pawn boost";
                            break;
                        case ChessCompStompWithHacksEngine.Hack.SuperEnPassant: 
                            hackNameForHackExplanationPanel = "Super en passant";
                            break;
                        case ChessCompStompWithHacksEngine.Hack.RooksCanMoveLikeBishops: 
                            hackNameForHackExplanationPanel = "Diagonal rooks";
                            break;
                        case ChessCompStompWithHacksEngine.Hack.SuperCastling: 
                            hackNameForHackExplanationPanel = "Super castling";
                            break;
                        case ChessCompStompWithHacksEngine.Hack.RooksCanCaptureLikeCannons: 
                            hackNameForHackExplanationPanel = "Cannoning";
                            break;
                        case ChessCompStompWithHacksEngine.Hack.KnightsCanMakeLargeKnightsMove: 
                            hackNameForHackExplanationPanel = "Upgraded knights";
                            break;
                        case ChessCompStompWithHacksEngine.Hack.QueensCanMoveLikeKnights: 
                            hackNameForHackExplanationPanel = "Upgraded queen";
                            break;
                        case ChessCompStompWithHacksEngine.Hack.TacticalNuke: 
                            hackNameForHackExplanationPanel = "Tactical nuke";
                            break;
                        case ChessCompStompWithHacksEngine.Hack.AnyPieceCanPromote: 
                            hackNameForHackExplanationPanel = "Equitable promotions";
                            break;
                        case ChessCompStompWithHacksEngine.Hack.StalemateIsVictory: 
                            hackNameForHackExplanationPanel = "Anti stalemate";
                            break;
                        case ChessCompStompWithHacksEngine.Hack.OpponentMustCaptureWhenPossible: 
                            hackNameForHackExplanationPanel = "Mandatory captures";
                            break;
                        case ChessCompStompWithHacksEngine.Hack.PawnsDestroyCapturingPiece: 
                            hackNameForHackExplanationPanel = "Sacrificial pawns";
                            break;
                        default: 
                            throw new System.Exception();
                    }

                    return new ChessCompStompWithHacksLibrary.HackUtil.HackNameInfo(hackNameForHackSelectionScreen, hackNameForHackExplanationPanel);
                },
                GetHackNameForHackSelectionScreen: function (hack) {
                    return ChessCompStompWithHacksLibrary.HackUtil.GetHackName(hack).HackNameForHackSelectionScreen;
                },
                GetHackNameForHackExplanationPanel: function (hack) {
                    return ChessCompStompWithHacksLibrary.HackUtil.GetHackName(hack).HackNameForHackExplanationPanel;
                },
                GetHackDescriptionForHackSelectionScreen: function (hack) {
                    switch (hack) {
                        case ChessCompStompWithHacksEngine.Hack.ExtraPawnFirst: 
                            return new ChessCompStompWithHacksLibrary.HackUtil.HackDescription("Start with an extra pawn.", 301);
                        case ChessCompStompWithHacksEngine.Hack.ExtraPawnSecond: 
                            return new ChessCompStompWithHacksLibrary.HackUtil.HackDescription("Start with another extra pawn.", 357);
                        case ChessCompStompWithHacksEngine.Hack.ExtraQueen: 
                            return new ChessCompStompWithHacksLibrary.HackUtil.HackDescription("Start with an extra queen.", 309);
                        case ChessCompStompWithHacksEngine.Hack.PawnsCanMoveThreeSpacesInitially: 
                            return new ChessCompStompWithHacksLibrary.HackUtil.HackDescription("The first time a pawn moves, the pawn may\nmove forward 3 squares.", 460);
                        case ChessCompStompWithHacksEngine.Hack.SuperEnPassant: 
                            return new ChessCompStompWithHacksLibrary.HackUtil.HackDescription("Your pawns may capture enemy pieces that are\nhorizontally adjacent to the pawn.\nSuper en passant is allowed regardless of\nwhen or how the enemy piece moved.\nThe pawn may capture super en passant\nregardless of which rank the pawn is on.", 500);
                        case ChessCompStompWithHacksEngine.Hack.RooksCanMoveLikeBishops: 
                            return new ChessCompStompWithHacksLibrary.HackUtil.HackDescription("In addition to their normal moves, your rooks\nmay also move as if they were bishops.", 489);
                        case ChessCompStompWithHacksEngine.Hack.SuperCastling: 
                            return new ChessCompStompWithHacksLibrary.HackUtil.HackDescription("You may castle as long as there are no pieces\nbetween your king and rook.\nSuper castling is allowed regardless of\nwhether the king or rook has previously moved.\nYou cannot super castle out of, through,\nor into check.\nSuper castling is allowed both horizontally\nand vertically.", 500);
                        case ChessCompStompWithHacksEngine.Hack.RooksCanCaptureLikeCannons: 
                            return new ChessCompStompWithHacksLibrary.HackUtil.HackDescription("Your rooks may capture enemy pieces even if\nthere is a piece between your rook and the\npiece being captured.", 486);
                        case ChessCompStompWithHacksEngine.Hack.KnightsCanMakeLargeKnightsMove: 
                            return new ChessCompStompWithHacksLibrary.HackUtil.HackDescription("Your knights may make large knight's moves\n(moving forward 3 squares and 1 square to\nthe side).", 472);
                        case ChessCompStompWithHacksEngine.Hack.QueensCanMoveLikeKnights: 
                            return new ChessCompStompWithHacksLibrary.HackUtil.HackDescription("Your queen may also move as\nif it were a knight.", 336);
                        case ChessCompStompWithHacksEngine.Hack.TacticalNuke: 
                            return new ChessCompStompWithHacksLibrary.HackUtil.HackDescription("You start each game with a nuke.\nThe nuke requires " + (DTLibrary.StringUtil.ToStringCultureInvariant(ChessCompStompWithHacksEngine.TacticalNukeUtil.NumberOfMovesPlayedBeforeNukeIsAvailable) || "") + " turns before" + "\n" + "it is operational.", 380);
                        case ChessCompStompWithHacksEngine.Hack.AnyPieceCanPromote: 
                            return new ChessCompStompWithHacksLibrary.HackUtil.HackDescription("Your rooks, knights, bishops, and queen may\npromote upon reaching the last rank.", 476);
                        case ChessCompStompWithHacksEngine.Hack.StalemateIsVictory: 
                            return new ChessCompStompWithHacksLibrary.HackUtil.HackDescription("If it is your turn and you have no legal\nmoves, you win the game.\nIf it is your opponent's turn and your\nopponent has no legal moves, you win\nthe game.", 428);
                        case ChessCompStompWithHacksEngine.Hack.OpponentMustCaptureWhenPossible: 
                            return new ChessCompStompWithHacksLibrary.HackUtil.HackDescription("Capturing is compulsory for your opponent\n(if your opponent can capture a piece, your\nopponent must capture a piece).", 476);
                        case ChessCompStompWithHacksEngine.Hack.PawnsDestroyCapturingPiece: 
                            return new ChessCompStompWithHacksLibrary.HackUtil.HackDescription("When any of your pawns are captured,\nthe capturing piece is also removed\nfrom the board.", 428);
                        default: 
                            throw new System.Exception();
                    }
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackUtil.HackDescription", {
        $kind: "nested class",
        fields: {
            Description: null,
            Width: 0
        },
        ctors: {
            ctor: function (description, width) {
                this.$initialize();
                this.Description = description;
                this.Width = width;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackUtil.HackNameInfo", {
        $kind: "nested class",
        fields: {
            HackNameForHackSelectionScreen: null,
            HackNameForHackExplanationPanel: null
        },
        ctors: {
            ctor: function (hackNameForHackSelectionScreen, hackNameForHackExplanationPanel) {
                this.$initialize();
                this.HackNameForHackSelectionScreen = hackNameForHackSelectionScreen;
                this.HackNameForHackExplanationPanel = hackNameForHackExplanationPanel;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.MoveTracker", {
        statics: {
            fields: {
                MaxNumberOfMovesTracked: 0
            },
            ctors: {
                init: function () {
                    this.MaxNumberOfMovesTracked = 50;
                }
            }
        },
        fields: {
            moves: null,
            colorTheme: 0
        },
        ctors: {
            ctor: function (colorTheme) {
                this.$initialize();
                this.moves = new (System.Collections.Generic.List$1(ChessCompStompWithHacksLibrary.MoveTracker.MoveInfo)).ctor();
                this.colorTheme = colorTheme;
            }
        },
        methods: {
            AddMove: function (originalGameState, move, timer) {
                var newGameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(originalGameState, move);

                var newTracker = new ChessCompStompWithHacksLibrary.MoveTracker(this.colorTheme);

                newTracker.moves = new (System.Collections.Generic.List$1(ChessCompStompWithHacksLibrary.MoveTracker.MoveInfo)).$ctor1(this.moves);

                var newGameStateChessPiecesRenderer = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetChessPiecesRenderer(newGameState.Board, ChessCompStompWithHacksLibrary.ChessPiecesRendererUtil.GetKingInDangerSquare(newGameState), ChessCompStompWithHacksLibrary.ChessPiecesRendererUtil.GetPreviousMoveSquares$1(originalGameState, move), newGameState.IsPlayerWhite, this.colorTheme);

                var newGameStateNukeRenderer = ChessCompStompWithHacksLibrary.NukeRenderer.GetNukeRenderer(newGameState.Abilities.HasTacticalNuke, newGameState.HasUsedNuke, false, null, newGameState.TurnCount, timer, this.colorTheme, false);

                newTracker.moves.add(new ChessCompStompWithHacksLibrary.MoveTracker.MoveInfo(originalGameState, newGameState, newGameStateChessPiecesRenderer, newGameStateNukeRenderer, move));

                if (newTracker.moves.Count > ChessCompStompWithHacksLibrary.MoveTracker.MaxNumberOfMovesTracked) {
                    newTracker.moves.removeAt(0);
                }

                return newTracker;
            },
            GetMostRecentMove: function () {
                if (this.moves.Count === 0) {
                    return null;
                }
                return this.moves.getItem(((this.moves.Count - 1) | 0));
            },
            GetRecentMoves: function () {
                return new (System.Collections.Generic.List$1(ChessCompStompWithHacksLibrary.MoveTracker.MoveInfo)).$ctor1(this.moves);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.MoveTracker.MoveInfo", {
        $kind: "nested class",
        fields: {
            OriginalGameState: null,
            NewGameState: null,
            NewStateChessPiecesRenderer: null,
            NewStateNukeRenderer: null,
            Move: null,
            MoveName: null
        },
        ctors: {
            ctor: function (originalGameState, newGameState, newGameStateChessPiecesRenderer, newGameStateNukeRenderer, move) {
                this.$initialize();
                this.OriginalGameState = originalGameState;
                this.NewGameState = newGameState;
                this.NewStateChessPiecesRenderer = newGameStateChessPiecesRenderer;
                this.NewStateNukeRenderer = newGameStateNukeRenderer;
                this.Move = move;
                this.MoveName = ChessCompStompWithHacksEngine.MoveNaming.GetNameOfMove(move, originalGameState);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.MoveTrackerRenderer", {
        statics: {
            fields: {
                HOVER_HIGHLIGHT_DURATION_MICROS: 0
            },
            ctors: {
                init: function () {
                    this.HOVER_HIGHLIGHT_DURATION_MICROS = 1000000;
                }
            },
            methods: {
                GetMoveTrackerRenderer: function (moveTracker, colorTheme) {
                    return new ChessCompStompWithHacksLibrary.MoveTrackerRenderer(moveTracker, new (System.Collections.Generic.List$1(ChessCompStompWithHacksLibrary.MoveTrackerRenderer.HoverInfo)).ctor(), colorTheme);
                },
                /**
                 * Returns the positionIndex of the move the mouse is hovering over.
                 Returns null if the mouse isn't hovering over the MoveTrackerRenderer.
                 *
                 * @static
                 * @public
                 * @this ChessCompStompWithHacksLibrary.MoveTrackerRenderer
                 * @memberof ChessCompStompWithHacksLibrary.MoveTrackerRenderer
                 * @param   {DTLibrary.IMouse}    mouseInput             
                 * @param   {boolean}             isMobileDisplayType
                 * @return  {?number}
                 */
                GetHoverOverMove: function (mouseInput, isMobileDisplayType) {
                    var $t;
                    if (isMobileDisplayType && !mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                        return null;
                    }

                    var moveDisplays = ChessCompStompWithHacksLibrary.MoveTrackerRenderer.GetMoveDisplays(isMobileDisplayType);

                    var mouseX = mouseInput.DTLibrary$IMouse$GetX();
                    var mouseY = mouseInput.DTLibrary$IMouse$GetY();

                    var width = isMobileDisplayType ? ChessCompStompWithHacksLibrary.MoveTrackerRenderer.MoveDisplay.MOBILE_WIDTH : ChessCompStompWithHacksLibrary.MoveTrackerRenderer.MoveDisplay.DESKTOP_WIDTH;

                    $t = Bridge.getEnumerator(moveDisplays);
                    try {
                        while ($t.moveNext()) {
                            var moveDisplay = $t.Current;
                            if (moveDisplay.X <= mouseX && mouseX <= ((moveDisplay.X + width) | 0) && moveDisplay.Y <= mouseY && mouseY <= ((moveDisplay.Y + ChessCompStompWithHacksLibrary.MoveTrackerRenderer.MoveDisplay.HEIGHT) | 0)) {
                                return moveDisplay.PositionIndex;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    return null;
                },
                GetMoveInfoForHover: function (positionIndex, moveTracker, isMobileDisplayType) {
                    var $t;
                    var moveDisplayMapping = ChessCompStompWithHacksLibrary.MoveTrackerRenderer.GetMoveDisplayMapping(moveTracker, isMobileDisplayType);

                    $t = Bridge.getEnumerator(moveDisplayMapping);
                    try {
                        while ($t.moveNext()) {
                            var x = $t.Current;
                            var moveDisplay = x.Item1;
                            var moveInfo = x.Item2;

                            if (moveDisplay.PositionIndex === positionIndex) {
                                return moveInfo;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    return null;
                },
                GetMoveDisplays: function (isMobileDisplayType) {
                    var list = new (System.Collections.Generic.List$1(ChessCompStompWithHacksLibrary.MoveTrackerRenderer.MoveDisplay)).ctor();

                    if (isMobileDisplayType) {
                        for (var i = 0; i < 5; i = (i + 1) | 0) {
                            list.add(new ChessCompStompWithHacksLibrary.MoveTrackerRenderer.MoveDisplay(i, 0, Bridge.Int.mul((((4 - i) | 0)), ChessCompStompWithHacksLibrary.MoveTrackerRenderer.MoveDisplay.HEIGHT)));
                        }
                    } else {
                        var isWhite = true;
                        var y = 306;

                        for (var i1 = 0; i1 < 20; i1 = (i1 + 1) | 0) {
                            if (isWhite) {
                                list.add(new ChessCompStompWithHacksLibrary.MoveTrackerRenderer.MoveDisplay(i1, 0, y));
                            } else {
                                list.add(new ChessCompStompWithHacksLibrary.MoveTrackerRenderer.MoveDisplay(i1, 124, y));
                                y = (y - (34)) | 0;
                            }

                            isWhite = !isWhite;
                        }
                    }

                    return list;
                },
                GetMoveDisplayMapping: function (moveTracker, isMobileDisplayType) {
                    var moveInfos = moveTracker.GetRecentMoves();

                    if (moveInfos.Count === 0) {
                        return new (System.Collections.Generic.List$1(System.Tuple$2(ChessCompStompWithHacksLibrary.MoveTrackerRenderer.MoveDisplay,ChessCompStompWithHacksLibrary.MoveTracker.MoveInfo))).ctor();
                    }

                    var index;

                    if (isMobileDisplayType) {
                        index = moveInfos.Count;
                        index = (index - 5) | 0;
                        if (index < 0) {
                            index = 0;
                        }
                    } else {
                        index = moveInfos.Count;
                        index = (index - 20) | 0;
                        if (index < 0) {
                            index = 0;
                        }

                        if (!moveInfos.getItem(index).OriginalGameState.IsWhiteTurn) {
                            index = (index + 1) | 0;
                            if (index === moveInfos.Count) {
                                return new (System.Collections.Generic.List$1(System.Tuple$2(ChessCompStompWithHacksLibrary.MoveTrackerRenderer.MoveDisplay,ChessCompStompWithHacksLibrary.MoveTracker.MoveInfo))).ctor();
                            }
                        }
                    }

                    var moveDisplays = ChessCompStompWithHacksLibrary.MoveTrackerRenderer.GetMoveDisplays(isMobileDisplayType);
                    var moveDisplayIndex = 0;

                    var returnValue = new (System.Collections.Generic.List$1(System.Tuple$2(ChessCompStompWithHacksLibrary.MoveTrackerRenderer.MoveDisplay,ChessCompStompWithHacksLibrary.MoveTracker.MoveInfo))).ctor();

                    while (true) {
                        if (index === moveInfos.Count) {
                            if (!isMobileDisplayType && moveInfos.getItem(((moveInfos.Count - 1) | 0)).OriginalGameState.IsWhiteTurn) {
                                returnValue.add({ Item1: moveDisplays.getItem(moveDisplayIndex), Item2: null });
                            }
                            return returnValue;
                        }

                        var moveDisplay = moveDisplays.getItem(moveDisplayIndex);

                        returnValue.add({ Item1: moveDisplay, Item2: moveInfos.getItem(index) });

                        moveDisplayIndex = (moveDisplayIndex + 1) | 0;
                        index = (index + 1) | 0;
                    }
                }
            }
        },
        fields: {
            moveTracker: null,
            hoverInfos: null,
            colorTheme: 0
        },
        ctors: {
            ctor: function (moveTracker, hoverInfos, colorTheme) {
                this.$initialize();
                this.moveTracker = moveTracker;
                this.hoverInfos = new (System.Collections.Generic.List$1(ChessCompStompWithHacksLibrary.MoveTrackerRenderer.HoverInfo)).$ctor1(hoverInfos);

                this.colorTheme = colorTheme;
            }
        },
        methods: {
            ProcessFrame: function (moveTracker, hoverPositionIndex, elapsedMicrosPerFrame) {
                var $t;
                var newHoverInfos = new (System.Collections.Generic.List$1(ChessCompStompWithHacksLibrary.MoveTrackerRenderer.HoverInfo)).ctor();

                $t = Bridge.getEnumerator(this.hoverInfos);
                try {
                    while ($t.moveNext()) {
                        var hoverInfo = $t.Current;
                        var positionIndex = hoverInfo.PositionIndex;
                        var elapsedMicros = (hoverInfo.ElapsedMicros + elapsedMicrosPerFrame) | 0;

                        if (elapsedMicros <= ChessCompStompWithHacksLibrary.MoveTrackerRenderer.HOVER_HIGHLIGHT_DURATION_MICROS && (hoverPositionIndex == null || System.Nullable.getValue(hoverPositionIndex) !== positionIndex)) {
                            newHoverInfos.add(new ChessCompStompWithHacksLibrary.MoveTrackerRenderer.HoverInfo(positionIndex, elapsedMicros));
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                if (hoverPositionIndex != null) {
                    newHoverInfos.add(new ChessCompStompWithHacksLibrary.MoveTrackerRenderer.HoverInfo(System.Nullable.getValue(hoverPositionIndex), 0));
                }

                return new ChessCompStompWithHacksLibrary.MoveTrackerRenderer(moveTracker, newHoverInfos, this.colorTheme);
            },
            Render: function (displayOutput, isMobileDisplayType) {
                var $t, $t1;
                var moveDisplayMapping = ChessCompStompWithHacksLibrary.MoveTrackerRenderer.GetMoveDisplayMapping(this.moveTracker, isMobileDisplayType);

                var hoverInfoMapping = new (System.Collections.Generic.Dictionary$2(System.Int32,System.Int32))();
                $t = Bridge.getEnumerator(this.hoverInfos);
                try {
                    while ($t.moveNext()) {
                        var hoverInfo = $t.Current;
                        hoverInfoMapping.set(hoverInfo.PositionIndex, hoverInfo.ElapsedMicros);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                var width = isMobileDisplayType ? ChessCompStompWithHacksLibrary.MoveTrackerRenderer.MoveDisplay.MOBILE_WIDTH : ChessCompStompWithHacksLibrary.MoveTrackerRenderer.MoveDisplay.DESKTOP_WIDTH;

                $t1 = Bridge.getEnumerator(moveDisplayMapping);
                try {
                    while ($t1.moveNext()) {
                        var entry = $t1.Current;
                        var moveDisplay = entry.Item1;
                        var moveInfo = entry.Item2;
                        displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(moveDisplay.X, moveDisplay.Y, width, ChessCompStompWithHacksLibrary.MoveTrackerRenderer.MoveDisplay.HEIGHT, ChessCompStompWithHacksLibrary.ColorThemeUtil.GetTextBackgroundColor(this.colorTheme), true);
                        displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(moveDisplay.X, moveDisplay.Y, width, ChessCompStompWithHacksLibrary.MoveTrackerRenderer.MoveDisplay.HEIGHT, DTLibrary.DTColor.Black(), false);

                        if (hoverInfoMapping.containsKey(moveDisplay.PositionIndex)) {
                            var elapsedMicros = hoverInfoMapping.get(moveDisplay.PositionIndex);
                            var alpha = (Bridge.Int.div(Bridge.Int.mul((((ChessCompStompWithHacksLibrary.MoveTrackerRenderer.HOVER_HIGHLIGHT_DURATION_MICROS - elapsedMicros) | 0)), 150), ChessCompStompWithHacksLibrary.MoveTrackerRenderer.HOVER_HIGHLIGHT_DURATION_MICROS)) | 0;
                            if (alpha > 255) {
                                alpha = 255;
                            }
                            if (alpha < 0) {
                                alpha = 0;
                            }
                            var fadeColor = new DTLibrary.DTColor.$ctor1(255, 255, 255, alpha);

                            displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(moveDisplay.X, moveDisplay.Y, width, ChessCompStompWithHacksLibrary.MoveTrackerRenderer.MoveDisplay.HEIGHT, fadeColor, true);
                        }

                        if (moveInfo != null) {
                            displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((moveDisplay.X + 2) | 0), ((moveDisplay.Y + 28) | 0), moveInfo.MoveName, ChessCompStompWithHacksLibrary.GameFont.GameFont14Pt, DTLibrary.DTColor.Black());
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.MoveTrackerRenderer.HoverInfo", {
        $kind: "nested class",
        fields: {
            PositionIndex: 0,
            ElapsedMicros: 0
        },
        ctors: {
            ctor: function (positionIndex, elapsedMicros) {
                this.$initialize();
                this.PositionIndex = positionIndex;
                this.ElapsedMicros = elapsedMicros;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.MoveTrackerRenderer.MoveDisplay", {
        $kind: "nested class",
        statics: {
            fields: {
                DESKTOP_WIDTH: 0,
                MOBILE_WIDTH: 0,
                HEIGHT: 0
            },
            ctors: {
                init: function () {
                    this.DESKTOP_WIDTH = 125;
                    this.MOBILE_WIDTH = 140;
                    this.HEIGHT = 35;
                }
            }
        },
        fields: {
            /**
             * Desktop:
             	0 means the first row, first col
             	1 means the first rol, second col
             	2 means the second row, first col
             	3 means the second row, second col
             	etc
             Mobile:
             	0 means first row
             	1 means second row
             	etc
             *
             * @instance
             * @public
             * @memberof ChessCompStompWithHacksLibrary.MoveTrackerRenderer.MoveDisplay
             * @function PositionIndex
             * @type number
             */
            PositionIndex: 0,
            X: 0,
            Y: 0
        },
        ctors: {
            ctor: function (positionIndex, x, y) {
                this.$initialize();
                this.PositionIndex = positionIndex;
                this.X = x;
                this.Y = y;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.MusicPlayer", {
        fields: {
            /**
             * The current music being played, or null if no music is playing.
             This may not be the same as intendedMusic since it takes a while
             to fade out an existing music and fade in a new one
             *
             * @instance
             * @private
             * @memberof ChessCompStompWithHacksLibrary.MusicPlayer
             * @type ?ChessCompStompWithHacksLibrary.GameMusic
             */
            currentMusic: null,
            /**
             * The intended music that should eventually play, or null if we should fade out all music
             *
             * @instance
             * @private
             * @memberof ChessCompStompWithHacksLibrary.MusicPlayer
             * @type ?ChessCompStompWithHacksLibrary.GameMusic
             */
            intendedMusic: null,
            /**
             * From 0 to 100 * 1024 (both inclusive)
             Normally, this value is 100 * 1024.
             However, when fading in/out, this value will decrease to represent the drop in music volume.
             *
             * @instance
             * @private
             * @memberof ChessCompStompWithHacksLibrary.MusicPlayer
             * @type number
             */
            currentFadeInAndOutVolumeMillis: 0,
            /**
             * From 0 to 100.
             For this.currentMusic, the intended volume at which the music should be played.
             We allow this to be set since we might want to play a particular music at a different
             volume depending on circumstances (e.g. maybe the music should be played softer when
             the game is paused)
             *
             * @instance
             * @private
             * @memberof ChessCompStompWithHacksLibrary.MusicPlayer
             * @type number
             */
            currentMusicVolume: 0,
            /**
             * From 0 to 100.
             For this.intendedMusic, the intended volume at which the music should be played.
             *
             * @instance
             * @private
             * @memberof ChessCompStompWithHacksLibrary.MusicPlayer
             * @type number
             */
            intendedMusicVolume: 0,
            elapsedMicrosPerFrame: 0
        },
        ctors: {
            ctor: function (elapsedMicrosPerFrame) {
                this.$initialize();
                this.currentMusic = null;
                this.intendedMusic = null;
                this.currentFadeInAndOutVolumeMillis = 0;
                this.currentMusicVolume = 0;
                this.intendedMusicVolume = 0;

                this.elapsedMicrosPerFrame = elapsedMicrosPerFrame;
            }
        },
        methods: {
            DecreaseCurrentFadeInAndOutVolumeMillis: function () {
                this.currentFadeInAndOutVolumeMillis = (this.currentFadeInAndOutVolumeMillis - ((Bridge.Int.div(this.elapsedMicrosPerFrame, 2)) | 0)) | 0;
                if (this.currentFadeInAndOutVolumeMillis < 0) {
                    this.currentFadeInAndOutVolumeMillis = 0;
                }
            },
            IncreaseCurrentFadeInAndOutVolumeMillis: function () {
                this.currentFadeInAndOutVolumeMillis = (this.currentFadeInAndOutVolumeMillis + ((Bridge.Int.div(this.elapsedMicrosPerFrame, 2)) | 0)) | 0;
                if (this.currentFadeInAndOutVolumeMillis > 102400) {
                    this.currentFadeInAndOutVolumeMillis = 102400;
                }
            },
            ProcessFrame: function () {
                if (this.intendedMusic == null) {
                    if (this.currentMusic != null) {
                        this.DecreaseCurrentFadeInAndOutVolumeMillis();
                        if (this.currentFadeInAndOutVolumeMillis === 0) {
                            this.currentMusic = null;
                        }
                    }

                    return;
                }

                if (this.currentMusic == null) {
                    this.currentMusic = this.intendedMusic;
                    this.currentFadeInAndOutVolumeMillis = 0;
                    this.currentMusicVolume = this.intendedMusicVolume;
                    return;
                }

                if (System.Nullable.getValue(this.currentMusic) !== System.Nullable.getValue(this.intendedMusic)) {
                    this.DecreaseCurrentFadeInAndOutVolumeMillis();
                    if (this.currentFadeInAndOutVolumeMillis === 0) {
                        this.currentMusic = null;
                    }
                    return;
                }

                if (this.currentMusicVolume < this.intendedMusicVolume) {
                    var delta = (Bridge.Int.div(this.elapsedMicrosPerFrame, 5000)) | 0;
                    if (delta === 0) {
                        delta = 1;
                    }
                    this.currentMusicVolume = (this.currentMusicVolume + delta) | 0;
                    if (this.currentMusicVolume > this.intendedMusicVolume) {
                        this.currentMusicVolume = this.intendedMusicVolume;
                    }
                }

                if (this.currentMusicVolume > this.intendedMusicVolume) {
                    var delta1 = (Bridge.Int.div(this.elapsedMicrosPerFrame, 5000)) | 0;
                    if (delta1 === 0) {
                        delta1 = 1;
                    }
                    this.currentMusicVolume = (this.currentMusicVolume - delta1) | 0;
                    if (this.currentMusicVolume < this.intendedMusicVolume) {
                        this.currentMusicVolume = this.intendedMusicVolume;
                    }
                }

                this.IncreaseCurrentFadeInAndOutVolumeMillis();
            },
            SetMusic: function (music, volume) {
                this.intendedMusic = music;
                this.intendedMusicVolume = volume;
            },
            StopMusic: function () {
                this.intendedMusic = null;
            },
            RenderMusic: function (musicOutput, userVolume) {
                if (this.currentMusic != null) {
                    musicOutput.DTLibrary$IMusicOutput$1$ChessCompStompWithHacksLibrary$GameMusic$PlayMusic(System.Nullable.getValue(this.currentMusic), ((Bridge.Int.div(Bridge.Int.mul(((((Bridge.Int.div(Bridge.Int.mul(this.currentFadeInAndOutVolumeMillis, this.currentMusicVolume), 100)) | 0)) >> 10), userVolume), 100)) | 0));
                } else {
                    musicOutput.DTLibrary$IMusicOutput$1$ChessCompStompWithHacksLibrary$GameMusic$StopMusic();
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.MusicVolumePicker", {
        fields: {
            _xPos: 0,
            _yPos: 0,
            _currentVolume: 0,
            _unmuteVolume: 0,
            _isDraggingVolumeSlider: false,
            _scalingFactor: 0
        },
        ctors: {
            ctor: function (xPos, yPos, initialVolume, scalingFactor) {
                this.$initialize();
                this._xPos = xPos;
                this._yPos = yPos;

                this._currentVolume = initialVolume;
                this._unmuteVolume = this._currentVolume;

                this._isDraggingVolumeSlider = false;

                this._scalingFactor = scalingFactor;
            }
        },
        methods: {
            ProcessFrame: function (mouseInput, previousMouseInput) {
                var mouseX = mouseInput.DTLibrary$IMouse$GetX();
                var mouseY = mouseInput.DTLibrary$IMouse$GetY();

                if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && this._xPos <= mouseX && mouseX <= ((this._xPos + Bridge.Int.mul(40, this._scalingFactor)) | 0) && this._yPos <= mouseY && mouseY <= ((this._yPos + Bridge.Int.mul(50, this._scalingFactor)) | 0)) {
                    if (this._currentVolume === 0) {
                        this._currentVolume = this._unmuteVolume === 0 ? ChessCompStompWithHacksLibrary.GlobalState.DEFAULT_VOLUME : this._unmuteVolume;
                        this._unmuteVolume = this._currentVolume;
                    } else {
                        this._unmuteVolume = this._currentVolume;
                        this._currentVolume = 0;
                    }
                }

                if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && ((this._xPos + Bridge.Int.mul(50, this._scalingFactor)) | 0) <= mouseX && mouseX <= ((this._xPos + Bridge.Int.mul(150, this._scalingFactor)) | 0) && ((this._yPos + Bridge.Int.mul(10, this._scalingFactor)) | 0) <= mouseY && mouseY <= ((this._yPos + Bridge.Int.mul(40, this._scalingFactor)) | 0)) {
                    this._isDraggingVolumeSlider = true;
                }

                if (this._isDraggingVolumeSlider && mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                    var volume = (Bridge.Int.div((((mouseX - (((this._xPos + Bridge.Int.mul(50, this._scalingFactor)) | 0))) | 0)), this._scalingFactor)) | 0;
                    if (volume < 0) {
                        volume = 0;
                    }
                    if (volume > 100) {
                        volume = 100;
                    }

                    this._currentVolume = volume;
                    this._unmuteVolume = this._currentVolume;
                }

                if (!mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                    this._isDraggingVolumeSlider = false;
                }
            },
            SetX: function (x) {
                this._xPos = x;
            },
            SetY: function (y) {
                this._yPos = y;
            },
            /**
             * Returns a number from 0 to 100 (both inclusive)
             *
             * @instance
             * @public
             * @this ChessCompStompWithHacksLibrary.MusicVolumePicker
             * @memberof ChessCompStompWithHacksLibrary.MusicVolumePicker
             * @return  {number}
             */
            GetCurrentMusicVolume: function () {
                return this._currentVolume;
            },
            Render: function (displayOutput) {
                if (this._currentVolume > 0) {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawImageRotatedClockwise$1(ChessCompStompWithHacksLibrary.GameImage.MusicOn, this._xPos, this._yPos, 0, ((Bridge.Int.div(Bridge.Int.mul(128, this._scalingFactor), 2)) | 0));
                } else {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawImageRotatedClockwise$1(ChessCompStompWithHacksLibrary.GameImage.MusicOff, this._xPos, this._yPos, 0, ((Bridge.Int.div(Bridge.Int.mul(128, this._scalingFactor), 2)) | 0));
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(((this._xPos + Bridge.Int.mul(50, this._scalingFactor)) | 0), ((this._yPos + Bridge.Int.mul(10, this._scalingFactor)) | 0), Bridge.Int.mul(100, this._scalingFactor), ((Bridge.Int.mul(30, this._scalingFactor) + 1) | 0), DTLibrary.DTColor.Black(), false);

                if (this._currentVolume > 0) {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(((this._xPos + Bridge.Int.mul(50, this._scalingFactor)) | 0), ((this._yPos + Bridge.Int.mul(10, this._scalingFactor)) | 0), Bridge.Int.mul(this._currentVolume, this._scalingFactor), ((Bridge.Int.mul(30, this._scalingFactor) + 1) | 0), DTLibrary.DTColor.Black(), true);
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.NewGameCreation", {
        statics: {
            methods: {
                CreateNewGame: function (isPlayerWhite, researchedHacks, aiHackLevel) {
                    var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23, $t24, $t25, $t26, $t27, $t28, $t29, $t30, $t31, $t32, $t33, $t34, $t35, $t36, $t37, $t38, $t39, $t40, $t41, $t42, $t43, $t44, $t45, $t46, $t47, $t48, $t49, $t50, $t51, $t52, $t53, $t54, $t55, $t56, $t57, $t58, $t59, $t60, $t61, $t62, $t63, $t64, $t65, $t66, $t67, $t68, $t69, $t70, $t71, $t72, $t73, $t74, $t75, $t76, $t77, $t78, $t79, $t80, $t81;
                    var hacks = new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.Hack)).ctor();
                    for (var i = 0; i < researchedHacks.Count; i = (i + 1) | 0) {
                        hacks.add(researchedHacks.getItem(i));
                    }

                    var board = System.Array.init(8, null, System.Array.type(ChessCompStompWithHacksEngine.ChessSquarePiece));
                    for (var i1 = 0; i1 < 8; i1 = (i1 + 1) | 0) {
                        board[System.Array.index(i1, board)] = System.Array.init(8, 0, ChessCompStompWithHacksEngine.ChessSquarePiece);
                        for (var j = 0; j < 8; j = (j + 1) | 0) {
                            ($t = board[System.Array.index(i1, board)])[System.Array.index(j, $t)] = ChessCompStompWithHacksEngine.ChessSquarePiece.Empty;
                        }
                    }

                    for (var i2 = 0; i2 < 8; i2 = (i2 + 1) | 0) {
                        ($t1 = board[System.Array.index(i2, board)])[System.Array.index(1, $t1)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn;
                        ($t2 = board[System.Array.index(i2, board)])[System.Array.index(6, $t2)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackPawn;
                    }

                    ($t3 = board[System.Array.index(0, board)])[System.Array.index(0, $t3)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook;
                    ($t4 = board[System.Array.index(1, board)])[System.Array.index(0, $t4)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKnight;
                    ($t5 = board[System.Array.index(2, board)])[System.Array.index(0, $t5)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteBishop;
                    ($t6 = board[System.Array.index(3, board)])[System.Array.index(0, $t6)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteQueen;
                    ($t7 = board[System.Array.index(4, board)])[System.Array.index(0, $t7)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKing;
                    ($t8 = board[System.Array.index(5, board)])[System.Array.index(0, $t8)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteBishop;
                    ($t9 = board[System.Array.index(6, board)])[System.Array.index(0, $t9)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKnight;
                    ($t10 = board[System.Array.index(7, board)])[System.Array.index(0, $t10)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook;

                    ($t11 = board[System.Array.index(0, board)])[System.Array.index(7, $t11)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackRook;
                    ($t12 = board[System.Array.index(1, board)])[System.Array.index(7, $t12)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKnight;
                    ($t13 = board[System.Array.index(2, board)])[System.Array.index(7, $t13)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackBishop;
                    ($t14 = board[System.Array.index(3, board)])[System.Array.index(7, $t14)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackQueen;
                    ($t15 = board[System.Array.index(4, board)])[System.Array.index(7, $t15)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKing;
                    ($t16 = board[System.Array.index(5, board)])[System.Array.index(7, $t16)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackBishop;
                    ($t17 = board[System.Array.index(6, board)])[System.Array.index(7, $t17)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKnight;
                    ($t18 = board[System.Array.index(7, board)])[System.Array.index(7, $t18)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackRook;

                    if (hacks.contains(ChessCompStompWithHacksEngine.Hack.ExtraQueen)) {
                        if (isPlayerWhite) {
                            ($t19 = board[System.Array.index(3, board)])[System.Array.index(1, $t19)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteQueen;
                            ($t20 = board[System.Array.index(3, board)])[System.Array.index(2, $t20)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn;
                        } else {
                            ($t21 = board[System.Array.index(3, board)])[System.Array.index(6, $t21)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackQueen;
                            ($t22 = board[System.Array.index(3, board)])[System.Array.index(5, $t22)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackPawn;
                        }
                    }

                    var numberOfExtraPawns = 0;
                    if (hacks.contains(ChessCompStompWithHacksEngine.Hack.ExtraPawnFirst)) {
                        numberOfExtraPawns = (numberOfExtraPawns + 1) | 0;
                    }
                    if (hacks.contains(ChessCompStompWithHacksEngine.Hack.ExtraPawnSecond)) {
                        numberOfExtraPawns = (numberOfExtraPawns + 1) | 0;
                    }

                    while (numberOfExtraPawns > 0) {
                        if (isPlayerWhite) {
                            if (($t23 = board[System.Array.index(3, board)])[System.Array.index(2, $t23)] === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                                ($t24 = board[System.Array.index(3, board)])[System.Array.index(2, $t24)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn;
                            } else {
                                if (($t25 = board[System.Array.index(4, board)])[System.Array.index(2, $t25)] === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                                    ($t26 = board[System.Array.index(4, board)])[System.Array.index(2, $t26)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn;
                                } else {
                                    if (($t27 = board[System.Array.index(2, board)])[System.Array.index(2, $t27)] === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                                        ($t28 = board[System.Array.index(2, board)])[System.Array.index(2, $t28)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn;
                                    } else {
                                        throw new System.Exception();
                                    }
                                }
                            }
                        } else {
                            if (($t29 = board[System.Array.index(3, board)])[System.Array.index(5, $t29)] === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                                ($t30 = board[System.Array.index(3, board)])[System.Array.index(5, $t30)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackPawn;
                            } else {
                                if (($t31 = board[System.Array.index(4, board)])[System.Array.index(5, $t31)] === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                                    ($t32 = board[System.Array.index(4, board)])[System.Array.index(5, $t32)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackPawn;
                                } else {
                                    if (($t33 = board[System.Array.index(2, board)])[System.Array.index(5, $t33)] === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                                        ($t34 = board[System.Array.index(2, board)])[System.Array.index(5, $t34)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackPawn;
                                    } else {
                                        throw new System.Exception();
                                    }
                                }
                            }
                        }

                        numberOfExtraPawns = (numberOfExtraPawns - 1) | 0;
                    }

                    switch (aiHackLevel) {
                        case ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.Initial: 
                            break;
                        case ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.UpgradedOnce: 
                            if (isPlayerWhite) {
                                for (var i3 = 0; i3 < 8; i3 = (i3 + 1) | 0) {
                                    ($t35 = board[System.Array.index(i3, board)])[System.Array.index(5, $t35)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackPawn;
                                }
                            } else {
                                for (var i4 = 0; i4 < 8; i4 = (i4 + 1) | 0) {
                                    ($t36 = board[System.Array.index(i4, board)])[System.Array.index(2, $t36)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn;
                                }
                            }
                            break;
                        case ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.UpgradedTwice: 
                            if (isPlayerWhite) {
                                for (var i5 = 0; i5 < 8; i5 = (i5 + 1) | 0) {
                                    ($t37 = board[System.Array.index(i5, board)])[System.Array.index(5, $t37)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackPawn;
                                }

                                ($t38 = board[System.Array.index(0, board)])[System.Array.index(6, $t38)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackRook;
                                ($t39 = board[System.Array.index(1, board)])[System.Array.index(6, $t39)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKnight;
                                ($t40 = board[System.Array.index(2, board)])[System.Array.index(6, $t40)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackBishop;
                                ($t41 = board[System.Array.index(3, board)])[System.Array.index(6, $t41)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackQueen;
                                ($t42 = board[System.Array.index(4, board)])[System.Array.index(6, $t42)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackQueen;
                                ($t43 = board[System.Array.index(5, board)])[System.Array.index(6, $t43)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackBishop;
                                ($t44 = board[System.Array.index(6, board)])[System.Array.index(6, $t44)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKnight;
                                ($t45 = board[System.Array.index(7, board)])[System.Array.index(6, $t45)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackRook;
                            } else {
                                for (var i6 = 0; i6 < 8; i6 = (i6 + 1) | 0) {
                                    ($t46 = board[System.Array.index(i6, board)])[System.Array.index(2, $t46)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn;
                                }

                                ($t47 = board[System.Array.index(0, board)])[System.Array.index(1, $t47)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook;
                                ($t48 = board[System.Array.index(1, board)])[System.Array.index(1, $t48)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKnight;
                                ($t49 = board[System.Array.index(2, board)])[System.Array.index(1, $t49)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteBishop;
                                ($t50 = board[System.Array.index(3, board)])[System.Array.index(1, $t50)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteQueen;
                                ($t51 = board[System.Array.index(4, board)])[System.Array.index(1, $t51)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteQueen;
                                ($t52 = board[System.Array.index(5, board)])[System.Array.index(1, $t52)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteBishop;
                                ($t53 = board[System.Array.index(6, board)])[System.Array.index(1, $t53)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKnight;
                                ($t54 = board[System.Array.index(7, board)])[System.Array.index(1, $t54)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook;
                            }
                            break;
                        case ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.UpgradedThrice: 
                            if (isPlayerWhite) {
                                for (var i7 = 0; i7 < 8; i7 = (i7 + 1) | 0) {
                                    ($t55 = board[System.Array.index(i7, board)])[System.Array.index(4, $t55)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackPawn;
                                }

                                for (var j1 = 5; j1 <= 6; j1 = (j1 + 1) | 0) {
                                    ($t56 = board[System.Array.index(0, board)])[System.Array.index(j1, $t56)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackRook;
                                    ($t57 = board[System.Array.index(1, board)])[System.Array.index(j1, $t57)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKnight;
                                    ($t58 = board[System.Array.index(2, board)])[System.Array.index(j1, $t58)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackBishop;
                                    ($t59 = board[System.Array.index(3, board)])[System.Array.index(j1, $t59)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackQueen;
                                    ($t60 = board[System.Array.index(4, board)])[System.Array.index(j1, $t60)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackQueen;
                                    ($t61 = board[System.Array.index(5, board)])[System.Array.index(j1, $t61)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackBishop;
                                    ($t62 = board[System.Array.index(6, board)])[System.Array.index(j1, $t62)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKnight;
                                    ($t63 = board[System.Array.index(7, board)])[System.Array.index(j1, $t63)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackRook;
                                }
                            } else {
                                for (var i8 = 0; i8 < 8; i8 = (i8 + 1) | 0) {
                                    ($t64 = board[System.Array.index(i8, board)])[System.Array.index(3, $t64)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn;
                                }

                                for (var j2 = 1; j2 <= 2; j2 = (j2 + 1) | 0) {
                                    ($t65 = board[System.Array.index(0, board)])[System.Array.index(j2, $t65)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook;
                                    ($t66 = board[System.Array.index(1, board)])[System.Array.index(j2, $t66)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKnight;
                                    ($t67 = board[System.Array.index(2, board)])[System.Array.index(j2, $t67)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteBishop;
                                    ($t68 = board[System.Array.index(3, board)])[System.Array.index(j2, $t68)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteQueen;
                                    ($t69 = board[System.Array.index(4, board)])[System.Array.index(j2, $t69)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteQueen;
                                    ($t70 = board[System.Array.index(5, board)])[System.Array.index(j2, $t70)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteBishop;
                                    ($t71 = board[System.Array.index(6, board)])[System.Array.index(j2, $t71)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKnight;
                                    ($t72 = board[System.Array.index(7, board)])[System.Array.index(j2, $t72)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook;
                                }
                            }
                            break;
                        case ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.FinalBattle: 
                            if (isPlayerWhite) {
                                for (var i9 = 0; i9 < 8; i9 = (i9 + 1) | 0) {
                                    ($t73 = board[System.Array.index(i9, board)])[System.Array.index(4, $t73)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackPawn;
                                }

                                for (var i10 = 0; i10 < 8; i10 = (i10 + 1) | 0) {
                                    for (var j3 = 5; j3 <= 7; j3 = (j3 + 1) | 0) {
                                        if (($t74 = board[System.Array.index(i10, board)])[System.Array.index(j3, $t74)] !== ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKing) {
                                            ($t75 = board[System.Array.index(i10, board)])[System.Array.index(j3, $t75)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackQueen;
                                        }
                                    }
                                }
                            } else {
                                for (var i11 = 0; i11 < 8; i11 = (i11 + 1) | 0) {
                                    ($t76 = board[System.Array.index(i11, board)])[System.Array.index(3, $t76)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn;
                                }

                                for (var i12 = 0; i12 < 8; i12 = (i12 + 1) | 0) {
                                    for (var j4 = 0; j4 <= 2; j4 = (j4 + 1) | 0) {
                                        if (($t77 = board[System.Array.index(i12, board)])[System.Array.index(j4, $t77)] !== ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKing) {
                                            ($t78 = board[System.Array.index(i12, board)])[System.Array.index(j4, $t78)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteQueen;
                                        }
                                    }
                                }
                            }
                            break;
                        default: 
                            throw new System.Exception();
                    }

                    var unmovedPawns = System.Array.init(8, null, System.Array.type(System.Boolean));
                    for (var i13 = 0; i13 < 8; i13 = (i13 + 1) | 0) {
                        unmovedPawns[System.Array.index(i13, unmovedPawns)] = System.Array.init(8, false, System.Boolean);
                        for (var j5 = 0; j5 < 8; j5 = (j5 + 1) | 0) {
                            ($t79 = unmovedPawns[System.Array.index(i13, unmovedPawns)])[System.Array.index(j5, $t79)] = ($t80 = board[System.Array.index(i13, board)])[System.Array.index(j5, $t80)] === ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn || ($t81 = board[System.Array.index(i13, board)])[System.Array.index(j5, $t81)] === ChessCompStompWithHacksEngine.ChessSquarePiece.BlackPawn;
                        }
                    }

                    return new ChessCompStompWithHacksEngine.GameState(new ChessCompStompWithHacksEngine.ChessSquarePieceArray.$ctor1(board), new ChessCompStompWithHacksEngine.UnmovedPawnsArray.$ctor1(unmovedPawns), 1, false, isPlayerWhite, true, null, null, new ChessCompStompWithHacksEngine.GameState.CastlingRights(true, true, true, true), new ChessCompStompWithHacksEngine.GameState.PlayerAbilities(hacks.contains(ChessCompStompWithHacksEngine.Hack.PawnsCanMoveThreeSpacesInitially), hacks.contains(ChessCompStompWithHacksEngine.Hack.SuperEnPassant), hacks.contains(ChessCompStompWithHacksEngine.Hack.RooksCanMoveLikeBishops), hacks.contains(ChessCompStompWithHacksEngine.Hack.SuperCastling), hacks.contains(ChessCompStompWithHacksEngine.Hack.RooksCanCaptureLikeCannons), hacks.contains(ChessCompStompWithHacksEngine.Hack.KnightsCanMakeLargeKnightsMove), hacks.contains(ChessCompStompWithHacksEngine.Hack.QueensCanMoveLikeKnights), hacks.contains(ChessCompStompWithHacksEngine.Hack.TacticalNuke), hacks.contains(ChessCompStompWithHacksEngine.Hack.AnyPieceCanPromote), hacks.contains(ChessCompStompWithHacksEngine.Hack.StalemateIsVictory), hacks.contains(ChessCompStompWithHacksEngine.Hack.OpponentMustCaptureWhenPossible), hacks.contains(ChessCompStompWithHacksEngine.Hack.PawnsDestroyCapturingPiece)));
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.NukeRenderer", {
        statics: {
            fields: {
                ELAPSED_MICROS_TO_FLY_OFF_SCREEN: 0
            },
            ctors: {
                init: function () {
                    this.ELAPSED_MICROS_TO_FLY_OFF_SCREEN = 300000;
                }
            },
            methods: {
                GetNukeRenderer: function (hasNukeAbility, hasUsedNuke, isNukeSelected, isHoverOverNuke, turnCount, timer, colorTheme, isClickingOnNuke) {
                    return new ChessCompStompWithHacksLibrary.NukeRenderer(hasNukeAbility, hasUsedNuke, isNukeSelected, isHoverOverNuke, turnCount, timer, null, colorTheme, isClickingOnNuke);
                },
                IsHoverOverNuke: function (mouse, scalingFactorScaled) {
                    var $t;
                    var mouseX = mouse.DTLibrary$IMouse$GetX();
                    var mouseY = mouse.DTLibrary$IMouse$GetY();

                    var hitboxes = new (System.Collections.Generic.List$1(System.Tuple$4(System.Int32,System.Int32,System.Int32,System.Int32))).ctor();

                    hitboxes.add({ Item1: 38, Item2: 0, Item3: 98, Item4: 18 });
                    hitboxes.add({ Item1: 0, Item2: 18, Item3: 136, Item4: 54 });
                    hitboxes.add({ Item1: 0, Item2: 54, Item3: 136, Item4: 67 });
                    hitboxes.add({ Item1: 9, Item2: 67, Item3: 127, Item4: 77 });
                    hitboxes.add({ Item1: 16, Item2: 77, Item3: 120, Item4: 87 });
                    hitboxes.add({ Item1: 23, Item2: 87, Item3: 113, Item4: 97 });
                    hitboxes.add({ Item1: 29, Item2: 97, Item3: 107, Item4: 104 });
                    hitboxes.add({ Item1: 33, Item2: 104, Item3: 103, Item4: 318 });
                    hitboxes.add({ Item1: 40, Item2: 318, Item3: 96, Item4: 324 });
                    hitboxes.add({ Item1: 46, Item2: 324, Item3: 90, Item4: 355 });
                    hitboxes.add({ Item1: 50, Item2: 355, Item3: 86, Item4: 363 });
                    hitboxes.add({ Item1: 57, Item2: 363, Item3: 79, Item4: 366 });
                    hitboxes.add({ Item1: 61, Item2: 366, Item3: 75, Item4: 369 });

                    $t = Bridge.getEnumerator(hitboxes);
                    try {
                        while ($t.moveNext()) {
                            var hitbox = $t.Current;
                            var startX = (Bridge.Int.div(Bridge.Int.mul(hitbox.Item1, scalingFactorScaled), 128)) | 0;
                            var startY = (Bridge.Int.div(Bridge.Int.mul(hitbox.Item2, scalingFactorScaled), 128)) | 0;
                            var endX = (Bridge.Int.div(Bridge.Int.mul(hitbox.Item3, scalingFactorScaled), 128)) | 0;
                            var endY = (Bridge.Int.div(Bridge.Int.mul(hitbox.Item4, scalingFactorScaled), 128)) | 0;

                            if (mouseX >= startX && mouseX <= endX && mouseY >= startY && mouseY <= endY) {
                                return true;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    return false;
                }
            }
        },
        fields: {
            hasNukeAbility: false,
            hasUsedNuke: false,
            isNukeSelected: false,
            isHoverOverNuke: null,
            turnCount: 0,
            timer: null,
            nukeAnimationElapsedMicros: null,
            colorTheme: 0,
            isClickingOnNuke: false
        },
        ctors: {
            ctor: function (hasNukeAbility, hasUsedNuke, isNukeSelected, isHoverOverNuke, turnCount, timer, nukeAnimationElapsedMicros, colorTheme, isClickingOnNuke) {
                this.$initialize();
                this.hasNukeAbility = hasNukeAbility;
                this.hasUsedNuke = hasUsedNuke;
                this.isNukeSelected = isNukeSelected;
                this.isHoverOverNuke = isHoverOverNuke;
                this.turnCount = turnCount;
                this.timer = timer;
                this.nukeAnimationElapsedMicros = nukeAnimationElapsedMicros;
                this.colorTheme = colorTheme;
                this.isClickingOnNuke = isClickingOnNuke;
            }
        },
        methods: {
            LaunchNuke: function () {
                return new ChessCompStompWithHacksLibrary.NukeRenderer(this.hasNukeAbility, this.hasUsedNuke, this.isNukeSelected, this.isHoverOverNuke, this.turnCount, this.timer, 0, this.colorTheme, this.isClickingOnNuke);
            },
            ProcessFrame: function (hasUsedNuke, isNukeSelected, isHoverOverNuke, turnCount, elapsedMicrosPerFrame, mouseInput) {
                var newNukeAnimationElapsedMicros;
                if (this.nukeAnimationElapsedMicros == null) {
                    newNukeAnimationElapsedMicros = null;
                } else {
                    newNukeAnimationElapsedMicros = Bridge.Int.clip32(System.Nullable.getValue(this.nukeAnimationElapsedMicros) + elapsedMicrosPerFrame);
                }

                if (System.Nullable.hasValue(newNukeAnimationElapsedMicros) && System.Nullable.getValue(newNukeAnimationElapsedMicros) > ChessCompStompWithHacksLibrary.NukeRenderer.ELAPSED_MICROS_TO_FLY_OFF_SCREEN) {
                    newNukeAnimationElapsedMicros = 300001;
                }

                return new ChessCompStompWithHacksLibrary.NukeRenderer(this.hasNukeAbility, hasUsedNuke, isNukeSelected, isHoverOverNuke, turnCount, this.timer, newNukeAnimationElapsedMicros, this.colorTheme, isHoverOverNuke != null && mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed());
            },
            HasNukeFlownOffScreen: function () {
                if (this.nukeAnimationElapsedMicros == null) {
                    return false;
                }

                return System.Nullable.getValue(this.nukeAnimationElapsedMicros) >= ChessCompStompWithHacksLibrary.NukeRenderer.ELAPSED_MICROS_TO_FLY_OFF_SCREEN;
            },
            Render: function (endingY, scalingFactorScaled, displayOutput, isMobileDisplayType) {
                if (!this.hasNukeAbility) {
                    return;
                }

                if (this.nukeAnimationElapsedMicros == null) {
                    if (this.hasUsedNuke) {
                        return;
                    }

                    var isNukeAvailable = this.turnCount > ChessCompStompWithHacksEngine.TacticalNukeUtil.NumberOfMovesPlayedBeforeNukeIsAvailable;

                    var nukeImage = new ChessCompStompWithHacksLibrary.GameImage();

                    if (isNukeAvailable) {
                        if (this.isNukeSelected) {
                            nukeImage = ChessCompStompWithHacksLibrary.GameImage.Nuke_Selected;
                        } else {
                            if (this.isHoverOverNuke != null && !isMobileDisplayType) {
                                nukeImage = ChessCompStompWithHacksLibrary.GameImage.Nuke_Hover;
                            } else {
                                nukeImage = ChessCompStompWithHacksLibrary.GameImage.Nuke_Ready;
                            }
                        }
                    } else {
                        nukeImage = ChessCompStompWithHacksLibrary.GameImage.Nuke_NotReady;
                    }

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawImageRotatedClockwise$1(nukeImage, 0, 0, 0, scalingFactorScaled);

                    if (this.isHoverOverNuke != null && !isNukeAvailable && (!isMobileDisplayType || this.isClickingOnNuke)) {
                        var heightOffset = isMobileDisplayType ? 125 : 0;

                        var numTurnsUntilNukeAvailable = (11 - this.turnCount) | 0;
                        displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(this.isHoverOverNuke.Item1, ((this.isHoverOverNuke.Item2 + heightOffset) | 0), ((335 + (numTurnsUntilNukeAvailable >= 10 ? 8 : 0)) | 0), 21, ChessCompStompWithHacksLibrary.ColorThemeUtil.GetTextBackgroundColor(this.colorTheme), true);

                        var text = numTurnsUntilNukeAvailable > 1 ? "Tactical nuke available in " + (DTLibrary.StringUtil.ToStringCultureInvariant(numTurnsUntilNukeAvailable) || "") + " turns" : "Tactical nuke available in 1 turn";

                        displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((this.isHoverOverNuke.Item1 + 5) | 0), ((((this.isHoverOverNuke.Item2 + heightOffset) | 0) + 19) | 0), text, ChessCompStompWithHacksLibrary.GameFont.GameFont14Pt, DTLibrary.DTColor.Black());
                    }
                } else {
                    if (System.Nullable.getValue(this.nukeAnimationElapsedMicros) >= ChessCompStompWithHacksLibrary.NukeRenderer.ELAPSED_MICROS_TO_FLY_OFF_SCREEN) {
                        return;
                    }

                    var rocketWidth = (Bridge.Int.div(Bridge.Int.mul(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetWidth(ChessCompStompWithHacksLibrary.GameImage.Nuke_Ready), scalingFactorScaled), 128)) | 0;

                    var rocketFireScalingFactor = Bridge.Int.mul(2, scalingFactorScaled);
                    var rocketFireWidthOriginal = displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetWidth(ChessCompStompWithHacksLibrary.GameImage.Nuke_RocketFire);
                    var rocketFireHeightOriginal = displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetHeight(ChessCompStompWithHacksLibrary.GameImage.Nuke_RocketFire);
                    var rocketFireWidthScaled = (Bridge.Int.div(Bridge.Int.mul(rocketFireWidthOriginal, rocketFireScalingFactor), 128)) | 0;
                    var rocketFireHeightScaled = (Bridge.Int.div(Bridge.Int.mul(rocketFireHeightOriginal, rocketFireScalingFactor), 128)) | 0;
                    var y = System.Int64.clip32(System.Int64(System.Nullable.getValue(this.nukeAnimationElapsedMicros)).mul(System.Int64(endingY)).div((System.Int64(300000))));

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawImageRotatedClockwise$1(ChessCompStompWithHacksLibrary.GameImage.Nuke_Ready, 0, y, 0, scalingFactorScaled);

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawImageRotatedClockwise$1(ChessCompStompWithHacksLibrary.GameImage.Nuke_RocketFire, ((Bridge.Int.div((((rocketWidth - rocketFireWidthScaled) | 0)), 2)) | 0), ((y - rocketFireHeightScaled) | 0), 0, rocketFireScalingFactor);
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ObjectiveDisplay", {
        statics: {
            fields: {
                NON_FINAL_OBJECTIVE_WIDTH: 0,
                NON_FINAL_OBJECTIVE_HEIGHT: 0,
                FINAL_OBJECTIVE_WIDTH: 0,
                FINAL_OBJECTIVE_HEIGHT: 0
            },
            ctors: {
                init: function () {
                    this.NON_FINAL_OBJECTIVE_WIDTH = 250;
                    this.NON_FINAL_OBJECTIVE_HEIGHT = 100;
                    this.FINAL_OBJECTIVE_WIDTH = 500;
                    this.FINAL_OBJECTIVE_HEIGHT = 100;
                }
            }
        },
        fields: {
            objectiveDisplayUtil: null
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                this.objectiveDisplayUtil = new ChessCompStompWithHacksLibrary.ObjectiveDisplayUtil();
            }
        },
        methods: {
            RenderNonFinalObjective: function (x, y, objective, completedObjectives, displayOutput) {
                var hasCompletedObjective = completedObjectives.contains(objective);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(x, y, 249, 99, hasCompletedObjective ? new DTLibrary.DTColor.ctor(201, 255, 196) : new DTLibrary.DTColor.ctor(255, 211, 161), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(x, y, ChessCompStompWithHacksLibrary.ObjectiveDisplay.NON_FINAL_OBJECTIVE_WIDTH, ChessCompStompWithHacksLibrary.ObjectiveDisplay.NON_FINAL_OBJECTIVE_HEIGHT, new DTLibrary.DTColor.ctor(110, 110, 110), false);

                if (objective === ChessCompStompWithHacksEngine.Objective.WinFinalBattle) {
                    throw new System.Exception();
                }

                var objectiveDescription = this.objectiveDisplayUtil.GetObjectiveDescription(objective).DescriptionForObjectiveFrame;

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((x + 10) | 0), ((y + 90) | 0), objectiveDescription, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, DTLibrary.DTColor.Black());

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((x + 10) | 0), ((y + 39) | 0), (DTLibrary.StringUtil.ToStringCultureInvariant(ChessCompStompWithHacksLibrary.SessionState.NUMBER_OF_HACK_POINTS_PER_OBJECTIVE) || "") + " hack points", ChessCompStompWithHacksLibrary.GameFont.GameFont14Pt, new DTLibrary.DTColor.ctor(128, 128, 128));

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((x + 10) | 0), ((y + 20) | 0), hasCompletedObjective ? "(completed)" : "(incomplete)", ChessCompStompWithHacksLibrary.GameFont.GameFont12Pt, new DTLibrary.DTColor.ctor(128, 128, 128));
            },
            HasUnlockedFinalObjective: function (completedObjectives) {
                return completedObjectives.contains(ChessCompStompWithHacksEngine.Objective.DefeatComputer) && completedObjectives.contains(ChessCompStompWithHacksEngine.Objective.DefeatComputerByPlayingAtMost25Moves) && completedObjectives.contains(ChessCompStompWithHacksEngine.Objective.DefeatComputerWith5QueensOnTheBoard) && completedObjectives.contains(ChessCompStompWithHacksEngine.Objective.CheckmateUsingAKnight) && completedObjectives.contains(ChessCompStompWithHacksEngine.Objective.PromoteAPieceToABishop) && completedObjectives.contains(ChessCompStompWithHacksEngine.Objective.LaunchANuke);
            },
            RenderFinalObjective: function (x, y, completedObjectives, displayOutput) {
                var hasCompletedObjective = completedObjectives.contains(ChessCompStompWithHacksEngine.Objective.WinFinalBattle);

                var hasUnlockedFinalObjective = this.HasUnlockedFinalObjective(completedObjectives);

                var fillColor;

                if (hasCompletedObjective) {
                    fillColor = new DTLibrary.DTColor.ctor(201, 255, 196);
                } else {
                    if (!hasUnlockedFinalObjective) {
                        fillColor = new DTLibrary.DTColor.ctor(179, 179, 179);
                    } else {
                        fillColor = new DTLibrary.DTColor.ctor(252, 185, 149);
                    }
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(x, y, 499, 99, fillColor, true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(x, y, ChessCompStompWithHacksLibrary.ObjectiveDisplay.FINAL_OBJECTIVE_WIDTH, ChessCompStompWithHacksLibrary.ObjectiveDisplay.FINAL_OBJECTIVE_HEIGHT, new DTLibrary.DTColor.ctor(110, 110, 110), false);

                if (hasUnlockedFinalObjective) {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((x + 10) | 0), ((y + 90) | 0), this.objectiveDisplayUtil.GetObjectiveDescription(ChessCompStompWithHacksEngine.Objective.WinFinalBattle).DescriptionForObjectiveFrame, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, DTLibrary.DTColor.Black());

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((x + 10) | 0), ((y + 30) | 0), hasCompletedObjective ? "(completed)" : "(incomplete)", ChessCompStompWithHacksLibrary.GameFont.GameFont14Pt, new DTLibrary.DTColor.ctor(128, 128, 128));
                } else {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((x + 237) | 0), ((y + 76) | 0), "?", ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt, DTLibrary.DTColor.Black());
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ObjectiveDisplayUtil", {
        fields: {
            nameOfCastlingVeryLongAndPromotingToQueenWithCheckmateMove: null
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                this.nameOfCastlingVeryLongAndPromotingToQueenWithCheckmateMove = ChessCompStompWithHacksEngine.ObjectiveChecker.GetNameOfCastlingVeryLongAndPromotingToQueenWithCheckmateMove();
            }
        },
        methods: {
            GetObjectiveDescription: function (objective) {
                switch (objective) {
                    case ChessCompStompWithHacksEngine.Objective.DefeatComputer: 
                        return new ChessCompStompWithHacksLibrary.ObjectiveDisplayUtil.ObjectiveDescription("Win a game against\nthe AI.", "Win a game against the AI");
                    case ChessCompStompWithHacksEngine.Objective.DefeatComputerByPlayingAtMost25Moves: 
                        return new ChessCompStompWithHacksLibrary.ObjectiveDisplayUtil.ObjectiveDescription("Win by playing at\nmost 25 moves.", "Win by playing at most 25 moves");
                    case ChessCompStompWithHacksEngine.Objective.DefeatComputerWith5QueensOnTheBoard: 
                        return new ChessCompStompWithHacksLibrary.ObjectiveDisplayUtil.ObjectiveDescription("Win with 5 queens on\nthe board.", "Win with 5 queens on the board");
                    case ChessCompStompWithHacksEngine.Objective.CheckmateUsingAKnight: 
                        return new ChessCompStompWithHacksLibrary.ObjectiveDisplayUtil.ObjectiveDescription("Deliver checkmate\nusing a knight.", "Deliver checkmate using a knight");
                    case ChessCompStompWithHacksEngine.Objective.PromoteAPieceToABishop: 
                        return new ChessCompStompWithHacksLibrary.ObjectiveDisplayUtil.ObjectiveDescription("Promote a piece to\na bishop.", "Promote a piece to a bishop");
                    case ChessCompStompWithHacksEngine.Objective.LaunchANuke: 
                        return new ChessCompStompWithHacksLibrary.ObjectiveDisplayUtil.ObjectiveDescription("Launch a nuke.", "Launch a nuke");
                    case ChessCompStompWithHacksEngine.Objective.WinFinalBattle: 
                        return new ChessCompStompWithHacksLibrary.ObjectiveDisplayUtil.ObjectiveDescription("Win the Final Battle against the AI.", "Win the Final Battle against the AI");
                    case ChessCompStompWithHacksEngine.Objective.PlayAStupidOpening: 
                        return new ChessCompStompWithHacksLibrary.ObjectiveDisplayUtil.ObjectiveDescription("Play a stupid\nopening.", "Play a stupid opening");
                    case ChessCompStompWithHacksEngine.Objective.NukeYourOwnPieces: 
                        return new ChessCompStompWithHacksLibrary.ObjectiveDisplayUtil.ObjectiveDescription("Carelessly nuke\nyour own pieces.", "Carelessly nuke your own pieces");
                    case ChessCompStompWithHacksEngine.Objective.WinByCastlingVeryLongAndPromotingRookToQueen: 
                        return new ChessCompStompWithHacksLibrary.ObjectiveDisplayUtil.ObjectiveDescription("Play the move\n" + (this.nameOfCastlingVeryLongAndPromotingToQueenWithCheckmateMove || ""), "Play the move " + (this.nameOfCastlingVeryLongAndPromotingToQueenWithCheckmateMove || ""));
                    default: 
                        throw new System.Exception();
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ObjectiveDisplayUtil.ObjectiveDescription", {
        $kind: "nested class",
        fields: {
            DescriptionForObjectiveFrame: null,
            DescriptionForVictoryStalemateOrDefeatPanel: null
        },
        ctors: {
            ctor: function (descriptionForObjectiveFrame, descriptionForVictoryStalemateOrDefeatPanel) {
                this.$initialize();
                this.DescriptionForObjectiveFrame = descriptionForObjectiveFrame;
                this.DescriptionForVictoryStalemateOrDefeatPanel = descriptionForVictoryStalemateOrDefeatPanel;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ObjectivesScreenDisplayDesktop", {
        fields: {
            objectiveDisplay: null,
            completedObjectives: null
        },
        ctors: {
            ctor: function (sessionState) {
                this.$initialize();
                this.objectiveDisplay = new ChessCompStompWithHacksLibrary.ObjectiveDisplay();
                this.completedObjectives = sessionState.GetCompletedObjectives();
            }
        },
        methods: {
            HasCompletedAtLeastOneHiddenObjective: function () {
                return this.GetCompletedHiddenObjectives().Count > 0;
            },
            GetCompletedHiddenObjectives: function () {
                var $t;
                var completedHiddenObjectives = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.Objective)).ctor();

                $t = Bridge.getEnumerator(this.completedObjectives);
                try {
                    while ($t.moveNext()) {
                        var completedObjective = $t.Current;
                        if (ChessCompStompWithHacksLibrary.ObjectiveUtil.IsHiddenObjective(completedObjective)) {
                            completedHiddenObjectives.add(completedObjective);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                return completedHiddenObjectives;
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(389, 675, "Objectives", ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt, DTLibrary.DTColor.Black());

                var row1Y;
                var row2Y;
                var row3Y;
                var completedHiddenObjectives = this.GetCompletedHiddenObjectives();
                completedHiddenObjectives.Sort$1(new ChessCompStompWithHacksLibrary.ObjectiveUtil.ObjectiveComparer());

                if (this.HasCompletedAtLeastOneHiddenObjective()) {
                    row1Y = 520;
                    row2Y = (row1Y - 110) | 0;
                    row3Y = (row2Y - 110) | 0;
                } else {
                    row1Y = 450;
                    row2Y = (row1Y - 130) | 0;
                    row3Y = (row2Y - 130) | 0;
                }

                this.objectiveDisplay.RenderNonFinalObjective(62, row1Y, ChessCompStompWithHacksEngine.Objective.DefeatComputer, this.completedObjectives, displayOutput);

                this.objectiveDisplay.RenderNonFinalObjective(375, row1Y, ChessCompStompWithHacksEngine.Objective.DefeatComputerByPlayingAtMost25Moves, this.completedObjectives, displayOutput);

                this.objectiveDisplay.RenderNonFinalObjective(687, row1Y, ChessCompStompWithHacksEngine.Objective.DefeatComputerWith5QueensOnTheBoard, this.completedObjectives, displayOutput);

                this.objectiveDisplay.RenderNonFinalObjective(62, row2Y, ChessCompStompWithHacksEngine.Objective.CheckmateUsingAKnight, this.completedObjectives, displayOutput);

                this.objectiveDisplay.RenderNonFinalObjective(375, row2Y, ChessCompStompWithHacksEngine.Objective.PromoteAPieceToABishop, this.completedObjectives, displayOutput);

                this.objectiveDisplay.RenderNonFinalObjective(687, row2Y, ChessCompStompWithHacksEngine.Objective.LaunchANuke, this.completedObjectives, displayOutput);

                if (completedHiddenObjectives.Count >= 1) {
                    this.objectiveDisplay.RenderNonFinalObjective(62, row3Y, completedHiddenObjectives.getItem(0), this.completedObjectives, displayOutput);
                }
                if (completedHiddenObjectives.Count >= 2) {
                    this.objectiveDisplay.RenderNonFinalObjective(375, row3Y, completedHiddenObjectives.getItem(1), this.completedObjectives, displayOutput);
                }
                if (completedHiddenObjectives.Count >= 3) {
                    this.objectiveDisplay.RenderNonFinalObjective(687, row3Y, completedHiddenObjectives.getItem(2), this.completedObjectives, displayOutput);
                }

                if (completedHiddenObjectives.Count >= 4) {
                    throw new System.Exception();
                }

                this.objectiveDisplay.RenderFinalObjective(250, 190, this.completedObjectives, displayOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ObjectivesScreenDisplayMobile", {
        fields: {
            objectiveDisplay: null,
            completedObjectives: null
        },
        ctors: {
            ctor: function (sessionState) {
                this.$initialize();
                this.objectiveDisplay = new ChessCompStompWithHacksLibrary.ObjectiveDisplay();
                this.completedObjectives = sessionState.GetCompletedObjectives();
            }
        },
        methods: {
            HasCompletedThreeHiddenObjectives: function () {
                return this.GetCompletedHiddenObjectives().Count === 3;
            },
            HasCompletedAtLeastOneHiddenObjective: function () {
                return this.GetCompletedHiddenObjectives().Count > 0;
            },
            GetCompletedHiddenObjectives: function () {
                var $t;
                var completedHiddenObjectives = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.Objective)).ctor();

                $t = Bridge.getEnumerator(this.completedObjectives);
                try {
                    while ($t.moveNext()) {
                        var completedObjective = $t.Current;
                        if (ChessCompStompWithHacksLibrary.ObjectiveUtil.IsHiddenObjective(completedObjective)) {
                            completedHiddenObjectives.add(completedObjective);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                return completedHiddenObjectives;
            },
            Render: function (displayOutput) {
                if (DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput)) {
                    this.RenderLandscape(displayOutput);
                } else {
                    this.RenderPortrait(displayOutput);
                }
            },
            RenderLandscape: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((((Bridge.Int.div(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth(), 2)) | 0) - 163) | 0), 675, "Objectives", ChessCompStompWithHacksLibrary.GameFont.GameFont48Pt, DTLibrary.DTColor.Black());

                var row1Y;
                var row2Y;
                var row3Y;
                var completedHiddenObjectives = this.GetCompletedHiddenObjectives();
                completedHiddenObjectives.Sort$1(new ChessCompStompWithHacksLibrary.ObjectiveUtil.ObjectiveComparer());

                if (this.HasCompletedAtLeastOneHiddenObjective()) {
                    row1Y = 505;
                    row2Y = (row1Y - 105) | 0;
                    row3Y = (row2Y - 105) | 0;
                } else {
                    row1Y = 450;
                    row2Y = (row1Y - 130) | 0;
                    row3Y = (row2Y - 130) | 0;
                }

                var spacingWidth = (Bridge.Int.div((((displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth() - 750) | 0)), 4)) | 0;
                var column1X = spacingWidth;
                var column2X = (((column1X + 250) | 0) + spacingWidth) | 0;
                var column3X = (((column2X + 250) | 0) + spacingWidth) | 0;

                this.objectiveDisplay.RenderNonFinalObjective(column1X, row1Y, ChessCompStompWithHacksEngine.Objective.DefeatComputer, this.completedObjectives, displayOutput);

                this.objectiveDisplay.RenderNonFinalObjective(column2X, row1Y, ChessCompStompWithHacksEngine.Objective.DefeatComputerByPlayingAtMost25Moves, this.completedObjectives, displayOutput);

                this.objectiveDisplay.RenderNonFinalObjective(column3X, row1Y, ChessCompStompWithHacksEngine.Objective.DefeatComputerWith5QueensOnTheBoard, this.completedObjectives, displayOutput);

                this.objectiveDisplay.RenderNonFinalObjective(column1X, row2Y, ChessCompStompWithHacksEngine.Objective.CheckmateUsingAKnight, this.completedObjectives, displayOutput);

                this.objectiveDisplay.RenderNonFinalObjective(column2X, row2Y, ChessCompStompWithHacksEngine.Objective.PromoteAPieceToABishop, this.completedObjectives, displayOutput);

                this.objectiveDisplay.RenderNonFinalObjective(column3X, row2Y, ChessCompStompWithHacksEngine.Objective.LaunchANuke, this.completedObjectives, displayOutput);

                if (completedHiddenObjectives.Count >= 1) {
                    this.objectiveDisplay.RenderNonFinalObjective(column1X, row3Y, completedHiddenObjectives.getItem(0), this.completedObjectives, displayOutput);
                }
                if (completedHiddenObjectives.Count >= 2) {
                    this.objectiveDisplay.RenderNonFinalObjective(column2X, row3Y, completedHiddenObjectives.getItem(1), this.completedObjectives, displayOutput);
                }
                if (completedHiddenObjectives.Count >= 3) {
                    this.objectiveDisplay.RenderNonFinalObjective(column3X, row3Y, completedHiddenObjectives.getItem(2), this.completedObjectives, displayOutput);
                }

                if (completedHiddenObjectives.Count >= 4) {
                    throw new System.Exception();
                }

                this.objectiveDisplay.RenderFinalObjective(((Bridge.Int.div((((displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth() - 500) | 0)), 2)) | 0), 190, this.completedObjectives, displayOutput);
            },
            RenderPortrait: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(187, ((displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight() - 100) | 0), "Objectives", ChessCompStompWithHacksLibrary.GameFont.GameFont48Pt, DTLibrary.DTColor.Black());

                var row1Y;
                var row2Y;
                var row3Y;
                var row4Y;
                var row5Y;
                var completedHiddenObjectives = this.GetCompletedHiddenObjectives();
                completedHiddenObjectives.Sort$1(new ChessCompStompWithHacksLibrary.ObjectiveUtil.ObjectiveComparer());

                if (this.HasCompletedThreeHiddenObjectives()) {
                    var spacing = (Bridge.Int.div((((((((displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight() - 270) | 0) - 290) | 0) - 400) | 0)), 5)) | 0;
                    row1Y = (displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight() - 270) | 0;
                    row2Y = (((row1Y - 100) | 0) - spacing) | 0;
                    row3Y = (((row2Y - 100) | 0) - spacing) | 0;
                    row4Y = (((row3Y - 100) | 0) - spacing) | 0;
                    row5Y = (((row4Y - 100) | 0) - spacing) | 0;
                } else if (this.HasCompletedAtLeastOneHiddenObjective()) {
                    var spacing1 = (Bridge.Int.div((((((((displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight() - 270) | 0) - 290) | 0) - 300) | 0)), 4)) | 0;
                    row1Y = (displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight() - 270) | 0;
                    row2Y = (((row1Y - 100) | 0) - spacing1) | 0;
                    row3Y = (((row2Y - 100) | 0) - spacing1) | 0;
                    row4Y = (((row3Y - 100) | 0) - spacing1) | 0;
                    row5Y = (((row4Y - 100) | 0) - spacing1) | 0;
                } else {
                    var spacing2 = (Bridge.Int.div((((((((displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight() - 325) | 0) - 290) | 0) - 200) | 0)), 3)) | 0;
                    row1Y = (displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight() - 325) | 0;
                    row2Y = (((row1Y - 100) | 0) - spacing2) | 0;
                    row3Y = (((row2Y - 100) | 0) - spacing2) | 0;
                    row4Y = (((row3Y - 100) | 0) - spacing2) | 0;
                    row5Y = (((row4Y - 100) | 0) - spacing2) | 0;
                }

                this.objectiveDisplay.RenderNonFinalObjective(67, row1Y, ChessCompStompWithHacksEngine.Objective.DefeatComputer, this.completedObjectives, displayOutput);

                this.objectiveDisplay.RenderNonFinalObjective(383, row1Y, ChessCompStompWithHacksEngine.Objective.DefeatComputerByPlayingAtMost25Moves, this.completedObjectives, displayOutput);

                this.objectiveDisplay.RenderNonFinalObjective(67, row2Y, ChessCompStompWithHacksEngine.Objective.DefeatComputerWith5QueensOnTheBoard, this.completedObjectives, displayOutput);

                this.objectiveDisplay.RenderNonFinalObjective(383, row2Y, ChessCompStompWithHacksEngine.Objective.CheckmateUsingAKnight, this.completedObjectives, displayOutput);

                this.objectiveDisplay.RenderNonFinalObjective(67, row3Y, ChessCompStompWithHacksEngine.Objective.PromoteAPieceToABishop, this.completedObjectives, displayOutput);

                this.objectiveDisplay.RenderNonFinalObjective(383, row3Y, ChessCompStompWithHacksEngine.Objective.LaunchANuke, this.completedObjectives, displayOutput);

                if (completedHiddenObjectives.Count >= 1) {
                    this.objectiveDisplay.RenderNonFinalObjective(67, row4Y, completedHiddenObjectives.getItem(0), this.completedObjectives, displayOutput);
                }
                if (completedHiddenObjectives.Count >= 2) {
                    this.objectiveDisplay.RenderNonFinalObjective(383, row4Y, completedHiddenObjectives.getItem(1), this.completedObjectives, displayOutput);
                }
                if (completedHiddenObjectives.Count >= 3) {
                    this.objectiveDisplay.RenderNonFinalObjective(67, row5Y, completedHiddenObjectives.getItem(2), this.completedObjectives, displayOutput);
                }

                if (completedHiddenObjectives.Count >= 4) {
                    throw new System.Exception();
                }

                this.objectiveDisplay.RenderFinalObjective(100, 190, this.completedObjectives, displayOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ObjectiveUtil", {
        statics: {
            methods: {
                IsHiddenObjective: function (objective) {
                    switch (objective) {
                        case ChessCompStompWithHacksEngine.Objective.DefeatComputer: 
                        case ChessCompStompWithHacksEngine.Objective.DefeatComputerByPlayingAtMost25Moves: 
                        case ChessCompStompWithHacksEngine.Objective.DefeatComputerWith5QueensOnTheBoard: 
                        case ChessCompStompWithHacksEngine.Objective.CheckmateUsingAKnight: 
                        case ChessCompStompWithHacksEngine.Objective.PromoteAPieceToABishop: 
                        case ChessCompStompWithHacksEngine.Objective.LaunchANuke: 
                            return false;
                        case ChessCompStompWithHacksEngine.Objective.WinFinalBattle: 
                            return false;
                        case ChessCompStompWithHacksEngine.Objective.PlayAStupidOpening: 
                        case ChessCompStompWithHacksEngine.Objective.NukeYourOwnPieces: 
                        case ChessCompStompWithHacksEngine.Objective.WinByCastlingVeryLongAndPromotingRookToQueen: 
                            return true;
                        default: 
                            throw new System.Exception();
                    }
                },
                GetObjectiveIdMapping: function () {
                    var list = new (System.Collections.Generic.List$1(System.Tuple$2(ChessCompStompWithHacksEngine.Objective,System.Int32))).ctor();

                    list.add({ Item1: ChessCompStompWithHacksEngine.Objective.DefeatComputer, Item2: 1 });
                    list.add({ Item1: ChessCompStompWithHacksEngine.Objective.DefeatComputerByPlayingAtMost25Moves, Item2: 2 });
                    list.add({ Item1: ChessCompStompWithHacksEngine.Objective.DefeatComputerWith5QueensOnTheBoard, Item2: 3 });
                    list.add({ Item1: ChessCompStompWithHacksEngine.Objective.CheckmateUsingAKnight, Item2: 4 });
                    list.add({ Item1: ChessCompStompWithHacksEngine.Objective.PromoteAPieceToABishop, Item2: 5 });
                    list.add({ Item1: ChessCompStompWithHacksEngine.Objective.LaunchANuke, Item2: 6 });
                    list.add({ Item1: ChessCompStompWithHacksEngine.Objective.WinFinalBattle, Item2: 7 });
                    list.add({ Item1: ChessCompStompWithHacksEngine.Objective.PlayAStupidOpening, Item2: 8 });
                    list.add({ Item1: ChessCompStompWithHacksEngine.Objective.NukeYourOwnPieces, Item2: 9 });
                    list.add({ Item1: ChessCompStompWithHacksEngine.Objective.WinByCastlingVeryLongAndPromotingRookToQueen, Item2: 10 });

                    return list;
                },
                /**
                 * Returns null if the objectiveId isn't valid
                 *
                 * @static
                 * @public
                 * @this ChessCompStompWithHacksLibrary.ObjectiveUtil
                 * @memberof ChessCompStompWithHacksLibrary.ObjectiveUtil
                 * @param   {number}                                      objectiveId
                 * @return  {?ChessCompStompWithHacksEngine.Objective}
                 */
                GetObjectiveFromObjectiveId: function (objectiveId) {
                    var $t;
                    var mapping = ChessCompStompWithHacksLibrary.ObjectiveUtil.GetObjectiveIdMapping();

                    $t = Bridge.getEnumerator(mapping);
                    try {
                        while ($t.moveNext()) {
                            var tuple = $t.Current;
                            if (tuple.Item2 === objectiveId) {
                                return tuple.Item1;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    return null;
                },
                /**
                 * Maps an objective to an integer identifier (in a consistent but arbitrary way)
                 *
                 * @static
                 * @public
                 * @this ChessCompStompWithHacksLibrary.ObjectiveUtil
                 * @memberof ChessCompStompWithHacksLibrary.ObjectiveUtil
                 * @param   {ChessCompStompWithHacksEngine.Objective}    objective
                 * @return  {number}
                 */
                GetObjectiveId: function (objective) {
                    var $t;
                    var mapping = ChessCompStompWithHacksLibrary.ObjectiveUtil.GetObjectiveIdMapping();

                    $t = Bridge.getEnumerator(mapping);
                    try {
                        while ($t.moveNext()) {
                            var tuple = $t.Current;
                            if (tuple.Item1 === objective) {
                                return tuple.Item2;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    throw new System.Exception();
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.PromotionPanel", {
        statics: {
            fields: {
                PROMOTION_PANEL_WIDTH_DESKTOP: 0,
                PROMOTION_PANEL_HEIGHT_DESKTOP: 0,
                PROMOTION_PANEL_WIDTH_MOBILE: 0,
                PROMOTION_PANEL_HEIGHT_MOBILE: 0,
                QUEEN_OFFSET_X_DESKTOP: 0,
                ROOK_OFFSET_X_DESKTOP: 0,
                KNIGHT_OFFSET_X_DESKTOP: 0,
                BISHOP_OFFSET_X_DESKTOP: 0,
                PIECE_OFFSET_Y_DESKTOP: 0,
                QUEEN_OFFSET_X_MOBILE: 0,
                ROOK_OFFSET_X_MOBILE: 0,
                KNIGHT_OFFSET_X_MOBILE: 0,
                BISHOP_OFFSET_X_MOBILE: 0,
                PIECE_OFFSET_Y_MOBILE: 0
            },
            ctors: {
                init: function () {
                    this.PROMOTION_PANEL_WIDTH_DESKTOP = 293;
                    this.PROMOTION_PANEL_HEIGHT_DESKTOP = 100;
                    this.PROMOTION_PANEL_WIDTH_MOBILE = 410;
                    this.PROMOTION_PANEL_HEIGHT_MOBILE = 150;
                    this.QUEEN_OFFSET_X_DESKTOP = 10;
                    this.ROOK_OFFSET_X_DESKTOP = 80;
                    this.KNIGHT_OFFSET_X_DESKTOP = 150;
                    this.BISHOP_OFFSET_X_DESKTOP = 220;
                    this.PIECE_OFFSET_Y_DESKTOP = 8;
                    this.QUEEN_OFFSET_X_MOBILE = 15;
                    this.ROOK_OFFSET_X_MOBILE = 113;
                    this.KNIGHT_OFFSET_X_MOBILE = 211;
                    this.BISHOP_OFFSET_X_MOBILE = 309;
                    this.PIECE_OFFSET_Y_MOBILE = 12;
                }
            },
            methods: {
                GetPromotionPanel: function (isWhite, colorTheme) {
                    return new ChessCompStompWithHacksLibrary.PromotionPanel(isWhite, false, 0, 0, null, null, colorTheme);
                },
                /**
                 * Returns the piece that the mouse is hovering over, if any
                 *
                 * @static
                 * @public
                 * @this ChessCompStompWithHacksLibrary.PromotionPanel
                 * @memberof ChessCompStompWithHacksLibrary.PromotionPanel
                 * @param   {number}                            promotionPanelX        
                 * @param   {number}                            promotionPanelY        
                 * @param   {DTLibrary.IMouse}                  mouse                  
                 * @param   {DTLibrary.IDisplayProcessing$1}    displayProcessing      
                 * @param   {boolean}                           isMobileDisplayType
                 * @return  {?number}
                 */
                IsHoverOverSquare: function (promotionPanelX, promotionPanelY, mouse, displayProcessing, isMobileDisplayType) {
                    if (isMobileDisplayType) {
                        var imageWidth = (Bridge.Int.div(Bridge.Int.mul(displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetWidth(ChessCompStompWithHacksLibrary.GameImage.WhitePawn), ChessCompStompWithHacksLibrary.GameImageUtil.MobileChessPieceScalingFactor), 128)) | 0;
                        var imageHeight = (Bridge.Int.div(Bridge.Int.mul(displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetHeight(ChessCompStompWithHacksLibrary.GameImage.WhitePawn), ChessCompStompWithHacksLibrary.GameImageUtil.MobileChessPieceScalingFactor), 128)) | 0;

                        var mouseX = mouse.DTLibrary$IMouse$GetX();
                        var mouseY = mouse.DTLibrary$IMouse$GetY();

                        if (mouseY < ((((promotionPanelY - ChessCompStompWithHacksLibrary.PromotionPanel.PROMOTION_PANEL_HEIGHT_MOBILE) | 0) + ChessCompStompWithHacksLibrary.PromotionPanel.PIECE_OFFSET_Y_MOBILE) | 0)) {
                            return null;
                        }
                        if (mouseY > ((((((promotionPanelY - ChessCompStompWithHacksLibrary.PromotionPanel.PROMOTION_PANEL_HEIGHT_MOBILE) | 0) + ChessCompStompWithHacksLibrary.PromotionPanel.PIECE_OFFSET_Y_MOBILE) | 0) + imageHeight) | 0)) {
                            return null;
                        }

                        var mouseXRelativeToPanel = (mouseX - promotionPanelX) | 0;

                        if (ChessCompStompWithHacksLibrary.PromotionPanel.QUEEN_OFFSET_X_MOBILE <= mouseXRelativeToPanel && mouseXRelativeToPanel <= ((ChessCompStompWithHacksLibrary.PromotionPanel.QUEEN_OFFSET_X_MOBILE + imageWidth) | 0)) {
                            return ChessCompStompWithHacksEngine.Move.PromotionType.PromoteToQueen;
                        }
                        if (ChessCompStompWithHacksLibrary.PromotionPanel.ROOK_OFFSET_X_MOBILE <= mouseXRelativeToPanel && mouseXRelativeToPanel <= ((ChessCompStompWithHacksLibrary.PromotionPanel.ROOK_OFFSET_X_MOBILE + imageWidth) | 0)) {
                            return ChessCompStompWithHacksEngine.Move.PromotionType.PromoteToRook;
                        }
                        if (ChessCompStompWithHacksLibrary.PromotionPanel.KNIGHT_OFFSET_X_MOBILE <= mouseXRelativeToPanel && mouseXRelativeToPanel <= ((ChessCompStompWithHacksLibrary.PromotionPanel.KNIGHT_OFFSET_X_MOBILE + imageWidth) | 0)) {
                            return ChessCompStompWithHacksEngine.Move.PromotionType.PromoteToKnight;
                        }
                        if (ChessCompStompWithHacksLibrary.PromotionPanel.BISHOP_OFFSET_X_MOBILE <= mouseXRelativeToPanel && mouseXRelativeToPanel <= ((ChessCompStompWithHacksLibrary.PromotionPanel.BISHOP_OFFSET_X_MOBILE + imageWidth) | 0)) {
                            return ChessCompStompWithHacksEngine.Move.PromotionType.PromoteToBishop;
                        }
                        return null;
                    } else {
                        var imageWidth1 = (Bridge.Int.div(Bridge.Int.mul(displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetWidth(ChessCompStompWithHacksLibrary.GameImage.WhitePawn), ChessCompStompWithHacksLibrary.GameImageUtil.DesktopChessPieceScalingFactor), 128)) | 0;
                        var imageHeight1 = (Bridge.Int.div(Bridge.Int.mul(displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetHeight(ChessCompStompWithHacksLibrary.GameImage.WhitePawn), ChessCompStompWithHacksLibrary.GameImageUtil.DesktopChessPieceScalingFactor), 128)) | 0;

                        var mouseX1 = mouse.DTLibrary$IMouse$GetX();
                        var mouseY1 = mouse.DTLibrary$IMouse$GetY();

                        if (mouseY1 < ((((promotionPanelY - ChessCompStompWithHacksLibrary.PromotionPanel.PROMOTION_PANEL_HEIGHT_DESKTOP) | 0) + ChessCompStompWithHacksLibrary.PromotionPanel.PIECE_OFFSET_Y_DESKTOP) | 0)) {
                            return null;
                        }
                        if (mouseY1 > ((((((promotionPanelY - ChessCompStompWithHacksLibrary.PromotionPanel.PROMOTION_PANEL_HEIGHT_DESKTOP) | 0) + ChessCompStompWithHacksLibrary.PromotionPanel.PIECE_OFFSET_Y_DESKTOP) | 0) + imageHeight1) | 0)) {
                            return null;
                        }

                        var mouseXRelativeToPanel1 = (mouseX1 - promotionPanelX) | 0;

                        if (ChessCompStompWithHacksLibrary.PromotionPanel.QUEEN_OFFSET_X_DESKTOP <= mouseXRelativeToPanel1 && mouseXRelativeToPanel1 <= ((ChessCompStompWithHacksLibrary.PromotionPanel.QUEEN_OFFSET_X_DESKTOP + imageWidth1) | 0)) {
                            return ChessCompStompWithHacksEngine.Move.PromotionType.PromoteToQueen;
                        }
                        if (ChessCompStompWithHacksLibrary.PromotionPanel.ROOK_OFFSET_X_DESKTOP <= mouseXRelativeToPanel1 && mouseXRelativeToPanel1 <= ((ChessCompStompWithHacksLibrary.PromotionPanel.ROOK_OFFSET_X_DESKTOP + imageWidth1) | 0)) {
                            return ChessCompStompWithHacksEngine.Move.PromotionType.PromoteToRook;
                        }
                        if (ChessCompStompWithHacksLibrary.PromotionPanel.KNIGHT_OFFSET_X_DESKTOP <= mouseXRelativeToPanel1 && mouseXRelativeToPanel1 <= ((ChessCompStompWithHacksLibrary.PromotionPanel.KNIGHT_OFFSET_X_DESKTOP + imageWidth1) | 0)) {
                            return ChessCompStompWithHacksEngine.Move.PromotionType.PromoteToKnight;
                        }
                        if (ChessCompStompWithHacksLibrary.PromotionPanel.BISHOP_OFFSET_X_DESKTOP <= mouseXRelativeToPanel1 && mouseXRelativeToPanel1 <= ((ChessCompStompWithHacksLibrary.PromotionPanel.BISHOP_OFFSET_X_DESKTOP + imageWidth1) | 0)) {
                            return ChessCompStompWithHacksEngine.Move.PromotionType.PromoteToBishop;
                        }
                        return null;
                    }
                },
                IsHoverOverPanel: function (promotionPanelX, promotionPanelY, mouse, isMobileDisplayType) {
                    var mouseX = mouse.DTLibrary$IMouse$GetX();
                    var mouseY = mouse.DTLibrary$IMouse$GetY();

                    var panelWidth = isMobileDisplayType ? ChessCompStompWithHacksLibrary.PromotionPanel.PROMOTION_PANEL_WIDTH_MOBILE : ChessCompStompWithHacksLibrary.PromotionPanel.PROMOTION_PANEL_WIDTH_DESKTOP;
                    var panelHeight = isMobileDisplayType ? ChessCompStompWithHacksLibrary.PromotionPanel.PROMOTION_PANEL_HEIGHT_MOBILE : ChessCompStompWithHacksLibrary.PromotionPanel.PROMOTION_PANEL_HEIGHT_DESKTOP;

                    if (mouseX < promotionPanelX) {
                        return false;
                    }
                    if (mouseX > ((promotionPanelX + panelWidth) | 0)) {
                        return false;
                    }
                    if (mouseY < ((promotionPanelY - panelHeight) | 0)) {
                        return false;
                    }
                    if (mouseY > promotionPanelY) {
                        return false;
                    }
                    return true;
                },
                GetXOffset: function (promotionType, isMobileDisplayType) {
                    switch (promotionType) {
                        case ChessCompStompWithHacksEngine.Move.PromotionType.PromoteToQueen: 
                            return isMobileDisplayType ? ChessCompStompWithHacksLibrary.PromotionPanel.QUEEN_OFFSET_X_MOBILE : ChessCompStompWithHacksLibrary.PromotionPanel.QUEEN_OFFSET_X_DESKTOP;
                        case ChessCompStompWithHacksEngine.Move.PromotionType.PromoteToRook: 
                            return isMobileDisplayType ? ChessCompStompWithHacksLibrary.PromotionPanel.ROOK_OFFSET_X_MOBILE : ChessCompStompWithHacksLibrary.PromotionPanel.ROOK_OFFSET_X_DESKTOP;
                        case ChessCompStompWithHacksEngine.Move.PromotionType.PromoteToKnight: 
                            return isMobileDisplayType ? ChessCompStompWithHacksLibrary.PromotionPanel.KNIGHT_OFFSET_X_MOBILE : ChessCompStompWithHacksLibrary.PromotionPanel.KNIGHT_OFFSET_X_DESKTOP;
                        case ChessCompStompWithHacksEngine.Move.PromotionType.PromoteToBishop: 
                            return isMobileDisplayType ? ChessCompStompWithHacksLibrary.PromotionPanel.BISHOP_OFFSET_X_MOBILE : ChessCompStompWithHacksLibrary.PromotionPanel.BISHOP_OFFSET_X_DESKTOP;
                        default: 
                            throw new System.Exception();
                    }
                }
            }
        },
        fields: {
            isWhite: false,
            isOpen: false,
            x: 0,
            y: 0,
            hoverSquare: null,
            selectedSquare: null,
            colorTheme: 0
        },
        ctors: {
            ctor: function (isWhite, isOpen, x, y, hoverSquare, selectedSquare, colorTheme) {
                this.$initialize();
                this.isWhite = isWhite;
                this.isOpen = isOpen;
                this.x = x;
                this.y = y;
                this.hoverSquare = hoverSquare;
                this.selectedSquare = selectedSquare;
                this.colorTheme = colorTheme;
            }
        },
        methods: {
            ProcessFrame: function (isOpen, x, y, hoverSquare, selectedSquare) {
                return new ChessCompStompWithHacksLibrary.PromotionPanel(this.isWhite, isOpen, x, y, hoverSquare, selectedSquare, this.colorTheme);
            },
            Render: function (displayOutput, isMobileDisplayType) {
                if (!this.isOpen) {
                    return;
                }

                var chessPieceScalingFactor = isMobileDisplayType ? ChessCompStompWithHacksLibrary.GameImageUtil.MobileChessPieceScalingFactor : ChessCompStompWithHacksLibrary.GameImageUtil.DesktopChessPieceScalingFactor;

                var imageWidth = (Bridge.Int.div(Bridge.Int.mul(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetWidth(ChessCompStompWithHacksLibrary.GameImage.WhitePawn), chessPieceScalingFactor), 128)) | 0;
                var imageHeight = (Bridge.Int.div(Bridge.Int.mul(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetHeight(ChessCompStompWithHacksLibrary.GameImage.WhitePawn), chessPieceScalingFactor), 128)) | 0;

                var panelWidth;
                var panelHeight;
                var queenOffsetX;
                var rookOffsetX;
                var knightOffsetX;
                var bishopOffsetX;
                var pieceOffsetY;

                if (isMobileDisplayType) {
                    panelWidth = ChessCompStompWithHacksLibrary.PromotionPanel.PROMOTION_PANEL_WIDTH_MOBILE;
                    panelHeight = ChessCompStompWithHacksLibrary.PromotionPanel.PROMOTION_PANEL_HEIGHT_MOBILE;
                    queenOffsetX = ChessCompStompWithHacksLibrary.PromotionPanel.QUEEN_OFFSET_X_MOBILE;
                    rookOffsetX = ChessCompStompWithHacksLibrary.PromotionPanel.ROOK_OFFSET_X_MOBILE;
                    knightOffsetX = ChessCompStompWithHacksLibrary.PromotionPanel.KNIGHT_OFFSET_X_MOBILE;
                    bishopOffsetX = ChessCompStompWithHacksLibrary.PromotionPanel.BISHOP_OFFSET_X_MOBILE;
                    pieceOffsetY = ChessCompStompWithHacksLibrary.PromotionPanel.PIECE_OFFSET_Y_MOBILE;
                } else {
                    panelWidth = ChessCompStompWithHacksLibrary.PromotionPanel.PROMOTION_PANEL_WIDTH_DESKTOP;
                    panelHeight = ChessCompStompWithHacksLibrary.PromotionPanel.PROMOTION_PANEL_HEIGHT_DESKTOP;
                    queenOffsetX = ChessCompStompWithHacksLibrary.PromotionPanel.QUEEN_OFFSET_X_DESKTOP;
                    rookOffsetX = ChessCompStompWithHacksLibrary.PromotionPanel.ROOK_OFFSET_X_DESKTOP;
                    knightOffsetX = ChessCompStompWithHacksLibrary.PromotionPanel.KNIGHT_OFFSET_X_DESKTOP;
                    bishopOffsetX = ChessCompStompWithHacksLibrary.PromotionPanel.BISHOP_OFFSET_X_DESKTOP;
                    pieceOffsetY = ChessCompStompWithHacksLibrary.PromotionPanel.PIECE_OFFSET_Y_DESKTOP;
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(this.x, ((this.y - panelHeight) | 0), panelWidth, panelHeight, ChessCompStompWithHacksLibrary.ColorThemeUtil.GetTextBackgroundColor(this.colorTheme), true);

                if (isMobileDisplayType) {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((this.x + 126) | 0), ((this.y - 10) | 0), "Promote to:", ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());
                } else {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((this.x + 90) | 0), ((this.y - 10) | 0), "Promote to:", ChessCompStompWithHacksLibrary.GameFont.GameFont14Pt, DTLibrary.DTColor.Black());
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawImageRotatedClockwise$1(this.isWhite ? ChessCompStompWithHacksLibrary.GameImage.WhiteQueen : ChessCompStompWithHacksLibrary.GameImage.BlackQueen, ((this.x + queenOffsetX) | 0), ((((this.y - panelHeight) | 0) + pieceOffsetY) | 0), 0, chessPieceScalingFactor);
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawImageRotatedClockwise$1(this.isWhite ? ChessCompStompWithHacksLibrary.GameImage.WhiteRook : ChessCompStompWithHacksLibrary.GameImage.BlackRook, ((this.x + rookOffsetX) | 0), ((((this.y - panelHeight) | 0) + pieceOffsetY) | 0), 0, chessPieceScalingFactor);
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawImageRotatedClockwise$1(this.isWhite ? ChessCompStompWithHacksLibrary.GameImage.WhiteKnight : ChessCompStompWithHacksLibrary.GameImage.BlackKnight, ((this.x + knightOffsetX) | 0), ((((this.y - panelHeight) | 0) + pieceOffsetY) | 0), 0, chessPieceScalingFactor);
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawImageRotatedClockwise$1(this.isWhite ? ChessCompStompWithHacksLibrary.GameImage.WhiteBishop : ChessCompStompWithHacksLibrary.GameImage.BlackBishop, ((this.x + bishopOffsetX) | 0), ((((this.y - panelHeight) | 0) + pieceOffsetY) | 0), 0, chessPieceScalingFactor);

                if (!isMobileDisplayType) {
                    if (this.hoverSquare != null && (this.selectedSquare == null || System.Nullable.getValue(this.selectedSquare) !== System.Nullable.getValue(this.hoverSquare))) {
                        var hoverXOffset = ChessCompStompWithHacksLibrary.PromotionPanel.GetXOffset(System.Nullable.getValue(this.hoverSquare), isMobileDisplayType);

                        displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(((this.x + hoverXOffset) | 0), ((((this.y - panelHeight) | 0) + pieceOffsetY) | 0), imageWidth, imageHeight, new DTLibrary.DTColor.$ctor1(0, 0, 128, 50), true);
                    }
                }

                if (this.selectedSquare != null) {
                    var selectedXOffset = ChessCompStompWithHacksLibrary.PromotionPanel.GetXOffset(System.Nullable.getValue(this.selectedSquare), isMobileDisplayType);

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(((this.x + selectedXOffset) | 0), ((((this.y - panelHeight) | 0) + pieceOffsetY) | 0), imageWidth, imageHeight, new DTLibrary.DTColor.$ctor1(0, 0, 170, 150), true);
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.SaveAndLoadData", {
        fields: {
            sessionStateByteList: null,
            soundVolume: null,
            musicVolume: null,
            fileIO: null,
            versionInfo: null
        },
        ctors: {
            ctor: function (fileIO, versionInfo) {
                this.$initialize();
                this.fileIO = fileIO;
                this.versionInfo = versionInfo;

                this.sessionStateByteList = null;
                this.soundVolume = null;
                this.musicVolume = null;
            }
        },
        methods: {
            SaveData: function (sessionState, soundVolume, musicVolume) {
                this.SaveSessionState(sessionState);

                this.SaveSoundAndMusicVolume(soundVolume, musicVolume);
            },
            SaveSoundAndMusicVolume: function (soundVolume, musicVolume) {
                if (System.Nullable.hasValue(this.soundVolume) && System.Nullable.hasValue(this.musicVolume) && System.Nullable.getValue(this.soundVolume) === soundVolume && System.Nullable.getValue(this.musicVolume) === musicVolume) {
                    return;
                }

                this.soundVolume = soundVolume;
                this.musicVolume = musicVolume;

                var listBuilder = new DTLibrary.ByteList.Builder();

                listBuilder.AddInt(soundVolume);
                listBuilder.AddInt(musicVolume);

                this.fileIO.DTLibrary$IFileIO$PersistData(ChessCompStompWithHacksLibrary.GlobalConstants.FILE_ID_FOR_SOUND_AND_MUSIC_VOLUME, this.versionInfo, listBuilder.ToByteList());
            },
            SaveSessionState: function (sessionState) {
                var listBuilder = new DTLibrary.ByteList.Builder();
                sessionState.SerializeEverythingExceptGameLogic(listBuilder);

                var byteList = listBuilder.ToByteList();

                if (this.sessionStateByteList != null && this.sessionStateByteList.equalsT(byteList)) {
                    return;
                }

                this.sessionStateByteList = byteList;

                this.fileIO.DTLibrary$IFileIO$PersistData(ChessCompStompWithHacksLibrary.GlobalConstants.FILE_ID_FOR_SESSION_STATE, this.versionInfo, this.sessionStateByteList);
            },
            LoadSessionState: function (sessionState) {
                var list = this.fileIO.DTLibrary$IFileIO$FetchData(ChessCompStompWithHacksLibrary.GlobalConstants.FILE_ID_FOR_SESSION_STATE, this.versionInfo);

                if (list == null) {
                    sessionState.ClearData();
                    return;
                }

                try {
                    var iterator = list.GetIterator();
                    sessionState.TryDeserializeEverythingExceptGameLogic(iterator);

                    if (iterator.HasNextByte()) {
                        throw new DTLibrary.DTDeserializationException();
                    }
                } catch ($e1) {
                    $e1 = System.Exception.create($e1);
                    if (Bridge.is($e1, DTLibrary.DTDeserializationException)) {
                        sessionState.ClearData();
                    } else {
                        throw $e1;
                    }
                }
            },
            LoadSoundVolume: function () {
                var list = this.fileIO.DTLibrary$IFileIO$FetchData(ChessCompStompWithHacksLibrary.GlobalConstants.FILE_ID_FOR_SOUND_AND_MUSIC_VOLUME, this.versionInfo);

                if (list == null) {
                    return null;
                }

                try {
                    var iterator = list.GetIterator();
                    var soundVolume = iterator.TryPopInt();
                    iterator.TryPopInt();
                    if (iterator.HasNextByte()) {
                        throw new DTLibrary.DTDeserializationException();
                    }

                    if (soundVolume >= 0 && soundVolume <= 100) {
                        return soundVolume;
                    }
                    return null;
                } catch ($e1) {
                    $e1 = System.Exception.create($e1);
                    if (Bridge.is($e1, DTLibrary.DTDeserializationException)) {
                        return null;
                    } else {
                        throw $e1;
                    }
                }
            },
            LoadMusicVolume: function () {
                var list = this.fileIO.DTLibrary$IFileIO$FetchData(ChessCompStompWithHacksLibrary.GlobalConstants.FILE_ID_FOR_SOUND_AND_MUSIC_VOLUME, this.versionInfo);

                if (list == null) {
                    return null;
                }

                try {
                    var iterator = list.GetIterator();

                    iterator.TryPopInt();
                    var musicVolume = iterator.TryPopInt();
                    if (iterator.HasNextByte()) {
                        throw new DTLibrary.DTDeserializationException();
                    }

                    if (musicVolume >= 0 && musicVolume <= 100) {
                        return musicVolume;
                    }
                    return null;
                } catch ($e1) {
                    $e1 = System.Exception.create($e1);
                    if (Bridge.is($e1, DTLibrary.DTDeserializationException)) {
                        return null;
                    } else {
                        throw $e1;
                    }
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.SavedDataMigration_ToV1_01", {
        statics: {
            methods: {
                MigrateSessionStateDataFromOlderVersionsToV1_01IfNeeded: function (fileIO) { },
                MigrateSoundAndMusicVolumeDataFromOlderVersionsToV1_01IfNeeded: function (fileIO) { }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.SavedDataMigration_ToV1_02", {
        statics: {
            methods: {
                MigrateSessionStateDataFromOlderVersionsToV1_02IfNeeded: function (fileIO) {
                    var versionHistory = ChessCompStompWithHacksLibrary.VersionHistory.GetVersionHistory();

                    var version1_01 = System.Linq.Enumerable.from(versionHistory).single(function (x) {
                            return Bridge.referenceEquals(x.Version, "1.01");
                        });
                    var version1_02 = System.Linq.Enumerable.from(versionHistory).single(function (x) {
                            return Bridge.referenceEquals(x.Version, "1.02");
                        });

                    var data1_02 = fileIO.DTLibrary$IFileIO$FetchData(ChessCompStompWithHacksLibrary.GlobalConstants.FILE_ID_FOR_SESSION_STATE, version1_02);
                    if (data1_02 != null) {
                        return;
                    }

                    ChessCompStompWithHacksLibrary.SavedDataMigration_ToV1_01.MigrateSessionStateDataFromOlderVersionsToV1_01IfNeeded(fileIO);

                    var data1_01 = fileIO.DTLibrary$IFileIO$FetchData(ChessCompStompWithHacksLibrary.GlobalConstants.FILE_ID_FOR_SESSION_STATE, version1_01);

                    if (data1_01 != null) {
                        fileIO.DTLibrary$IFileIO$PersistData(ChessCompStompWithHacksLibrary.GlobalConstants.FILE_ID_FOR_SESSION_STATE, version1_02, data1_01);
                    }
                },
                MigrateSoundAndMusicVolumeDataFromOlderVersionsToV1_02IfNeeded: function (fileIO) {
                    var versionHistory = ChessCompStompWithHacksLibrary.VersionHistory.GetVersionHistory();

                    var version1_01 = System.Linq.Enumerable.from(versionHistory).single(function (x) {
                            return Bridge.referenceEquals(x.Version, "1.01");
                        });
                    var version1_02 = System.Linq.Enumerable.from(versionHistory).single(function (x) {
                            return Bridge.referenceEquals(x.Version, "1.02");
                        });

                    var data1_02 = fileIO.DTLibrary$IFileIO$FetchData(ChessCompStompWithHacksLibrary.GlobalConstants.FILE_ID_FOR_SOUND_AND_MUSIC_VOLUME, version1_02);
                    if (data1_02 != null) {
                        return;
                    }

                    ChessCompStompWithHacksLibrary.SavedDataMigration_ToV1_01.MigrateSoundAndMusicVolumeDataFromOlderVersionsToV1_01IfNeeded(fileIO);

                    var data1_01 = fileIO.DTLibrary$IFileIO$FetchData(ChessCompStompWithHacksLibrary.GlobalConstants.FILE_ID_FOR_SOUND_AND_MUSIC_VOLUME, version1_01);

                    if (data1_01 != null) {
                        fileIO.DTLibrary$IFileIO$PersistData(ChessCompStompWithHacksLibrary.GlobalConstants.FILE_ID_FOR_SOUND_AND_MUSIC_VOLUME, version1_02, data1_01);
                    }
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.SavedDataMigration_ToV1_03", {
        statics: {
            methods: {
                MigrateAllDataFromOlderVersionsToV1_03IfNeeded: function (fileIO) {
                    ChessCompStompWithHacksLibrary.SavedDataMigration_ToV1_03.MigrateSessionStateDataFromOlderVersionsToV1_03IfNeeded(fileIO);
                    ChessCompStompWithHacksLibrary.SavedDataMigration_ToV1_03.MigrateSoundAndMusicVolumeDataFromOlderVersionsToV1_03IfNeeded(fileIO);
                },
                MigrateSessionStateDataFromOlderVersionsToV1_03IfNeeded: function (fileIO) {
                    var versionHistory = ChessCompStompWithHacksLibrary.VersionHistory.GetVersionHistory();

                    var version1_02 = System.Linq.Enumerable.from(versionHistory).single(function (x) {
                            return Bridge.referenceEquals(x.Version, "1.02");
                        });
                    var version1_03 = System.Linq.Enumerable.from(versionHistory).single(function (x) {
                            return Bridge.referenceEquals(x.Version, "1.03");
                        });

                    var data1_03 = fileIO.DTLibrary$IFileIO$FetchData(ChessCompStompWithHacksLibrary.GlobalConstants.FILE_ID_FOR_SESSION_STATE, version1_03);

                    if (data1_03 != null) {
                        return;
                    }

                    ChessCompStompWithHacksLibrary.SavedDataMigration_ToV1_02.MigrateSessionStateDataFromOlderVersionsToV1_02IfNeeded(fileIO);

                    var data1_02 = fileIO.DTLibrary$IFileIO$FetchData(ChessCompStompWithHacksLibrary.GlobalConstants.FILE_ID_FOR_SESSION_STATE, version1_02);

                    if (data1_02 != null) {
                        try {
                            var iterator = data1_02.GetIterator();

                            var listBuilder = new DTLibrary.ByteList.Builder();

                            listBuilder.AddNullableLong(iterator.TryPopNullableLong());
                            listBuilder.AddInt(iterator.TryPopInt());
                            listBuilder.AddNullableBool(iterator.TryPopNullableBool());
                            listBuilder.AddBool(iterator.TryPopBool());
                            listBuilder.AddBool(iterator.TryPopBool());
                            listBuilder.AddBool(iterator.TryPopBool());
                            listBuilder.AddIntSet(iterator.TryPopIntSet());
                            listBuilder.AddIntSet(iterator.TryPopIntSet());
                            listBuilder.AddInt(iterator.TryPopInt());
                            listBuilder.AddInt(ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTabUtil.GetTabId(ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTab.Tactics));

                            if (iterator.HasNextByte()) {
                                throw new DTLibrary.DTDeserializationException();
                            }

                            var byteList = listBuilder.ToByteList();

                            fileIO.DTLibrary$IFileIO$PersistData(ChessCompStompWithHacksLibrary.GlobalConstants.FILE_ID_FOR_SESSION_STATE, version1_03, byteList);
                        } catch ($e1) {
                            $e1 = System.Exception.create($e1);
                            if (Bridge.is($e1, DTLibrary.DTDeserializationException)) {
                            } else {
                                throw $e1;
                            }
                        }
                    }
                },
                MigrateSoundAndMusicVolumeDataFromOlderVersionsToV1_03IfNeeded: function (fileIO) {
                    var versionHistory = ChessCompStompWithHacksLibrary.VersionHistory.GetVersionHistory();

                    var version1_02 = System.Linq.Enumerable.from(versionHistory).single(function (x) {
                            return Bridge.referenceEquals(x.Version, "1.02");
                        });
                    var version1_03 = System.Linq.Enumerable.from(versionHistory).single(function (x) {
                            return Bridge.referenceEquals(x.Version, "1.03");
                        });

                    var data1_03 = fileIO.DTLibrary$IFileIO$FetchData(ChessCompStompWithHacksLibrary.GlobalConstants.FILE_ID_FOR_SOUND_AND_MUSIC_VOLUME, version1_03);
                    if (data1_03 != null) {
                        return;
                    }

                    ChessCompStompWithHacksLibrary.SavedDataMigration_ToV1_02.MigrateSoundAndMusicVolumeDataFromOlderVersionsToV1_02IfNeeded(fileIO);

                    var data1_02 = fileIO.DTLibrary$IFileIO$FetchData(ChessCompStompWithHacksLibrary.GlobalConstants.FILE_ID_FOR_SOUND_AND_MUSIC_VOLUME, version1_02);

                    if (data1_02 != null) {
                        fileIO.DTLibrary$IFileIO$PersistData(ChessCompStompWithHacksLibrary.GlobalConstants.FILE_ID_FOR_SOUND_AND_MUSIC_VOLUME, version1_03, data1_02);
                    }
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ScrollableTextDisplay", {
        statics: {
            fields: {
                WIDTH_OF_ARROW: 0,
                HEIGHT_OF_ARROW: 0
            },
            ctors: {
                init: function () {
                    this.WIDTH_OF_ARROW = 25;
                    this.HEIGHT_OF_ARROW = 25;
                }
            }
        },
        fields: {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            lineHeightInPixels: 0,
            maxLinesOfTextToRender: 0,
            font: 0,
            color: null,
            lineIndexToPixelOffsetMapping: null,
            heightOfScrollBar: 0,
            textLines: null,
            indexOfFirstLineToRender: 0,
            clickedScrollBar: false,
            clickedMouseY: 0,
            clickedScrollBarPixelOffset: 0
        },
        ctors: {
            ctor: function (x, y, width, height, lineHeightInPixels, maxLinesOfTextToRender, font, color, text) {
                var $t;
                this.$initialize();
                this.maxLinesOfTextToRender = maxLinesOfTextToRender;

                this.textLines = new (System.Collections.Generic.List$1(System.String)).ctor();

                var textArray = System.String.split(text, [10].map(function (i) {{ return String.fromCharCode(i); }}));
                $t = Bridge.getEnumerator(textArray);
                try {
                    while ($t.moveNext()) {
                        var str = $t.Current;
                        this.textLines.add(str);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                if (this.textLines.Count > maxLinesOfTextToRender) {
                    this.height = Math.max(height, 60);

                    this.lineIndexToPixelOffsetMapping = new (System.Collections.Generic.Dictionary$2(System.Int32,System.Int32))();

                    var lineIndex = 0;
                    while (true) {
                        if (lineIndex > ((this.textLines.Count - maxLinesOfTextToRender) | 0)) {
                            break;
                        }

                        this.lineIndexToPixelOffsetMapping.set(lineIndex, (Bridge.Int.div(Bridge.Int.mul(lineIndex, (((((this.height - ChessCompStompWithHacksLibrary.ScrollableTextDisplay.HEIGHT_OF_ARROW) | 0) - ChessCompStompWithHacksLibrary.ScrollableTextDisplay.HEIGHT_OF_ARROW) | 0))), this.textLines.Count)) | 0);

                        lineIndex = (lineIndex + 1) | 0;
                    }

                    this.heightOfScrollBar = (Bridge.Int.div(Bridge.Int.mul(maxLinesOfTextToRender, (((((this.height - ChessCompStompWithHacksLibrary.ScrollableTextDisplay.HEIGHT_OF_ARROW) | 0) - ChessCompStompWithHacksLibrary.ScrollableTextDisplay.HEIGHT_OF_ARROW) | 0))), this.textLines.Count)) | 0;
                } else {
                    this.height = height;

                    this.lineIndexToPixelOffsetMapping = new (System.Collections.Generic.Dictionary$2(System.Int32,System.Int32))();
                    this.lineIndexToPixelOffsetMapping.set(0, 0);

                    this.heightOfScrollBar = 0;
                }

                this.indexOfFirstLineToRender = 0;

                this.clickedScrollBar = false;
                this.clickedMouseY = 0;
                this.clickedScrollBarPixelOffset = 0;

                this.x = x;
                this.y = y;
                this.width = width;
                this.lineHeightInPixels = lineHeightInPixels;
                this.font = font;
                this.color = color;
            }
        },
        methods: {
            ProcessFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput) {
                var $t;
                if (this.textLines.Count > this.maxLinesOfTextToRender) {
                    var mouseX = mouseInput.DTLibrary$IMouse$GetX();
                    var mouseY = mouseInput.DTLibrary$IMouse$GetY();

                    var isHoverOverScrollAreaX = ((((this.x + this.width) | 0) - ChessCompStompWithHacksLibrary.ScrollableTextDisplay.WIDTH_OF_ARROW) | 0) <= mouseX && mouseX <= ((this.x + this.width) | 0);

                    var topOfScrollBarY = (((((this.y + this.height) | 0) - ChessCompStompWithHacksLibrary.ScrollableTextDisplay.HEIGHT_OF_ARROW) | 0) - this.lineIndexToPixelOffsetMapping.get(this.indexOfFirstLineToRender)) | 0;
                    var bottomOfScrollBarY = (topOfScrollBarY - this.heightOfScrollBar) | 0;

                    if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && isHoverOverScrollAreaX && bottomOfScrollBarY <= mouseY && mouseY <= topOfScrollBarY) {
                        this.clickedScrollBar = true;
                        this.clickedMouseY = mouseY;
                        this.clickedScrollBarPixelOffset = this.lineIndexToPixelOffsetMapping.get(this.indexOfFirstLineToRender);
                    }

                    if (this.clickedScrollBar) {
                        if (!mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                            this.clickedScrollBar = false;
                        } else {
                            var scrollBarPixelOffsetOverride = (this.clickedScrollBarPixelOffset - (((mouseY - this.clickedMouseY) | 0))) | 0;

                            var bestLineIndex = this.indexOfFirstLineToRender;
                            var bestDelta = Math.abs(((this.lineIndexToPixelOffsetMapping.get(bestLineIndex) - scrollBarPixelOffsetOverride) | 0));

                            $t = Bridge.getEnumerator(System.Linq.Enumerable.from(this.lineIndexToPixelOffsetMapping).orderBy(function (x) {
                                    return x.key;
                                }));
                            try {
                                while ($t.moveNext()) {
                                    var mapping = $t.Current;
                                    var delta = Math.abs(((mapping.value - scrollBarPixelOffsetOverride) | 0));
                                    if (delta < bestDelta) {
                                        bestDelta = delta;
                                        bestLineIndex = mapping.key;
                                    }
                                }
                            } finally {
                                if (Bridge.is($t, System.IDisposable)) {
                                    $t.System$IDisposable$Dispose();
                                }
                            }

                            this.indexOfFirstLineToRender = bestLineIndex;
                        }
                    }

                    if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.DownArrow) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.DownArrow)) {
                        this.indexOfFirstLineToRender = (this.indexOfFirstLineToRender + 1) | 0;
                    }

                    if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.UpArrow) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.UpArrow)) {
                        this.indexOfFirstLineToRender = (this.indexOfFirstLineToRender - 1) | 0;
                    }

                    if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && isHoverOverScrollAreaX && this.y <= mouseY && mouseY < ((this.y + ChessCompStompWithHacksLibrary.ScrollableTextDisplay.HEIGHT_OF_ARROW) | 0)) {
                        this.indexOfFirstLineToRender = (this.indexOfFirstLineToRender + 1) | 0;
                    }

                    if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && isHoverOverScrollAreaX && ((((this.y + this.height) | 0) - ChessCompStompWithHacksLibrary.ScrollableTextDisplay.HEIGHT_OF_ARROW) | 0) < mouseY && mouseY <= ((this.y + this.height) | 0)) {
                        this.indexOfFirstLineToRender = (this.indexOfFirstLineToRender - 1) | 0;
                    }

                    if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && isHoverOverScrollAreaX && ((this.y + ChessCompStompWithHacksLibrary.ScrollableTextDisplay.HEIGHT_OF_ARROW) | 0) < mouseY && mouseY < bottomOfScrollBarY) {
                        this.indexOfFirstLineToRender = (this.indexOfFirstLineToRender + this.maxLinesOfTextToRender) | 0;
                    }

                    if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && isHoverOverScrollAreaX && topOfScrollBarY < mouseY && mouseY < ((((this.y + this.height) | 0) - ChessCompStompWithHacksLibrary.ScrollableTextDisplay.HEIGHT_OF_ARROW) | 0)) {
                        this.indexOfFirstLineToRender = (this.indexOfFirstLineToRender - this.maxLinesOfTextToRender) | 0;
                    }

                    if (this.indexOfFirstLineToRender < 0) {
                        this.indexOfFirstLineToRender = 0;
                    }
                    if (this.indexOfFirstLineToRender > ((this.textLines.Count - this.maxLinesOfTextToRender) | 0)) {
                        this.indexOfFirstLineToRender = (this.textLines.Count - this.maxLinesOfTextToRender) | 0;
                    }
                }
            },
            Render: function (displayOutput) {
                var lineIndex = this.indexOfFirstLineToRender;
                var y = (this.y + this.height) | 0;
                for (var i = 0; i < this.maxLinesOfTextToRender; i = (i + 1) | 0) {
                    if (lineIndex >= this.textLines.Count) {
                        break;
                    }

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(this.x, y, this.textLines.getItem(lineIndex), this.font, this.color);

                    y = (y - this.lineHeightInPixels) | 0;
                    lineIndex = (lineIndex + 1) | 0;
                }

                if (this.textLines.Count > this.maxLinesOfTextToRender) {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawImageRotatedClockwise$1(ChessCompStompWithHacksLibrary.GameImage.Up, ((((this.x + this.width) | 0) - ChessCompStompWithHacksLibrary.ScrollableTextDisplay.WIDTH_OF_ARROW) | 0), ((((this.y + this.height) | 0) - ChessCompStompWithHacksLibrary.ScrollableTextDisplay.HEIGHT_OF_ARROW) | 0), 0, 32);

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawImageRotatedClockwise$1(ChessCompStompWithHacksLibrary.GameImage.Down, ((((this.x + this.width) | 0) - ChessCompStompWithHacksLibrary.ScrollableTextDisplay.WIDTH_OF_ARROW) | 0), this.y, 0, 32);

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(((((this.x + this.width) | 0) - ChessCompStompWithHacksLibrary.ScrollableTextDisplay.WIDTH_OF_ARROW) | 0), ((((this.y + ChessCompStompWithHacksLibrary.ScrollableTextDisplay.HEIGHT_OF_ARROW) | 0) + 1) | 0), ChessCompStompWithHacksLibrary.ScrollableTextDisplay.WIDTH_OF_ARROW, (((((((((this.height - ChessCompStompWithHacksLibrary.ScrollableTextDisplay.HEIGHT_OF_ARROW) | 0) - ChessCompStompWithHacksLibrary.ScrollableTextDisplay.HEIGHT_OF_ARROW) | 0) - 1) | 0)) - 1) | 0), DTLibrary.DTColor.Black(), false);

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(((((this.x + this.width) | 0) - ChessCompStompWithHacksLibrary.ScrollableTextDisplay.WIDTH_OF_ARROW) | 0), ((((((((this.y + this.height) | 0) - ChessCompStompWithHacksLibrary.ScrollableTextDisplay.HEIGHT_OF_ARROW) | 0) - this.lineIndexToPixelOffsetMapping.get(this.indexOfFirstLineToRender)) | 0) - this.heightOfScrollBar) | 0), ChessCompStompWithHacksLibrary.ScrollableTextDisplay.WIDTH_OF_ARROW, this.heightOfScrollBar, DTLibrary.DTColor.Black(), true);
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.SessionState", {
        statics: {
            fields: {
                NUMBER_OF_HACK_POINTS_PER_WIN: 0,
                NUMBER_OF_HACK_POINTS_PER_OBJECTIVE: 0
            },
            ctors: {
                init: function () {
                    this.NUMBER_OF_HACK_POINTS_PER_WIN = 5;
                    this.NUMBER_OF_HACK_POINTS_PER_OBJECTIVE = 10;
                }
            }
        },
        fields: {
            timer: null,
            data: null
        },
        props: {
            HasStarted: {
                get: function () {
                    return System.Nullable.liftne("ne", this.data.StartTime, System.Int64.lift(null));
                }
            }
        },
        ctors: {
            ctor: function (timer) {
                this.$initialize();
                this.timer = timer;
                this.data = new ChessCompStompWithHacksLibrary.SessionState.Data();
            }
        },
        methods: {
            SerializeEverythingExceptGameLogic: function (list) {
                this.data.SerializeEverythingExceptGameLogic(list);
            },
            /**
             * Can possibly throw DTDeserializationException
             *
             * @instance
             * @public
             * @this ChessCompStompWithHacksLibrary.SessionState
             * @memberof ChessCompStompWithHacksLibrary.SessionState
             * @param   {DTLibrary.ByteList.Iterator}    iterator
             * @return  {void}
             */
            TryDeserializeEverythingExceptGameLogic: function (iterator) {
                var data = ChessCompStompWithHacksLibrary.SessionState.Data.TryDeserializeEverythingExceptGameLogic(iterator);
                this.data = data;
            },
            ClearData: function () {
                this.data = new ChessCompStompWithHacksLibrary.SessionState.Data();
            },
            Debug_AddWin: function () {
                if (this.data.NumberOfWins < ChessCompStompWithHacksLibrary.SessionState.Data.MAX_NUMBER_OF_WINS) {
                    this.data.NumberOfWins = (this.data.NumberOfWins + 1) | 0;
                }
            },
            GetGameLogic: function () {
                return this.data.GameLogic;
            },
            GetMostRecentGameLogic: function () {
                return this.data.MostRecentGameLogic;
            },
            GetColorTheme: function () {
                return this.data.ColorTheme;
            },
            /**
             * Returns true iff at least one objective was actually newly completed
             *
             * @instance
             * @public
             * @this ChessCompStompWithHacksLibrary.SessionState
             * @memberof ChessCompStompWithHacksLibrary.SessionState
             * @param   {System.Collections.Generic.HashSet$1}    completedObjectives
             * @return  {boolean}
             */
            AddCompletedObjectives: function (completedObjectives) {
                var $t;
                var hasCompletedANewObjective = false;

                $t = Bridge.getEnumerator(completedObjectives);
                try {
                    while ($t.moveNext()) {
                        var completedObjective = $t.Current;
                        var didAdd = this.data.CompletedObjectives.add(completedObjective);

                        if (didAdd) {
                            hasCompletedANewObjective = true;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                return hasCompletedANewObjective;
            },
            GetCompletedObjectives: function () {
                return new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.Objective)).$ctor1(this.data.CompletedObjectives);
            },
            GetCompletedAchievements: function () {
                var numberOfCompletedObjectives = this.data.CompletedObjectives.Count;

                var completedAchievements = new (System.Collections.Generic.HashSet$1(System.String)).ctor();

                if (numberOfCompletedObjectives >= 1) {
                    completedAchievements.add("completed_1_objective");
                }

                for (var i = 2; i <= numberOfCompletedObjectives; i = (i + 1) | 0) {
                    completedAchievements.add("completed_" + (DTLibrary.StringUtil.ToStringCultureInvariant(i) || "") + "_objectives");
                }

                return completedAchievements;
            },
            GetObjectivesThatWereAlreadyCompletedPriorToCurrentGame: function () {
                return new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.Objective)).$ctor1(this.data.ObjectivesThatWereAlreadyCompletedPriorToCurrentGame);
            },
            StartNewSession: function () {
                this.data.StartTime = this.timer.DTLibrary$ITimer$GetNumberOfMicroSeconds();
            },
            GetResearchedHacks: function () {
                return new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.Hack)).$ctor1(this.data.ResearchedHacks);
            },
            AddResearchedHack: function (hack) {
                this.data.ResearchedHacks.add(hack);
            },
            GetHackSelectionScreenMobileTab: function () {
                return this.data.HackSelectionScreenMobileTab;
            },
            SetHackSelectionScreenMobileTab: function (tab) {
                this.data.HackSelectionScreenMobileTab = tab;
            },
            /**
             * Includes both used and unused hack points
             *
             * @instance
             * @public
             * @this ChessCompStompWithHacksLibrary.SessionState
             * @memberof ChessCompStompWithHacksLibrary.SessionState
             * @return  {number}
             */
            GetTotalNumberOfHackPoints: function () {
                var initialNumberOfHackPoints = 10;

                var numberOfPointsFromWins = Bridge.Int.mul(this.data.NumberOfWins, ChessCompStompWithHacksLibrary.SessionState.NUMBER_OF_HACK_POINTS_PER_WIN);

                var numberOfPointsFromObjectives;

                if (this.data.CompletedObjectives.contains(ChessCompStompWithHacksEngine.Objective.WinFinalBattle)) {
                    numberOfPointsFromObjectives = Bridge.Int.mul((((this.data.CompletedObjectives.Count - 1) | 0)), ChessCompStompWithHacksLibrary.SessionState.NUMBER_OF_HACK_POINTS_PER_OBJECTIVE);
                } else {
                    numberOfPointsFromObjectives = Bridge.Int.mul(this.data.CompletedObjectives.Count, ChessCompStompWithHacksLibrary.SessionState.NUMBER_OF_HACK_POINTS_PER_OBJECTIVE);
                }

                return ((((initialNumberOfHackPoints + numberOfPointsFromWins) | 0) + numberOfPointsFromObjectives) | 0);
            },
            GetUnusedHackPoints: function () {
                var $t;
                var points = this.GetTotalNumberOfHackPoints();
                $t = Bridge.getEnumerator(this.data.ResearchedHacks);
                try {
                    while ($t.moveNext()) {
                        var hack = $t.Current;
                        points = (points - ChessCompStompWithHacksLibrary.HackUtil.GetHackCost(hack)) | 0;
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                return points;
            },
            ResetResearchedHacks: function () {
                this.data.ResearchedHacks = new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.Hack)).ctor();
            },
            HasShownFinalBattleVictoryPanel: function () {
                return this.data.HasShownFinalBattleVictoryPanel;
            },
            SetShownFinalBattleVictoryPanel: function () {
                this.data.HasShownFinalBattleVictoryPanel = true;
            },
            CompleteGame: function (didPlayerWin) {
                if (didPlayerWin) {
                    if (this.data.NumberOfWins < ChessCompStompWithHacksLibrary.SessionState.Data.MAX_NUMBER_OF_WINS) {
                        this.data.NumberOfWins = (this.data.NumberOfWins + 1) | 0;
                    }
                }

                this.data.MostRecentGameLogic = this.data.GameLogic;
                this.data.GameLogic = null;
            },
            WillPlayerBeWhiteNextGame: function () {
                if (this.data.WasPlayerWhiteInPreviousGame == null) {
                    return true;
                }
                return !System.Nullable.getValue(this.data.WasPlayerWhiteInPreviousGame);
            },
            StartGame: function (isFinalBattle, globalState, aiHackLevelOverride, display, isMobileDisplayType) {
                this.data.ObjectivesThatWereAlreadyCompletedPriorToCurrentGame = new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.Objective)).$ctor1(this.data.CompletedObjectives);

                var isPlayerWhite = this.WillPlayerBeWhiteNextGame();

                var displayType = new DTLibrary.DisplayType();

                if (!isMobileDisplayType) {
                    displayType = DTLibrary.DisplayType.Desktop;
                } else {
                    if (DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation(ChessCompStompWithHacksLibrary.GameImage, display)) {
                        displayType = DTLibrary.DisplayType.MobileLandscape;
                    } else {
                        displayType = DTLibrary.DisplayType.MobilePortrait;
                    }
                }

                if (isFinalBattle) {
                    this.data.ColorTheme = ChessCompStompWithHacksLibrary.ColorTheme.Final;

                    this.data.GameLogic = new ChessCompStompWithHacksLibrary.GameLogic(globalState, isPlayerWhite, new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.Hack)).$ctor1(this.data.ResearchedHacks), ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.FinalBattle, this.data.ColorTheme, displayType);
                    this.data.MostRecentGameLogic = this.data.GameLogic;

                    this.data.WasPlayerWhiteInPreviousGame = isPlayerWhite;
                    if (this.data.HasShownFinalBattleMessage) {
                        if (isMobileDisplayType) {
                            return new ChessCompStompWithHacksLibrary.ChessMobileFrame.ctor(globalState, this, display);
                        } else {
                            return new ChessCompStompWithHacksLibrary.ChessDesktopFrame.ctor(globalState, this);
                        }
                    }

                    this.data.HasShownFinalBattleMessage = true;
                    return isMobileDisplayType ? ChessCompStompWithHacksLibrary.AIMessageMobileFrame.GetFinalBattleMessageFrame(globalState, this, display) : ChessCompStompWithHacksLibrary.AIMessageDesktopFrame.GetFinalBattleMessageFrame(globalState, this);
                }

                var aiHackLevel = new ChessCompStompWithHacksLibrary.SessionState.AIHackLevel();

                if (System.Nullable.hasValue(aiHackLevelOverride)) {
                    aiHackLevel = System.Nullable.getValue(aiHackLevelOverride);
                } else if (!this.data.HasShownAIHackMessage && this.data.ResearchedHacks.Count === 0 || this.data.NumberOfWins <= 1) {
                    aiHackLevel = ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.Initial;
                } else if (this.data.NumberOfWins <= 3) {
                    aiHackLevel = ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.UpgradedOnce;
                    if (this.data.ColorTheme === ChessCompStompWithHacksLibrary.ColorTheme.Initial) {
                        this.data.ColorTheme = ChessCompStompWithHacksLibrary.ColorTheme.Progress1;
                    }
                } else if (this.data.NumberOfWins <= 5) {
                    aiHackLevel = ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.UpgradedTwice;
                    if (this.data.ColorTheme === ChessCompStompWithHacksLibrary.ColorTheme.Initial || this.data.ColorTheme === ChessCompStompWithHacksLibrary.ColorTheme.Progress1) {
                        this.data.ColorTheme = ChessCompStompWithHacksLibrary.ColorTheme.Progress2;
                    }
                } else {
                    aiHackLevel = ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.UpgradedThrice;
                    if (this.data.ColorTheme === ChessCompStompWithHacksLibrary.ColorTheme.Initial || this.data.ColorTheme === ChessCompStompWithHacksLibrary.ColorTheme.Progress1 || this.data.ColorTheme === ChessCompStompWithHacksLibrary.ColorTheme.Progress2) {
                        this.data.ColorTheme = ChessCompStompWithHacksLibrary.ColorTheme.Progress3;
                    }
                }

                this.data.GameLogic = new ChessCompStompWithHacksLibrary.GameLogic(globalState, isPlayerWhite, new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.Hack)).$ctor1(this.data.ResearchedHacks), aiHackLevel, this.data.ColorTheme, displayType);
                this.data.MostRecentGameLogic = this.data.GameLogic;

                this.data.WasPlayerWhiteInPreviousGame = isPlayerWhite;

                if (aiHackLevel !== ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.Initial && !this.data.HasShownAIHackMessage) {
                    this.data.HasShownAIHackMessage = true;
                    return isMobileDisplayType ? ChessCompStompWithHacksLibrary.AIMessageMobileFrame.GetAIHackMessageFrame(globalState, this, display) : ChessCompStompWithHacksLibrary.AIMessageDesktopFrame.GetAIHackMessageFrame(globalState, this);
                }

                if (isMobileDisplayType) {
                    return new ChessCompStompWithHacksLibrary.ChessMobileFrame.ctor(globalState, this, display);
                } else {
                    return new ChessCompStompWithHacksLibrary.ChessDesktopFrame.ctor(globalState, this);
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.SessionState.AIHackLevel", {
        $kind: "nested enum",
        statics: {
            fields: {
                Initial: 0,
                UpgradedOnce: 1,
                UpgradedTwice: 2,
                UpgradedThrice: 3,
                FinalBattle: 4
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.SessionState.Data", {
        $kind: "nested class",
        statics: {
            fields: {
                MAX_NUMBER_OF_WINS: 0
            },
            ctors: {
                init: function () {
                    this.MAX_NUMBER_OF_WINS = 50000;
                }
            },
            methods: {
                /**
                 * Can possibly throw DTDeserializationException
                 *
                 * @static
                 * @public
                 * @this ChessCompStompWithHacksLibrary.SessionState.Data
                 * @memberof ChessCompStompWithHacksLibrary.SessionState.Data
                 * @param   {DTLibrary.ByteList.Iterator}                         iterator
                 * @return  {ChessCompStompWithHacksLibrary.SessionState.Data}
                 */
                TryDeserializeEverythingExceptGameLogic: function (iterator) {
                    var $t, $t1;
                    var data = new ChessCompStompWithHacksLibrary.SessionState.Data();

                    data.StartTime = iterator.TryPopNullableLong();

                    data.NumberOfWins = iterator.TryPopInt();

                    if (data.NumberOfWins < 0 || data.NumberOfWins > ChessCompStompWithHacksLibrary.SessionState.Data.MAX_NUMBER_OF_WINS) {
                        throw new DTLibrary.DTDeserializationException();
                    }

                    data.WasPlayerWhiteInPreviousGame = iterator.TryPopNullableBool();

                    data.HasShownAIHackMessage = iterator.TryPopBool();

                    data.HasShownFinalBattleMessage = iterator.TryPopBool();

                    data.HasShownFinalBattleVictoryPanel = iterator.TryPopBool();

                    var researchedHackIds = iterator.TryPopIntSet();

                    if (researchedHackIds == null) {
                        throw new DTLibrary.DTDeserializationException();
                    }

                    data.ResearchedHacks = new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.Hack)).ctor();
                    $t = Bridge.getEnumerator(researchedHackIds);
                    try {
                        while ($t.moveNext()) {
                            var researchedHackId = $t.Current;
                            var hack = ChessCompStompWithHacksLibrary.HackUtil.GetHackFromHackId(researchedHackId);

                            if (hack == null) {
                                throw new DTLibrary.DTDeserializationException();
                            }

                            data.ResearchedHacks.add(System.Nullable.getValue(hack));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    var completedObjectiveIds = iterator.TryPopIntSet();

                    if (completedObjectiveIds == null) {
                        throw new DTLibrary.DTDeserializationException();
                    }

                    data.CompletedObjectives = new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.Objective)).ctor();
                    $t1 = Bridge.getEnumerator(completedObjectiveIds);
                    try {
                        while ($t1.moveNext()) {
                            var completedObjectiveId = $t1.Current;
                            var objective = ChessCompStompWithHacksLibrary.ObjectiveUtil.GetObjectiveFromObjectiveId(completedObjectiveId);

                            if (objective == null) {
                                throw new DTLibrary.DTDeserializationException();
                            }

                            data.CompletedObjectives.add(System.Nullable.getValue(objective));
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }

                    data.ObjectivesThatWereAlreadyCompletedPriorToCurrentGame = new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.Objective)).$ctor1(data.CompletedObjectives);

                    var colorTheme = ChessCompStompWithHacksLibrary.ColorThemeUtil.GetColorThemeFromColorThemeId(iterator.TryPopInt());
                    if (colorTheme == null) {
                        throw new DTLibrary.DTDeserializationException();
                    }

                    data.ColorTheme = System.Nullable.getValue(colorTheme);

                    var tab = ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTabUtil.GetTabFromTabId(iterator.TryPopInt());
                    if (tab == null) {
                        throw new DTLibrary.DTDeserializationException();
                    }

                    data.HackSelectionScreenMobileTab = System.Nullable.getValue(tab);

                    return data;
                }
            }
        },
        fields: {
            /**
             * Null if player hasn't started playing yet
             or if player chose to "clear saved data".
             *
             * @instance
             * @public
             * @memberof ChessCompStompWithHacksLibrary.SessionState.Data
             * @type ?System.Int64
             */
            StartTime: null,
            NumberOfWins: 0,
            WasPlayerWhiteInPreviousGame: null,
            HasShownAIHackMessage: false,
            HasShownFinalBattleMessage: false,
            HasShownFinalBattleVictoryPanel: false,
            ResearchedHacks: null,
            CompletedObjectives: null,
            ObjectivesThatWereAlreadyCompletedPriorToCurrentGame: null,
            HackSelectionScreenMobileTab: 0,
            ColorTheme: 0,
            GameLogic: null,
            MostRecentGameLogic: null
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                this.ResearchedHacks = new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.Hack)).ctor();
                this.CompletedObjectives = new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.Objective)).ctor();
                this.WasPlayerWhiteInPreviousGame = null;
                this.HasShownAIHackMessage = false;
                this.HasShownFinalBattleMessage = false;
                this.HasShownFinalBattleVictoryPanel = false;
                this.NumberOfWins = 0;
                this.StartTime = System.Int64.lift(null);

                this.GameLogic = null;
                this.MostRecentGameLogic = null;

                this.ObjectivesThatWereAlreadyCompletedPriorToCurrentGame = new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.Objective)).ctor();

                this.HackSelectionScreenMobileTab = ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTab.Tactics;

                this.ColorTheme = ChessCompStompWithHacksLibrary.ColorTheme.Initial;
            }
        },
        methods: {
            SerializeEverythingExceptGameLogic: function (list) {
                var $t, $t1;
                list.AddNullableLong(this.StartTime);

                list.AddInt(this.NumberOfWins);

                list.AddNullableBool(this.WasPlayerWhiteInPreviousGame);

                list.AddBool(this.HasShownAIHackMessage);

                list.AddBool(this.HasShownFinalBattleMessage);

                list.AddBool(this.HasShownFinalBattleVictoryPanel);

                var researchedHackIds = new (System.Collections.Generic.HashSet$1(System.Int32)).ctor();
                $t = Bridge.getEnumerator(this.ResearchedHacks);
                try {
                    while ($t.moveNext()) {
                        var researchedHack = $t.Current;
                        researchedHackIds.add(ChessCompStompWithHacksLibrary.HackUtil.GetHackId(researchedHack));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                list.AddIntSet(researchedHackIds);

                var completedObjectiveIds = new (System.Collections.Generic.HashSet$1(System.Int32)).ctor();
                $t1 = Bridge.getEnumerator(this.CompletedObjectives);
                try {
                    while ($t1.moveNext()) {
                        var completedObjective = $t1.Current;
                        completedObjectiveIds.add(ChessCompStompWithHacksLibrary.ObjectiveUtil.GetObjectiveId(completedObjective));
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
                list.AddIntSet(completedObjectiveIds);

                list.AddInt(ChessCompStompWithHacksLibrary.ColorThemeUtil.GetColorThemeId(this.ColorTheme));

                list.AddInt(ChessCompStompWithHacksLibrary.HackSelectionScreenMobileTabUtil.GetTabId(this.HackSelectionScreenMobileTab));
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.SettingsIcon", {
        fields: {
            isHover: false,
            isClicked: false,
            isMobileDisplayType: false
        },
        ctors: {
            ctor: function (isMobileDisplayType) {
                this.$initialize();
                this.isHover = false;
                this.isClicked = false;

                this.isMobileDisplayType = isMobileDisplayType;
            }
        },
        methods: {
            ProcessFrame: function (mouseInput, previousMouseInput, ignoreMouse, displayProcessing) {
                var mouseX = mouseInput.DTLibrary$IMouse$GetX();
                var mouseY = mouseInput.DTLibrary$IMouse$GetY();

                var scalingFactor = this.isMobileDisplayType ? 2 : 1;

                var settingsIconWidth = Bridge.Int.mul(((Bridge.Int.div(displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetWidth(ChessCompStompWithHacksLibrary.GameImage.Gear), 2)) | 0), scalingFactor);
                var settingsIconHeight = Bridge.Int.mul(((Bridge.Int.div(displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetHeight(ChessCompStompWithHacksLibrary.GameImage.Gear), 2)) | 0), scalingFactor);

                var windowWidth = this.isMobileDisplayType ? displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth() : ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH;
                var windowHeight = this.isMobileDisplayType ? displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenHeight() : ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT;

                var isHover = ((windowWidth - settingsIconWidth) | 0) <= mouseX && mouseX <= windowWidth && ((windowHeight - settingsIconHeight) | 0) <= mouseY && mouseY <= windowHeight;

                this.isHover = isHover && !ignoreMouse;

                if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !ignoreMouse) {
                    if (isHover) {
                        this.isClicked = true;
                    }
                }

                if (this.isClicked && !mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                    this.isClicked = false;

                    if (isHover && !ignoreMouse) {
                        return new ChessCompStompWithHacksLibrary.SettingsIcon.SettingsIconStatus(true, this.isHover);
                    }
                }

                return new ChessCompStompWithHacksLibrary.SettingsIcon.SettingsIconStatus(false, this.isHover);
            },
            Render: function (displayOutput) {
                var scalingFactor = this.isMobileDisplayType ? 2 : 1;

                var windowWidth = this.isMobileDisplayType ? displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth() : ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH;
                var windowHeight = this.isMobileDisplayType ? displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight() : ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT;

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawImageRotatedClockwise$1(this.isClicked ? ChessCompStompWithHacksLibrary.GameImage.GearSelected : (this.isHover && !this.isMobileDisplayType ? ChessCompStompWithHacksLibrary.GameImage.GearHover : ChessCompStompWithHacksLibrary.GameImage.Gear), ((windowWidth - ((Bridge.Int.div(Bridge.Int.mul(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetWidth(ChessCompStompWithHacksLibrary.GameImage.Gear), scalingFactor), 2)) | 0)) | 0), ((windowHeight - ((Bridge.Int.div(Bridge.Int.mul(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetHeight(ChessCompStompWithHacksLibrary.GameImage.Gear), scalingFactor), 2)) | 0)) | 0), 0, ((Bridge.Int.div(Bridge.Int.mul(scalingFactor, 128), 2)) | 0));
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.SettingsIcon.SettingsIconStatus", {
        $kind: "nested class",
        fields: {
            HasClicked: false,
            IsHover: false
        },
        ctors: {
            ctor: function (hasClicked, isHover) {
                this.$initialize();
                this.HasClicked = hasClicked;
                this.IsHover = isHover;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.SoundAndMusicVolumePicker", {
        fields: {
            soundVolumePicker: null,
            musicVolumePicker: null,
            scalingFactor: 0
        },
        ctors: {
            ctor: function (xPos, yPos, initialSoundVolume, initialMusicVolume, elapsedMicrosPerFrame, scalingFactor) {
                this.$initialize();
                this.soundVolumePicker = new ChessCompStompWithHacksLibrary.SoundVolumePicker(xPos, ((yPos + Bridge.Int.mul(50, scalingFactor)) | 0), initialSoundVolume, scalingFactor);
                this.musicVolumePicker = new ChessCompStompWithHacksLibrary.MusicVolumePicker(xPos, yPos, initialMusicVolume, scalingFactor);
                this.scalingFactor = scalingFactor;
            }
        },
        methods: {
            ProcessFrame: function (mouseInput, previousMouseInput) {
                this.soundVolumePicker.ProcessFrame(mouseInput, previousMouseInput);
                this.musicVolumePicker.ProcessFrame(mouseInput, previousMouseInput);
            },
            SetX: function (x) {
                this.soundVolumePicker.SetX(x);
                this.musicVolumePicker.SetX(x);
            },
            SetY: function (y) {
                this.soundVolumePicker.SetY(((y + Bridge.Int.mul(50, this.scalingFactor)) | 0));
                this.musicVolumePicker.SetY(y);
            },
            /**
             * Returns a number from 0 to 100 (both inclusive)
             *
             * @instance
             * @public
             * @this ChessCompStompWithHacksLibrary.SoundAndMusicVolumePicker
             * @memberof ChessCompStompWithHacksLibrary.SoundAndMusicVolumePicker
             * @return  {number}
             */
            GetCurrentSoundVolume: function () {
                return this.soundVolumePicker.GetCurrentSoundVolume();
            },
            /**
             * Returns a number from 0 to 100 (both inclusive)
             *
             * @instance
             * @public
             * @this ChessCompStompWithHacksLibrary.SoundAndMusicVolumePicker
             * @memberof ChessCompStompWithHacksLibrary.SoundAndMusicVolumePicker
             * @return  {number}
             */
            GetCurrentMusicVolume: function () {
                return this.musicVolumePicker.GetCurrentMusicVolume();
            },
            Render: function (displayOutput) {
                this.soundVolumePicker.Render(displayOutput);
                this.musicVolumePicker.Render(displayOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.SoundVolumePicker", {
        fields: {
            _xPos: 0,
            _yPos: 0,
            _currentVolume: 0,
            _unmuteVolume: 0,
            _isDraggingVolumeSlider: false,
            _scalingFactor: 0
        },
        ctors: {
            ctor: function (xPos, yPos, initialVolume, scalingFactor) {
                this.$initialize();
                this._xPos = xPos;
                this._yPos = yPos;

                this._currentVolume = initialVolume;
                this._unmuteVolume = this._currentVolume;

                this._isDraggingVolumeSlider = false;

                this._scalingFactor = scalingFactor;
            }
        },
        methods: {
            ProcessFrame: function (mouseInput, previousMouseInput) {
                var mouseX = mouseInput.DTLibrary$IMouse$GetX();
                var mouseY = mouseInput.DTLibrary$IMouse$GetY();

                if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && this._xPos <= mouseX && mouseX <= ((this._xPos + Bridge.Int.mul(40, this._scalingFactor)) | 0) && this._yPos <= mouseY && mouseY <= ((this._yPos + Bridge.Int.mul(50, this._scalingFactor)) | 0)) {
                    if (this._currentVolume === 0) {
                        this._currentVolume = this._unmuteVolume === 0 ? ChessCompStompWithHacksLibrary.GlobalState.DEFAULT_VOLUME : this._unmuteVolume;
                        this._unmuteVolume = this._currentVolume;
                    } else {
                        this._unmuteVolume = this._currentVolume;
                        this._currentVolume = 0;
                    }
                }

                if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && ((this._xPos + Bridge.Int.mul(50, this._scalingFactor)) | 0) <= mouseX && mouseX <= ((this._xPos + Bridge.Int.mul(150, this._scalingFactor)) | 0) && ((this._yPos + Bridge.Int.mul(10, this._scalingFactor)) | 0) <= mouseY && mouseY <= ((this._yPos + Bridge.Int.mul(40, this._scalingFactor)) | 0)) {
                    this._isDraggingVolumeSlider = true;
                }

                if (this._isDraggingVolumeSlider && mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                    var volume = (Bridge.Int.div((((mouseX - (((this._xPos + Bridge.Int.mul(50, this._scalingFactor)) | 0))) | 0)), this._scalingFactor)) | 0;
                    if (volume < 0) {
                        volume = 0;
                    }
                    if (volume > 100) {
                        volume = 100;
                    }

                    this._currentVolume = volume;
                    this._unmuteVolume = this._currentVolume;
                }

                if (!mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                    this._isDraggingVolumeSlider = false;
                }
            },
            SetX: function (x) {
                this._xPos = x;
            },
            SetY: function (y) {
                this._yPos = y;
            },
            /**
             * Returns a number from 0 to 100 (both inclusive)
             *
             * @instance
             * @public
             * @this ChessCompStompWithHacksLibrary.SoundVolumePicker
             * @memberof ChessCompStompWithHacksLibrary.SoundVolumePicker
             * @return  {number}
             */
            GetCurrentSoundVolume: function () {
                return this._currentVolume;
            },
            Render: function (displayOutput) {
                if (this._currentVolume > 0) {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawImageRotatedClockwise$1(ChessCompStompWithHacksLibrary.GameImage.SoundOn, this._xPos, this._yPos, 0, ((Bridge.Int.div(Bridge.Int.mul(128, this._scalingFactor), 2)) | 0));
                } else {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawImageRotatedClockwise$1(ChessCompStompWithHacksLibrary.GameImage.SoundOff, this._xPos, this._yPos, 0, ((Bridge.Int.div(Bridge.Int.mul(128, this._scalingFactor), 2)) | 0));
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(((this._xPos + Bridge.Int.mul(50, this._scalingFactor)) | 0), ((this._yPos + Bridge.Int.mul(10, this._scalingFactor)) | 0), Bridge.Int.mul(100, this._scalingFactor), ((Bridge.Int.mul(30, this._scalingFactor) + 1) | 0), DTLibrary.DTColor.Black(), false);

                if (this._currentVolume > 0) {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(((this._xPos + Bridge.Int.mul(50, this._scalingFactor)) | 0), ((this._yPos + Bridge.Int.mul(10, this._scalingFactor)) | 0), Bridge.Int.mul(this._currentVolume, this._scalingFactor), ((Bridge.Int.mul(30, this._scalingFactor) + 1) | 0), DTLibrary.DTColor.Black(), true);
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.TitleScreenFrame", {
        statics: {
            methods: {
                GetTitleScreenFrame: function (globalState, sessionState, displayType, display) {
                    if (displayType === DTLibrary.DisplayType.Desktop) {
                        return new ChessCompStompWithHacksLibrary.TitleScreenDesktopFrame(globalState, sessionState);
                    }

                    return new ChessCompStompWithHacksLibrary.TitleScreenMobileFrame(globalState, sessionState, display);
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.VersionHistory", {
        statics: {
            methods: {
                GetVersionInfo: function () {
                    var versionHistory = ChessCompStompWithHacksLibrary.VersionHistory.GetVersionHistory();

                    return versionHistory.getItem(((versionHistory.Count - 1) | 0));
                },
                GetVersionHistory: function () {
                    var list = new (System.Collections.Generic.List$1(DTLibrary.VersionInfo)).ctor();

                    list.add(new DTLibrary.VersionInfo("1.00", "9958487281526502"));
                    list.add(new DTLibrary.VersionInfo("1.01", "4655654740627213"));
                    list.add(new DTLibrary.VersionInfo("1.02", "5737942911566923"));
                    list.add(new DTLibrary.VersionInfo("1.03", "6315541360892856"));

                    return list;
                },
                /**
                 * Returns a guid that doesn't change between versions, but is unique to this game
                 and isn't used by other games.
                 *
                 * @static
                 * @public
                 * @this ChessCompStompWithHacksLibrary.VersionHistory
                 * @memberof ChessCompStompWithHacksLibrary.VersionHistory
                 * @return  {string}
                 */
                GetGuidForGame: function () {
                    return "3631295139845259";
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.VictoryStalemateOrDefeatPanel", {
        statics: {
            fields: {
                TOTAL_TIME_TO_DISPLAY_COMPLETED_OBJECTIVES: 0
            },
            ctors: {
                init: function () {
                    this.TOTAL_TIME_TO_DISPLAY_COMPLETED_OBJECTIVES = 2000000;
                }
            },
            methods: {
                GetWidth: function (newlyCompletedObjectives) {
                    if (newlyCompletedObjectives.Count > 0) {
                        return 693;
                    }
                    return 300;
                },
                GetHeight: function (newlyCompletedObjectives) {
                    if (newlyCompletedObjectives.Count === 0) {
                        return 200;
                    }

                    return ((268 + Bridge.Int.mul(newlyCompletedObjectives.Count, 19)) | 0);
                }
            }
        },
        fields: {
            x: 0,
            y: 0,
            gameStatus: 0,
            isPlayerWhite: false,
            mouseDragXStart: null,
            mouseDragYStart: null,
            continueButton: null,
            previousMouseInput: null,
            previousScreenWidth: 0,
            previousScreenHeight: 0,
            newlyCompletedObjectives: null,
            objectiveDisplayUtil: null,
            elapsedTimeMicros: 0
        },
        ctors: {
            ctor: function (gameStatus, isPlayerWhite, completedObjectives, objectivesThatWereAlreadyCompletedPriorToThisGame, colorTheme, display, isMobileDisplayType) {
                var $t;
                this.$initialize();
                var newlyCompletedObjectives = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.Objective)).ctor();
                $t = Bridge.getEnumerator(completedObjectives);
                try {
                    while ($t.moveNext()) {
                        var completedObjective = $t.Current;
                        if (!objectivesThatWereAlreadyCompletedPriorToThisGame.contains(completedObjective)) {
                            newlyCompletedObjectives.add(completedObjective);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                newlyCompletedObjectives.Sort$1(new ChessCompStompWithHacksLibrary.ObjectiveUtil.ObjectiveComparer());
                this.newlyCompletedObjectives = newlyCompletedObjectives;

                var width = ChessCompStompWithHacksLibrary.VictoryStalemateOrDefeatPanel.GetWidth(newlyCompletedObjectives);
                var height = ChessCompStompWithHacksLibrary.VictoryStalemateOrDefeatPanel.GetHeight(newlyCompletedObjectives);

                var screenWidth = isMobileDisplayType ? display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth() : ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH;

                var screenHeight = isMobileDisplayType ? display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenHeight() : ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT;

                this.x = (((Bridge.Int.div(screenWidth, 2)) | 0) - ((Bridge.Int.div(width, 2)) | 0)) | 0;
                this.y = (((Bridge.Int.div(screenHeight, 2)) | 0) - ((Bridge.Int.div(height, 2)) | 0)) | 0;
                this.gameStatus = gameStatus;
                this.isPlayerWhite = isPlayerWhite;

                this.mouseDragXStart = null;
                this.mouseDragYStart = null;

                this.previousMouseInput = null;
                this.previousScreenWidth = screenWidth;
                this.previousScreenHeight = screenHeight;

                this.continueButton = new ChessCompStompWithHacksLibrary.Button(((Bridge.Int.div((((width - 150) | 0)), 2)) | 0), 55, 150, 40, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(colorTheme), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(colorTheme), "Continue", 14, 8, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, isMobileDisplayType);

                this.objectiveDisplayUtil = new ChessCompStompWithHacksLibrary.ObjectiveDisplayUtil();

                this.elapsedTimeMicros = 0;
            }
        },
        methods: {
            IsPlayerVictory: function () {
                return this.gameStatus === ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.WhiteVictory && this.isPlayerWhite || this.gameStatus === ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.BlackVictory && !this.isPlayerWhite;
            },
            ProcessFrame: function (mouseInput, previousMouseInput, elapsedMicrosPerFrame, display, isMobileDisplayType) {
                this.elapsedTimeMicros = (this.elapsedTimeMicros + elapsedMicrosPerFrame) | 0;
                if (this.elapsedTimeMicros > ChessCompStompWithHacksLibrary.VictoryStalemateOrDefeatPanel.TOTAL_TIME_TO_DISPLAY_COMPLETED_OBJECTIVES) {
                    this.elapsedTimeMicros = 2000001;
                }

                if (this.previousMouseInput != null) {
                    previousMouseInput = this.previousMouseInput;
                }

                this.previousMouseInput = new DTLibrary.CopiedMouse(mouseInput);

                this.continueButton.SetIsMobileDisplayType(isMobileDisplayType);

                var mouseX = mouseInput.DTLibrary$IMouse$GetX();
                var mouseY = mouseInput.DTLibrary$IMouse$GetY();

                var width = ChessCompStompWithHacksLibrary.VictoryStalemateOrDefeatPanel.GetWidth(this.newlyCompletedObjectives);
                var height = ChessCompStompWithHacksLibrary.VictoryStalemateOrDefeatPanel.GetHeight(this.newlyCompletedObjectives);

                var screenWidth = isMobileDisplayType ? display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth() : ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH;

                var screenHeight = isMobileDisplayType ? display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenHeight() : ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT;

                var translatedMouse = new DTLibrary.TranslatedMouse(mouseInput, ((-this.x) | 0), ((-this.y) | 0));

                var isHoverOverPanel = this.x <= mouseX && mouseX <= ((this.x + width) | 0) && this.y <= mouseY && mouseY <= ((this.y + height) | 0);

                if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && isHoverOverPanel && !this.continueButton.IsHover(translatedMouse)) {
                    this.mouseDragXStart = mouseX;
                    this.mouseDragYStart = mouseY;
                }

                if (this.mouseDragXStart != null && mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                    this.x = (this.x + (((mouseX - System.Nullable.getValue(this.mouseDragXStart)) | 0))) | 0;
                    this.y = (this.y + (((mouseY - System.Nullable.getValue(this.mouseDragYStart)) | 0))) | 0;

                    this.mouseDragXStart = mouseX;
                    this.mouseDragYStart = mouseY;
                }

                if (!mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                    this.mouseDragXStart = null;
                    this.mouseDragYStart = null;

                    if (this.x < 0) {
                        this.x = 0;
                    }

                    if (this.y < 0) {
                        this.y = 0;
                    }

                    if (this.x > ((screenWidth - width) | 0)) {
                        this.x = (screenWidth - width) | 0;
                    }

                    if (this.y > ((screenHeight - height) | 0)) {
                        this.y = (screenHeight - height) | 0;
                    }
                }

                if (screenWidth !== this.previousScreenWidth || screenHeight !== this.previousScreenHeight) {
                    var panelCenterX = (this.x + ((Bridge.Int.div(width, 2)) | 0)) | 0;
                    var panelCenterY = (this.y + ((Bridge.Int.div(height, 2)) | 0)) | 0;

                    var newPanelCenterX = (Bridge.Int.div(Bridge.Int.mul(panelCenterX, screenWidth), this.previousScreenWidth)) | 0;
                    var newPanelCenterY = (Bridge.Int.div(Bridge.Int.mul(panelCenterY, screenHeight), this.previousScreenHeight)) | 0;

                    this.x = (newPanelCenterX - ((Bridge.Int.div(width, 2)) | 0)) | 0;
                    this.y = (newPanelCenterY - ((Bridge.Int.div(height, 2)) | 0)) | 0;

                    this.previousScreenWidth = screenWidth;
                    this.previousScreenHeight = screenHeight;

                    if (this.x < 0) {
                        this.x = 0;
                    }

                    if (this.y < 0) {
                        this.y = 0;
                    }

                    if (this.x > ((screenWidth - width) | 0)) {
                        this.x = (screenWidth - width) | 0;
                    }

                    if (this.y > ((screenHeight - height) | 0)) {
                        this.y = (screenHeight - height) | 0;
                    }
                }

                var isClicked = this.continueButton.ProcessFrame(translatedMouse, new DTLibrary.TranslatedMouse(previousMouseInput, ((-this.x) | 0), ((-this.y) | 0)));

                return new ChessCompStompWithHacksLibrary.VictoryStalemateOrDefeatPanel.Result(isClicked, isHoverOverPanel || this.mouseDragXStart != null);
            },
            Render: function (displayOutput) {
                var $t;
                var width = ChessCompStompWithHacksLibrary.VictoryStalemateOrDefeatPanel.GetWidth(this.newlyCompletedObjectives);
                var height = ChessCompStompWithHacksLibrary.VictoryStalemateOrDefeatPanel.GetHeight(this.newlyCompletedObjectives);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(this.x, this.y, width, height, DTLibrary.DTColor.White(), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(this.x, this.y, width, height, DTLibrary.DTColor.Black(), false);

                var text;
                var textXOffset;
                if (this.IsPlayerVictory()) {
                    text = "Victory!";
                    textXOffset = ((((Bridge.Int.div(width, 2)) | 0)) - 86) | 0;
                } else if (this.gameStatus === ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.Stalemate) {
                    text = "Stalemate!";
                    textXOffset = ((((Bridge.Int.div(width, 2)) | 0)) - 112) | 0;
                } else if (this.gameStatus === ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.WhiteVictory || this.gameStatus === ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.BlackVictory) {
                    text = "Defeat!";
                    textXOffset = ((((Bridge.Int.div(width, 2)) | 0)) - 80) | 0;
                } else {
                    throw new System.Exception();
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((this.x + textXOffset) | 0), ((((this.y + height) | 0) - 30) | 0), text, ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt, DTLibrary.DTColor.Black());

                if (this.newlyCompletedObjectives.Count > 0) {
                    var objectivesText = "";
                    $t = Bridge.getEnumerator(this.newlyCompletedObjectives);
                    try {
                        while ($t.moveNext()) {
                            var objective = $t.Current;
                            var objectiveDescription = this.objectiveDisplayUtil.GetObjectiveDescription(objective).DescriptionForVictoryStalemateOrDefeatPanel;
                            objectivesText = (objectivesText || "") + (("Completed objective: " + (objectiveDescription || "") + "\n") || "");
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    var index;
                    if (this.elapsedTimeMicros >= ChessCompStompWithHacksLibrary.VictoryStalemateOrDefeatPanel.TOTAL_TIME_TO_DISPLAY_COMPLETED_OBJECTIVES) {
                        index = objectivesText.length;
                    } else {
                        index = System.Int64.clip32(System.Int64(this.elapsedTimeMicros).mul(System.Int64(objectivesText.length)).div((System.Int64(2000000))));
                    }

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((this.x + 15) | 0), ((((this.y + height) | 0) - 95) | 0), index >= objectivesText.length ? objectivesText : objectivesText.substr(0, index), ChessCompStompWithHacksLibrary.GameFont.GameFont18Pt, DTLibrary.DTColor.Black());
                }

                this.continueButton.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, this.x, this.y));
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.VictoryStalemateOrDefeatPanel.Result", {
        $kind: "nested class",
        fields: {
            HasClickedContinueButton: false,
            IsHoverOverPanel: false
        },
        ctors: {
            ctor: function (hasClickedContinueButton, isHoverOverPanel) {
                this.$initialize();
                this.HasClickedContinueButton = hasClickedContinueButton;
                this.IsHoverOverPanel = isHoverOverPanel;
            }
        }
    });

    Bridge.define("DTLibrary.BuildType", {
        $kind: "enum",
        statics: {
            fields: {
                WebStandAlone: 0,
                WebEmbedded: 1,
                Electron: 2
            }
        }
    });

    Bridge.define("DTLibrary.ByteList", {
        inherits: function () { return [System.IEquatable$1(DTLibrary.ByteList)]; },
        fields: {
            list: null
        },
        alias: ["equalsT", "System$IEquatable$1$DTLibrary$ByteList$equalsT"],
        ctors: {
            ctor: function (list) {
                var $t;
                this.$initialize();
                this.list = new (System.Collections.Generic.List$1(System.Byte)).ctor();
                $t = Bridge.getEnumerator(list);
                try {
                    while ($t.moveNext()) {
                        var b = $t.Current;
                        this.list.add(b);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            }
        },
        methods: {
            GetByte: function (index) {
                return this.list.getItem(index);
            },
            GetCount: function () {
                return this.list.Count;
            },
            GetIterator: function () {
                return new DTLibrary.ByteList.Iterator(this);
            },
            equals: function (obj) {
                return this.equalsT(Bridge.as(obj, DTLibrary.ByteList));
            },
            equalsT: function (other) {
                if (other == null) {
                    return false;
                }

                if (Bridge.referenceEquals(this, other)) {
                    return true;
                }

                if (other.list.Count !== this.list.Count) {
                    return false;
                }

                for (var i = 0; i < this.list.Count; i = (i + 1) | 0) {
                    var b1 = this.list.getItem(i);
                    var b2 = other.list.getItem(i);
                    if (b1 !== b2) {
                        return false;
                    }
                }

                return true;
            },
            getHashCode: function () {
                var hashCode = 0;
                for (var i = 0; i < this.list.Count; i = (i + 1) | 0) {
                    var b = this.list.getItem(i);
                    var bAsInt = b;

                    hashCode = ((Bridge.Int.mul(hashCode, 17) + bAsInt) | 0);
                }

                return hashCode;
            }
        }
    });

    Bridge.define("DTLibrary.ByteList.Builder", {
        $kind: "nested class",
        fields: {
            list: null
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                this.list = new (System.Collections.Generic.List$1(System.Byte)).ctor();
            }
        },
        methods: {
            ToByteList: function () {
                return new DTLibrary.ByteList(this.list);
            },
            Add: function (b) {
                this.list.add(b);
            },
            AddBool: function (b) {
                if (b) {
                    this.list.add(1);
                } else {
                    this.list.add(0);
                }
            },
            AddNullableBool: function (b) {
                if (b == null) {
                    this.AddBool(false);
                } else {
                    this.AddBool(true);
                    this.AddBool(System.Nullable.getValue(b));
                }
            },
            AddInt: function (i) {
                var b1 = i & 255;
                var b2 = (i >> 8) & 255;
                var b3 = (i >> 16) & 255;
                var b4 = (i >> 24) & 255;

                this.list.add((b1 & 255));
                this.list.add((b2 & 255));
                this.list.add((b3 & 255));
                this.list.add((b4 & 255));
            },
            AddLong: function (l) {
                var b1 = l.and(System.Int64(255));
                var b2 = (l.shr(8)).and(System.Int64(255));
                var b3 = (l.shr(16)).and(System.Int64(255));
                var b4 = (l.shr(24)).and(System.Int64(255));
                var b5 = (l.shr(32)).and(System.Int64(255));
                var b6 = (l.shr(40)).and(System.Int64(255));
                var b7 = (l.shr(48)).and(System.Int64(255));
                var b8 = (l.shr(56)).and(System.Int64(255));

                this.list.add(System.Int64.clipu8(b1));
                this.list.add(System.Int64.clipu8(b2));
                this.list.add(System.Int64.clipu8(b3));
                this.list.add(System.Int64.clipu8(b4));
                this.list.add(System.Int64.clipu8(b5));
                this.list.add(System.Int64.clipu8(b6));
                this.list.add(System.Int64.clipu8(b7));
                this.list.add(System.Int64.clipu8(b8));
            },
            AddNullableInt: function (i) {
                if (i == null) {
                    this.AddBool(false);
                } else {
                    this.AddBool(true);
                    this.AddInt(System.Nullable.getValue(i));
                }
            },
            AddNullableLong: function (l) {
                if (System.Nullable.lifteq("equals", l, System.Int64.lift(null))) {
                    this.AddBool(false);
                } else {
                    this.AddBool(true);
                    this.AddLong(System.Nullable.getValue(l));
                }
            },
            AddIntList: function (list) {
                var $t;
                if (list == null) {
                    this.AddBool(false);
                    return;
                }

                this.AddBool(true);

                this.AddInt(list.Count);

                $t = Bridge.getEnumerator(list);
                try {
                    while ($t.moveNext()) {
                        var i = $t.Current;
                        this.AddInt(i);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            AddIntSet: function (set) {
                if (set == null) {
                    this.AddBool(false);
                    return;
                }

                this.AddBool(true);

                var list = new (System.Collections.Generic.List$1(System.Int32)).$ctor1(set);
                list.Sort();
                this.AddIntList(list);
            },
            AddString: function (str) {
                var $t;
                if (str == null) {
                    this.AddBool(false);
                    return;
                }

                this.AddBool(true);

                this.AddInt(str.length);

                $t = Bridge.getEnumerator(str);
                try {
                    while ($t.moveNext()) {
                        var c = $t.Current;
                        var cAsInt = c;
                        this.AddInt(cAsInt);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            }
        }
    });

    Bridge.define("DTLibrary.ByteList.Iterator", {
        $kind: "nested class",
        fields: {
            byteList: null,
            index: 0
        },
        ctors: {
            ctor: function (byteList) {
                this.$initialize();
                this.byteList = byteList;
                this.index = 0;
            }
        },
        methods: {
            HasNextByte: function () {
                return this.index < this.byteList.GetCount();
            },
            /**
             * Can possibly throw DTDeserializationException
             *
             * @instance
             * @public
             * @this DTLibrary.ByteList.Iterator
             * @memberof DTLibrary.ByteList.Iterator
             * @return  {number}
             */
            TryPop: function () {
                if (this.index >= this.byteList.GetCount()) {
                    throw new DTLibrary.DTDeserializationException();
                }

                var b = this.byteList.GetByte(this.index);

                this.index = (this.index + 1) | 0;

                return b;
            },
            /**
             * Can possibly throw DTDeserializationException
             *
             * @instance
             * @public
             * @this DTLibrary.ByteList.Iterator
             * @memberof DTLibrary.ByteList.Iterator
             * @return  {boolean}
             */
            TryPopBool: function () {
                if (this.index >= this.byteList.GetCount()) {
                    throw new DTLibrary.DTDeserializationException();
                }

                var b = this.byteList.GetByte(this.index);

                this.index = (this.index + 1) | 0;

                if (b === 1) {
                    return true;
                }
                if (b === 0) {
                    return false;
                }

                throw new DTLibrary.DTDeserializationException();
            },
            /**
             * Can possibly throw DTDeserializationException
             *
             * @instance
             * @public
             * @this DTLibrary.ByteList.Iterator
             * @memberof DTLibrary.ByteList.Iterator
             * @return  {?boolean}
             */
            TryPopNullableBool: function () {
                var b = this.TryPopBool();

                if (!b) {
                    return null;
                }

                return this.TryPopBool();
            },
            /**
             * Can possibly throw DTDeserializationException
             *
             * @instance
             * @public
             * @this DTLibrary.ByteList.Iterator
             * @memberof DTLibrary.ByteList.Iterator
             * @return  {number}
             */
            TryPopInt: function () {
                if (((this.index + 3) | 0) >= this.byteList.GetCount()) {
                    throw new DTLibrary.DTDeserializationException();
                }

                var b1 = this.byteList.GetByte(this.index);
                var b2 = this.byteList.GetByte(((this.index + 1) | 0));
                var b3 = this.byteList.GetByte(((this.index + 2) | 0));
                var b4 = this.byteList.GetByte(((this.index + 3) | 0));

                this.index = (this.index + 4) | 0;

                var i1 = b1;
                var i2 = b2 << 8;
                var i3 = b3 << 16;
                var i4 = b4 << 24;

                return i1 | i2 | i3 | i4;
            },
            /**
             * Can possibly throw DTDeserializationException
             *
             * @instance
             * @public
             * @this DTLibrary.ByteList.Iterator
             * @memberof DTLibrary.ByteList.Iterator
             * @return  {System.Int64}
             */
            TryPopLong: function () {
                if (((this.index + 7) | 0) >= this.byteList.GetCount()) {
                    throw new DTLibrary.DTDeserializationException();
                }

                var b1 = System.Int64(this.byteList.GetByte(this.index));
                var b2 = System.Int64(this.byteList.GetByte(((this.index + 1) | 0)));
                var b3 = System.Int64(this.byteList.GetByte(((this.index + 2) | 0)));
                var b4 = System.Int64(this.byteList.GetByte(((this.index + 3) | 0)));
                var b5 = System.Int64(this.byteList.GetByte(((this.index + 4) | 0)));
                var b6 = System.Int64(this.byteList.GetByte(((this.index + 5) | 0)));
                var b7 = System.Int64(this.byteList.GetByte(((this.index + 6) | 0)));
                var b8 = System.Int64(this.byteList.GetByte(((this.index + 7) | 0)));

                this.index = (this.index + 8) | 0;

                var l1 = b1;
                var l2 = b2.shl(8);
                var l3 = b3.shl(16);
                var l4 = b4.shl(24);
                var l5 = b5.shl(32);
                var l6 = b6.shl(40);
                var l7 = b7.shl(48);
                var l8 = b8.shl(56);

                return l1.or(l2).or(l3).or(l4).or(l5).or(l6).or(l7).or(l8);
            },
            /**
             * Can possibly throw DTDeserializationException
             *
             * @instance
             * @public
             * @this DTLibrary.ByteList.Iterator
             * @memberof DTLibrary.ByteList.Iterator
             * @return  {?number}
             */
            TryPopNullableInt: function () {
                var b = this.TryPopBool();

                if (!b) {
                    return null;
                }

                return this.TryPopInt();
            },
            /**
             * Can possibly throw DTDeserializationException
             *
             * @instance
             * @public
             * @this DTLibrary.ByteList.Iterator
             * @memberof DTLibrary.ByteList.Iterator
             * @return  {?System.Int64}
             */
            TryPopNullableLong: function () {
                var b = this.TryPopBool();

                if (!b) {
                    return System.Int64.lift(null);
                }

                return this.TryPopLong();
            },
            /**
             * Can possibly throw DTDeserializationException
             *
             * @instance
             * @public
             * @this DTLibrary.ByteList.Iterator
             * @memberof DTLibrary.ByteList.Iterator
             * @return  {System.Collections.Generic.List$1}
             */
            TryPopIntList: function () {
                var b = this.TryPopBool();

                if (!b) {
                    return null;
                }

                var count = this.TryPopInt();

                var list = new (System.Collections.Generic.List$1(System.Int32)).ctor();

                for (var i = 0; i < count; i = (i + 1) | 0) {
                    list.add(this.TryPopInt());
                }

                return list;
            },
            /**
             * Can possibly throw DTDeserializationException
             *
             * @instance
             * @public
             * @this DTLibrary.ByteList.Iterator
             * @memberof DTLibrary.ByteList.Iterator
             * @return  {System.Collections.Generic.HashSet$1}
             */
            TryPopIntSet: function () {
                var b = this.TryPopBool();

                if (!b) {
                    return null;
                }

                var list = this.TryPopIntList();

                if (list == null) {
                    throw new DTLibrary.DTDeserializationException();
                }

                return new (System.Collections.Generic.HashSet$1(System.Int32)).$ctor1(list);
            },
            /**
             * Can possibly throw DTDeserializationException
             *
             * @instance
             * @public
             * @this DTLibrary.ByteList.Iterator
             * @memberof DTLibrary.ByteList.Iterator
             * @return  {string}
             */
            TryPopString: function () {
                var b = this.TryPopBool();

                if (!b) {
                    return null;
                }

                var count = this.TryPopInt();

                var array = System.Array.init(count, 0, System.Char);

                for (var i = 0; i < count; i = (i + 1) | 0) {
                    var cAsInt = this.TryPopInt();
                    array[System.Array.index(i, array)] = cAsInt & 65535;
                }

                return System.String.fromCharArray(array);
            }
        }
    });

    Bridge.define("DTLibrary.DisplayExtensions", {
        statics: {
            methods: {
                DrawThickRectangle: function (ImageEnum, FontEnum, displayOutput, x, y, width, height, additionalThickness, color, fill) {
                    displayOutput["DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$DrawRectangle"](((x - additionalThickness) | 0), ((y - additionalThickness) | 0), ((width + Bridge.Int.mul(additionalThickness, 2)) | 0), ((1 + Bridge.Int.mul(additionalThickness, 2)) | 0), color, true);
                    displayOutput["DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$DrawRectangle"](((x - additionalThickness) | 0), ((((((height - 1) | 0) + y) | 0) - additionalThickness) | 0), ((width + Bridge.Int.mul(additionalThickness, 2)) | 0), ((1 + Bridge.Int.mul(additionalThickness, 2)) | 0), color, true);
                    displayOutput["DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$DrawRectangle"](((x - additionalThickness) | 0), ((y - additionalThickness) | 0), ((1 + Bridge.Int.mul(additionalThickness, 2)) | 0), ((height + Bridge.Int.mul(additionalThickness, 2)) | 0), color, true);
                    displayOutput["DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$DrawRectangle"](((((((width - 1) | 0) + x) | 0) - additionalThickness) | 0), ((y - additionalThickness) | 0), ((1 + Bridge.Int.mul(additionalThickness, 2)) | 0), ((height + Bridge.Int.mul(additionalThickness, 2)) | 0), color, true);

                    if (fill) {
                        displayOutput["DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$DrawRectangle"](x, y, width, height, color, true);
                    }
                },
                IsMobileInLandscapeOrientation$1: function (ImageEnum, FontEnum, displayOutput) {
                    return displayOutput["DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$GetMobileScreenWidth"]() > displayOutput["DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$GetMobileScreenHeight"]();
                },
                IsMobileInLandscapeOrientation: function (ImageEnum, displayProcessing) {
                    return displayProcessing["DTLibrary$IDisplayProcessing$1$" + Bridge.getTypeAlias(ImageEnum) + "$GetMobileScreenWidth"]() > displayProcessing["DTLibrary$IDisplayProcessing$1$" + Bridge.getTypeAlias(ImageEnum) + "$GetMobileScreenHeight"]();
                }
            }
        }
    });

    Bridge.define("DTLibrary.DisplayType", {
        $kind: "enum",
        statics: {
            fields: {
                Desktop: 0,
                MobileLandscape: 1,
                MobilePortrait: 2
            }
        }
    });

    /** @namespace DTLibrary */

    /**
     * Represents a color, containing the standard r, g, b, and alpha values.
     *
     * @public
     * @class DTLibrary.DTColor
     */
    Bridge.define("DTLibrary.DTColor", {
        statics: {
            methods: {
                White: function () {
                    return new DTLibrary.DTColor.ctor(255, 255, 255);
                },
                Black: function () {
                    return new DTLibrary.DTColor.ctor(0, 0, 0);
                }
            }
        },
        fields: {
            r: 0,
            g: 0,
            b: 0,
            alpha: 0
        },
        props: {
            R: {
                get: function () {
                    return this.r;
                }
            },
            G: {
                get: function () {
                    return this.g;
                }
            },
            B: {
                get: function () {
                    return this.b;
                }
            },
            Alpha: {
                get: function () {
                    return this.alpha;
                }
            }
        },
        ctors: {
            ctor: function (r, g, b) {
                this.$initialize();
                this.r = r;
                this.g = g;
                this.b = b;
                this.alpha = 255;
            },
            $ctor1: function (r, g, b, alpha) {
                this.$initialize();
                this.r = r;
                this.g = g;
                this.b = b;
                this.alpha = alpha;
            }
        }
    });

    Bridge.define("DTLibrary.DTDeserializationException", {
        inherits: [System.Exception]
    });

    /**
     * An interface representing a (pseudo) random number generator.
     *
     * @abstract
     * @public
     * @class DTLibrary.IDTRandom
     */
    Bridge.define("DTLibrary.IDTRandom", {
        $kind: "interface"
    });

    Bridge.define("DTLibrary.DTImmutableList$1", function (T) { return {
        statics: {
            methods: {
                AsImmutableList: function (l) {
                    var immutableList = new (DTLibrary.DTImmutableList$1(T)).ctor();
                    immutableList.list = l;
                    immutableList.count = l.Count;
                    return immutableList;
                },
                EmptyList: function () {
                    return new (DTLibrary.DTImmutableList$1(T)).$ctor2(new (System.Collections.Generic.List$1(T)).ctor());
                }
            }
        },
        fields: {
            list: null,
            count: 0
        },
        props: {
            Count: {
                get: function () {
                    return this.count;
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            },
            $ctor1: function (set) {
                var $t;
                this.$initialize();
                this.list = new (System.Collections.Generic.List$1(T)).$ctor2(set.Count);
                $t = Bridge.getEnumerator(set);
                try {
                    while ($t.moveNext()) {
                        var item = $t.Current;
                        this.list.add(item);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.count = set.Count;
            },
            $ctor2: function (list) {
                var $t;
                this.$initialize();
                this.list = new (System.Collections.Generic.List$1(T)).$ctor2(list.Count);
                $t = Bridge.getEnumerator(list);
                try {
                    while ($t.moveNext()) {
                        var item = $t.Current;
                        this.list.add(item);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.count = list.Count;
            }
        },
        methods: {
            getItem: function (index) {
                return this.list.getItem(index);
            }
        }
    }; });

    Bridge.define("DTLibrary.GlobalConfigurationManager", {
        statics: {
            methods: {
                /**
                 * If no saved configuration is found (or the saved configuration is invalid), returns a default GlobalConfiguration.
                 *
                 * @static
                 * @public
                 * @this DTLibrary.GlobalConfigurationManager
                 * @memberof DTLibrary.GlobalConfigurationManager
                 * @param   {DTLibrary.IFileIO}                                           fileIO         
                 * @param   {number}                                                      fileId         
                 * @param   {DTLibrary.VersionInfo}                                       versionInfo
                 * @return  {DTLibrary.GlobalConfigurationManager.GlobalConfiguration}
                 */
                GetGlobalConfiguration: function (fileIO, fileId, versionInfo) {
                    var byteList = fileIO.DTLibrary$IFileIO$FetchData(fileId, versionInfo);

                    if (byteList == null) {
                        return new DTLibrary.GlobalConfigurationManager.GlobalConfiguration(DTLibrary.GlobalConfigurationManager.GlobalConfiguration.DEFAULT_FPS, DTLibrary.GlobalConfigurationManager.GlobalConfiguration.DEFAULT_DEBUG_MODE);
                    }

                    var iterator = byteList.GetIterator();

                    var fps = DTLibrary.GlobalConfigurationManager.GlobalConfiguration.DEFAULT_FPS;
                    var debugMode = DTLibrary.GlobalConfigurationManager.GlobalConfiguration.DEFAULT_DEBUG_MODE;

                    try {
                        while (true) {
                            if (!iterator.HasNextByte()) {
                                break;
                            }

                            var str = DTLibrary.GlobalConfigurationManager.TryDeserializeAsciiLineOfInput(iterator);

                            var array = System.String.split(str, [61].map(function (i) {{ return String.fromCharCode(i); }}));

                            if (array.length < 2) {
                                continue;
                            }

                            if (Bridge.referenceEquals(array[System.Array.index(0, array)], "fps")) {
                                var fpsString = array[System.Array.index(1, array)];

                                var possibleFpsValue = DTLibrary.StringUtil.TryParseInt(fpsString);

                                if (System.Nullable.hasValue(possibleFpsValue)) {
                                    fps = System.Nullable.getValue(possibleFpsValue);
                                }
                            }

                            if (Bridge.referenceEquals(array[System.Array.index(0, array)], "debugmode")) {
                                if (Bridge.referenceEquals(array[System.Array.index(1, array)], "true")) {
                                    debugMode = true;
                                }
                                if (Bridge.referenceEquals(array[System.Array.index(1, array)], "false")) {
                                    debugMode = false;
                                }
                            }
                        }
                    } catch ($e1) {
                        $e1 = System.Exception.create($e1);
                        if (Bridge.is($e1, DTLibrary.DTDeserializationException)) {
                        } else {
                            throw $e1;
                        }
                    }

                    if (fps < DTLibrary.GlobalConfigurationManager.GlobalConfiguration.MIN_FPS) {
                        fps = DTLibrary.GlobalConfigurationManager.GlobalConfiguration.MIN_FPS;
                    }
                    if (fps > DTLibrary.GlobalConfigurationManager.GlobalConfiguration.MAX_FPS) {
                        fps = DTLibrary.GlobalConfigurationManager.GlobalConfiguration.MAX_FPS;
                    }

                    return new DTLibrary.GlobalConfigurationManager.GlobalConfiguration(fps, debugMode);
                },
                SaveGlobalConfiguration: function (globalConfiguration, fileIO, fileId, versionInfo) {
                    var builder = new DTLibrary.ByteList.Builder();

                    var fps = globalConfiguration.Fps;
                    var fpsString = "fps=" + (DTLibrary.StringUtil.ToStringCultureInvariant(fps) || "");

                    DTLibrary.GlobalConfigurationManager.SerializeAsciiLineOfInput(fpsString, builder);

                    var debugMode = globalConfiguration.DebugMode;
                    var debugModeString = "debugmode=" + ((debugMode ? "true" : "false") || "");

                    DTLibrary.GlobalConfigurationManager.SerializeAsciiLineOfInput(debugModeString, builder);

                    fileIO.DTLibrary$IFileIO$PersistData(fileId, versionInfo, builder.ToByteList());
                },
                /**
                 * Can possibly throw DTDeserializationException
                 *
                 * @static
                 * @private
                 * @this DTLibrary.GlobalConfigurationManager
                 * @memberof DTLibrary.GlobalConfigurationManager
                 * @param   {DTLibrary.ByteList.Iterator}    byteListIterator
                 * @return  {string}
                 */
                TryDeserializeAsciiLineOfInput: function (byteListIterator) {
                    var line = "";

                    while (true) {
                        if (!byteListIterator.HasNextByte()) {
                            return line;
                        }

                        var b = byteListIterator.TryPop();
                        var c = b;

                        if (c === 10) {
                            return line;
                        }

                        line = (line || "") + ((String.fromCharCode(c)) || "");
                    }
                },
                SerializeAsciiLineOfInput: function (asciiString, byteListBuilder) {
                    var $t;
                    $t = Bridge.getEnumerator(asciiString);
                    try {
                        while ($t.moveNext()) {
                            var c = $t.Current;
                            var b = c & 255;
                            byteListBuilder.Add(b);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    var newline = 10;
                    var newLineAsByte = newline & 255;
                    byteListBuilder.Add(newLineAsByte);
                }
            }
        }
    });

    Bridge.define("DTLibrary.GlobalConfigurationManager.GlobalConfiguration", {
        $kind: "nested class",
        statics: {
            fields: {
                DEFAULT_FPS: 0,
                MIN_FPS: 0,
                MAX_FPS: 0,
                DEFAULT_DEBUG_MODE: false
            },
            ctors: {
                init: function () {
                    this.DEFAULT_FPS = 60;
                    this.MIN_FPS = 10;
                    this.MAX_FPS = 300;
                    this.DEFAULT_DEBUG_MODE = false;
                }
            }
        },
        fields: {
            Fps: 0,
            DebugMode: false
        },
        ctors: {
            ctor: function (fps, debugMode) {
                this.$initialize();
                this.Fps = fps;
                this.DebugMode = debugMode;
            }
        }
    });

    Bridge.define("DTLibrary.GuidGenerator", {
        statics: {
            methods: {
                IntToString: function (i) {
                    switch (i) {
                        case 0: 
                            return "0";
                        case 1: 
                            return "1";
                        case 2: 
                            return "2";
                        case 3: 
                            return "3";
                        case 4: 
                            return "4";
                        case 5: 
                            return "5";
                        case 6: 
                            return "6";
                        case 7: 
                            return "7";
                        case 8: 
                            return "8";
                        case 9: 
                            return "9";
                    }

                    if (i < 0) {
                        return "-" + (DTLibrary.GuidGenerator.IntToString(((-i) | 0)) || "");
                    }

                    var x = (Bridge.Int.div(i, 10)) | 0;
                    var y = i % 10;

                    return (DTLibrary.GuidGenerator.IntToString(x) || "") + (DTLibrary.GuidGenerator.IntToString(y) || "");
                }
            }
        },
        fields: {
            currentValue1: 0,
            currentValue2: 0,
            guidString: null
        },
        ctors: {
            ctor: function (guidString) {
                this.$initialize();
                this.currentValue1 = 0;
                this.currentValue2 = 0;
                this.guidString = guidString;
            }
        },
        methods: {
            NextGuid: function () {
                if (this.currentValue1 === 2147483647) {
                    this.currentValue1 = 0;
                    this.currentValue2 = (this.currentValue2 + 1) | 0;
                } else {
                    this.currentValue1 = (this.currentValue1 + 1) | 0;
                }

                var currentValue1AsString = DTLibrary.GuidGenerator.IntToString(this.currentValue1);
                var currentValue2AsString = this.currentValue2 === 0 ? "0" : DTLibrary.GuidGenerator.IntToString(this.currentValue2);
                return "g=" + (this.guidString || "") + "," + (currentValue1AsString || "") + "," + (currentValue2AsString || "");
            }
        }
    });

    Bridge.define("DTLibrary.IntTupleEqualityComparer", {
        inherits: [System.Collections.Generic.IEqualityComparer$1(System.Tuple$2(System.Int32,System.Int32))],
        alias: [
            "equals2", ["System$Collections$Generic$IEqualityComparer$1$System$Tuple$2$System$Int32$System$Int32$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2"],
            "getHashCode2", ["System$Collections$Generic$IEqualityComparer$1$System$Tuple$2$System$Int32$System$Int32$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"]
        ],
        methods: {
            equals2: function (x, y) {
                if (x == null && y == null) {
                    return true;
                }

                if (x == null || y == null) {
                    return false;
                }

                return x.Item1 === y.Item1 && x.Item2 === y.Item2;
            },
            getHashCode2: function (obj) {
                var a = obj.Item1 << 4;

                return ((((a + obj.Item1) | 0) + obj.Item2) | 0);
            }
        }
    });

    Bridge.define("DTLibrary.ITimer", {
        $kind: "interface"
    });

    Bridge.define("DTLibrary.Key", {
        $kind: "enum",
        statics: {
            fields: {
                A: 0,
                B: 1,
                C: 2,
                D: 3,
                E: 4,
                F: 5,
                G: 6,
                H: 7,
                I: 8,
                J: 9,
                K: 10,
                L: 11,
                M: 12,
                N: 13,
                O: 14,
                P: 15,
                Q: 16,
                R: 17,
                S: 18,
                T: 19,
                U: 20,
                V: 21,
                W: 22,
                X: 23,
                Y: 24,
                Z: 25,
                Zero: 26,
                One: 27,
                Two: 28,
                Three: 29,
                Four: 30,
                Five: 31,
                Six: 32,
                Seven: 33,
                Eight: 34,
                Nine: 35,
                UpArrow: 36,
                DownArrow: 37,
                LeftArrow: 38,
                RightArrow: 39,
                Delete: 40,
                Backspace: 41,
                Enter: 42,
                Shift: 43,
                Space: 44,
                Esc: 45
            }
        }
    });

    Bridge.define("DTLibrary.ListUtil", {
        statics: {
            methods: {
                Shuffle: function (T, list, random) {
                    for (var i = (list.Count - 1) | 0; i > 0; i = (i - 1) | 0) {
                        var index = random.DTLibrary$IDTRandom$NextInt(((i + 1) | 0));
                        if (index !== i) {
                            var element = list.getItem(index);
                            list.setItem(index, list.getItem(i));
                            list.setItem(i, element);
                        }
                    }
                }
            }
        }
    });

    Bridge.define("DTLibrary.StringConcatenation", {
        statics: {
            methods: {
                Concat: function (s, i) {
                    return (s || "") + (DTLibrary.StringUtil.ToStringCultureInvariant(i) || "");
                }
            }
        }
    });

    Bridge.define("DTLibrary.StringUtil", {
        statics: {
            methods: {
                IsDigit: function (c) {
                    return c === 48 || c === 49 || c === 50 || c === 51 || c === 52 || c === 53 || c === 54 || c === 55 || c === 56 || c === 57;
                },
                TryParseInt: function (str) {
                    if (str == null) {
                        return null;
                    }

                    if (Bridge.referenceEquals(str, "")) {
                        return null;
                    }

                    if (str.charCodeAt(0) !== 45 && !DTLibrary.StringUtil.IsDigit(str.charCodeAt(0))) {
                        return null;
                    }

                    if (Bridge.referenceEquals(str, "-")) {
                        return null;
                    }

                    for (var i = 1; i < str.length; i = (i + 1) | 0) {
                        if (!DTLibrary.StringUtil.IsDigit(str.charCodeAt(i))) {
                            return null;
                        }
                    }

                    if (Bridge.referenceEquals(str, "-2147483648")) {
                        return -2147483648;
                    }

                    if (str.charCodeAt(0) === 45) {
                        var result = DTLibrary.StringUtil.TryParseInt(str.substr(1));
                        if (result == null) {
                            return null;
                        }
                        return Bridge.Int.clip32(-(System.Nullable.getValue(result)));
                    }

                    return DTLibrary.StringUtil.TryParseIntHelper(str);
                },
                TryParseIntHelper: function (str) {
                    if (str.length === 1) {
                        if (Bridge.referenceEquals(str, "0")) {
                            return 0;
                        }
                        if (Bridge.referenceEquals(str, "1")) {
                            return 1;
                        }
                        if (Bridge.referenceEquals(str, "2")) {
                            return 2;
                        }
                        if (Bridge.referenceEquals(str, "3")) {
                            return 3;
                        }
                        if (Bridge.referenceEquals(str, "4")) {
                            return 4;
                        }
                        if (Bridge.referenceEquals(str, "5")) {
                            return 5;
                        }
                        if (Bridge.referenceEquals(str, "6")) {
                            return 6;
                        }
                        if (Bridge.referenceEquals(str, "7")) {
                            return 7;
                        }
                        if (Bridge.referenceEquals(str, "8")) {
                            return 8;
                        }
                        if (Bridge.referenceEquals(str, "9")) {
                            return 9;
                        }
                    }

                    var leastSignificantDigit = DTLibrary.StringUtil.TryParseIntHelper(str.substr(((str.length - 1) | 0)));
                    var restOfNumber = DTLibrary.StringUtil.TryParseIntHelper(str.substr(0, ((str.length - 1) | 0)));

                    if (leastSignificantDigit == null || restOfNumber == null) {
                        return null;
                    }

                    try {
                        var number = Bridge.Int.check(System.Nullable.getValue(leastSignificantDigit) + Bridge.Int.mul(10, System.Nullable.getValue(restOfNumber), 1), System.Int32);
                        return number;
                    } catch ($e1) {
                        $e1 = System.Exception.create($e1);
                        if (Bridge.is($e1, System.OverflowException)) {
                            return null;
                        } else {
                            throw $e1;
                        }
                    }
                },
                ParseAsIntCultureInvariant: function (str) {
                    return DTLibrary.StringUtil.ParseInt(str);
                },
                ParseInt: function (str) {
                    var val = DTLibrary.StringUtil.TryParseInt(str);

                    if (val == null) {
                        throw new System.Exception("str does not represent an int: " + (str || ""));
                    }

                    return System.Nullable.getValue(val);
                },
                /**
                 * Returns null if the string does not represent a long
                 *
                 * @static
                 * @public
                 * @this DTLibrary.StringUtil
                 * @memberof DTLibrary.StringUtil
                 * @param   {string}           str
                 * @return  {?System.Int64}
                 */
                TryParseLong: function (str) {
                    if (str == null) {
                        return System.Int64.lift(null);
                    }

                    if (Bridge.referenceEquals(str, "")) {
                        return System.Int64.lift(null);
                    }

                    if (str.charCodeAt(0) !== 45 && !DTLibrary.StringUtil.IsDigit(str.charCodeAt(0))) {
                        return System.Int64.lift(null);
                    }

                    if (Bridge.referenceEquals(str, "-")) {
                        return System.Int64.lift(null);
                    }

                    for (var i = 1; i < str.length; i = (i + 1) | 0) {
                        if (!DTLibrary.StringUtil.IsDigit(str.charCodeAt(i))) {
                            return System.Int64.lift(null);
                        }
                    }

                    if (Bridge.referenceEquals(str, "-9223372036854775808")) {
                        return System.Int64.MinValue;
                    }

                    if (str.charCodeAt(0) === 45) {
                        var result = DTLibrary.StringUtil.TryParseLong(str.substr(1));
                        if (System.Nullable.lifteq("equals", result, System.Int64.lift(null))) {
                            return System.Int64.lift(null);
                        }
                        return System.Int64(-1).mul(System.Nullable.getValue(result));
                    }

                    if (str.length === 1) {
                        if (Bridge.referenceEquals(str, "0")) {
                            return System.Int64(0);
                        }
                        if (Bridge.referenceEquals(str, "1")) {
                            return System.Int64(1);
                        }
                        if (Bridge.referenceEquals(str, "2")) {
                            return System.Int64(2);
                        }
                        if (Bridge.referenceEquals(str, "3")) {
                            return System.Int64(3);
                        }
                        if (Bridge.referenceEquals(str, "4")) {
                            return System.Int64(4);
                        }
                        if (Bridge.referenceEquals(str, "5")) {
                            return System.Int64(5);
                        }
                        if (Bridge.referenceEquals(str, "6")) {
                            return System.Int64(6);
                        }
                        if (Bridge.referenceEquals(str, "7")) {
                            return System.Int64(7);
                        }
                        if (Bridge.referenceEquals(str, "8")) {
                            return System.Int64(8);
                        }
                        if (Bridge.referenceEquals(str, "9")) {
                            return System.Int64(9);
                        }
                    }

                    var leastSignificantDigit = DTLibrary.StringUtil.TryParseLong(str.substr(((str.length - 1) | 0)));
                    var restOfNumber = DTLibrary.StringUtil.TryParseLong(str.substr(0, ((str.length - 1) | 0)));

                    if (System.Nullable.lifteq("equals", leastSignificantDigit, System.Int64.lift(null)) || System.Nullable.lifteq("equals", restOfNumber, System.Int64.lift(null))) {
                        return System.Int64.lift(null);
                    }

                    try {
                        var number = System.Nullable.getValue(leastSignificantDigit).add(System.Int64(10).mul(System.Nullable.getValue(restOfNumber), 1), 1);
                        return number;
                    } catch ($e1) {
                        $e1 = System.Exception.create($e1);
                        if (Bridge.is($e1, System.OverflowException)) {
                            return System.Int64.lift(null);
                        } else {
                            throw $e1;
                        }
                    }
                },
                ToUpperCaseCultureInvariant: function (str) {
                    var array = System.Array.init(str.length, 0, System.Char);

                    for (var i = 0; i < array.length; i = (i + 1) | 0) {
                        var c = str.charCodeAt(i);

                        if (c < 97 || c > 122) {
                            array[System.Array.index(i, array)] = c;
                        } else {
                            array[System.Array.index(i, array)] = (((c - 32) | 0)) & 65535;
                        }
                    }

                    return System.String.fromCharArray(array);
                },
                ToStringCultureInvariant: function (i) {
                    if (i === -2147483648) {
                        return "-2147483648";
                    }

                    return DTLibrary.StringUtil.IntToStringHelper(i);
                },
                ToStringCultureInvariant$1: function (l) {
                    if (l.equals(System.Int64.MinValue)) {
                        return "-9223372036854775808";
                    }

                    return DTLibrary.StringUtil.LongToStringHelper(l);
                },
                IntToStringHelper: function (i) {
                    switch (i) {
                        case 0: 
                            return "0";
                        case 1: 
                            return "1";
                        case 2: 
                            return "2";
                        case 3: 
                            return "3";
                        case 4: 
                            return "4";
                        case 5: 
                            return "5";
                        case 6: 
                            return "6";
                        case 7: 
                            return "7";
                        case 8: 
                            return "8";
                        case 9: 
                            return "9";
                    }

                    if (i < 0) {
                        return "-" + (DTLibrary.StringUtil.IntToStringHelper(((-i) | 0)) || "");
                    }

                    var x = (Bridge.Int.div(i, 10)) | 0;
                    var y = i % 10;

                    return (DTLibrary.StringUtil.IntToStringHelper(x) || "") + (DTLibrary.StringUtil.IntToStringHelper(y) || "");
                },
                LongToStringHelper: function (l) {
                    switch (l.toString()) {
                        case "0": 
                            return "0";
                        case "1": 
                            return "1";
                        case "2": 
                            return "2";
                        case "3": 
                            return "3";
                        case "4": 
                            return "4";
                        case "5": 
                            return "5";
                        case "6": 
                            return "6";
                        case "7": 
                            return "7";
                        case "8": 
                            return "8";
                        case "9": 
                            return "9";
                    }

                    if (l.lt(System.Int64(0))) {
                        return "-" + (DTLibrary.StringUtil.LongToStringHelper(l.neg()) || "");
                    }

                    var x = l.div(System.Int64(10));
                    var y = l.mod(System.Int64(10));

                    return (DTLibrary.StringUtil.LongToStringHelper(x) || "") + (DTLibrary.StringUtil.LongToStringHelper(y) || "");
                }
            }
        }
    });

    Bridge.define("DTLibrary.StringUtil.CultureInvariantComparer", {
        inherits: [System.Collections.Generic.IComparer$1(System.String)],
        $kind: "nested class",
        alias: ["compare", ["System$Collections$Generic$IComparer$1$System$String$compare", "System$Collections$Generic$IComparer$1$compare"]],
        methods: {
            compare: function (x, y) {
                if (x == null && y == null) {
                    return 0;
                }

                if (x == null) {
                    return -1;
                }

                if (y == null) {
                    return 1;
                }

                var index = 0;

                while (true) {
                    if (index === x.length && index === y.length) {
                        return 0;
                    }

                    if (index === x.length) {
                        return -1;
                    }

                    if (index === y.length) {
                        return 1;
                    }

                    var c1 = x.charCodeAt(index);
                    var c2 = y.charCodeAt(index);

                    if (c1 < c2) {
                        return -1;
                    }

                    if (c1 > c2) {
                        return 1;
                    }

                    index = (index + 1) | 0;
                }
            }
        }
    });

    Bridge.define("DTLibrary.VersionInfo", {
        fields: {
            Version: null,
            AlphanumericVersionGuid: null
        },
        ctors: {
            ctor: function (version, alphanumericVersionGuid) {
                this.$initialize();
                this.Version = version;
                this.AlphanumericVersionGuid = alphanumericVersionGuid;
            }
        }
    });

    Bridge.define("DTLibrary.VolumeUtil", {
        statics: {
            methods: {
                GetVolumeSmoothed: function (elapsedMicrosPerFrame, currentVolume, desiredVolume) {
                    var maxChangePerFrame = (Bridge.Int.div(elapsedMicrosPerFrame, 5000)) | 0;
                    if (maxChangePerFrame <= 0) {
                        maxChangePerFrame = 1;
                    }

                    if (Math.abs(((desiredVolume - currentVolume) | 0)) <= maxChangePerFrame) {
                        return desiredVolume;
                    } else {
                        if (desiredVolume > currentVolume) {
                            return ((currentVolume + maxChangePerFrame) | 0);
                        } else {
                            return ((currentVolume - maxChangePerFrame) | 0);
                        }
                    }
                }
            }
        }
    });

    Bridge.define("DTLibrary.DTDisplay$2", function (ImageEnum, FontEnum) { return {
        inherits: [DTLibrary.IDisplayProcessing$1(ImageEnum),DTLibrary.IDisplayOutput$2(ImageEnum,FontEnum),DTLibrary.IDisplayCleanup],
        alias: [
            "DrawImage", "DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$DrawImage",
            "DrawImageRotatedClockwise$2", "DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$DrawImageRotatedClockwise"
        ],
        methods: {
            DrawImage: function (image, x, y) {
                this.DrawImageRotatedClockwise$1(image, x, y, 0, 128);
            },
            DrawImageRotatedClockwise$2: function (image, x, y, degreesScaled) {
                this.DrawImageRotatedClockwise$1(image, x, y, degreesScaled, 128);
            }
        }
    }; });

    Bridge.define("ChessCompStompWithHacksLibrary.GameImage", {
        $kind: "enum",
        statics: {
            fields: {
                SoundOn: 0,
                SoundOff: 1,
                MusicOn: 2,
                MusicOff: 3,
                Gear: 4,
                GearHover: 5,
                GearSelected: 6,
                Cross: 7,
                CrossHover: 8,
                CrossSelected: 9,
                Down: 10,
                Up: 11,
                BlackPawn: 12,
                BlackRook: 13,
                BlackKnight: 14,
                BlackBishop: 15,
                BlackQueen: 16,
                BlackKing: 17,
                WhitePawn: 18,
                WhiteRook: 19,
                WhiteKnight: 20,
                WhiteBishop: 21,
                WhiteQueen: 22,
                WhiteKing: 23,
                Nuke_NotReady: 24,
                Nuke_Ready: 25,
                Nuke_Hover: 26,
                Nuke_Selected: 27,
                Nuke_RocketFire: 28,
                Nuke_Explosion1: 29,
                Nuke_Explosion2: 30,
                Nuke_Explosion3: 31,
                Nuke_Explosion4: 32,
                Nuke_Explosion5: 33,
                Nuke_Explosion6: 34,
                Nuke_Explosion7: 35,
                Nuke_Explosion8: 36,
                Nuke_Explosion9: 37
            }
        }
    });

    Bridge.define("ChessCompStompWithHacks.BridgeFileIO", {
        inherits: [DTLibrary.IFileIO],
        alias: [
            "PersistData", "DTLibrary$IFileIO$PersistData",
            "FetchData", "DTLibrary$IFileIO$FetchData"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                
				window.BridgeFileIOJavascript = ((function () {
					'use strict';
					
					var persistData = function (fileName, base64String) {
						try {
							localStorage.setItem(fileName, base64String);
						} catch (error) {
							// do nothing
						}
					};
										
					var fetchData = function (fileName) {
						try {
							var value = localStorage.getItem(fileName);
							return value;
						} catch (error) {
							return null;
						}
					};
					
					var hasData = function (fileName) {
						try {
							var value = localStorage.getItem(fileName);
							return value !== null;
						} catch (error) {
							return false;
						}
					};
										
					return {
						persistData: persistData,
						fetchData: fetchData,
						hasData: hasData
					};
				})());
			
            }
        },
        methods: {
            GetFileName: function (fileId, versionInfo) {
                var alphanumericVersionGuid = versionInfo.AlphanumericVersionGuid;
                return "guid" + (alphanumericVersionGuid || "") + "_file" + (DTLibrary.StringUtil.ToStringCultureInvariant(fileId) || "");
            },
            PersistData: function (fileId, versionInfo, data) {
                var list = new (System.Collections.Generic.List$1(System.Byte)).ctor();

                var iterator = data.GetIterator();

                while (true) {
                    if (!iterator.HasNextByte()) {
                        break;
                    }

                    list.add(iterator.TryPop());
                }

                var array = System.Array.init(list.Count, 0, System.Byte);
                for (var i = 0; i < array.length; i = (i + 1) | 0) {
                    array[System.Array.index(i, array)] = list.getItem(i);
                }

                var base64String = System.Convert.toBase64String(array, null, null, null);

                window.BridgeFileIOJavascript.persistData(this.GetFileName(fileId, versionInfo), base64String);
            },
            FetchData: function (fileId, versionInfo) {
                var fileName = this.GetFileName(fileId, versionInfo);

                var hasData = eval("window.BridgeFileIOJavascript.hasData('" + (fileName || "") + "')");

                if (!hasData) {
                    return null;
                }

                var result = eval("window.BridgeFileIOJavascript.fetchData('" + (fileName || "") + "')");

                if (result == null) {
                    return null;
                }

                try {
                    var array = System.Convert.fromBase64String(result);
                    var byteList = new DTLibrary.ByteList.Builder();

                    for (var i = 0; i < array.length; i = (i + 1) | 0) {
                        byteList.Add(array[System.Array.index(i, array)]);
                    }

                    return byteList.ToByteList();
                } catch ($e1) {
                    $e1 = System.Exception.create($e1);
                }

                return null;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacks.BridgeKeyboard", {
        inherits: [DTLibrary.IKeyboard],
        alias: ["IsPressed", "DTLibrary$IKeyboard$IsPressed"],
        ctors: {
            ctor: function (disableArrowKeyScrolling) {
                this.$initialize();
                eval("\r\n\t\t\t\twindow.BridgeKeyboardJavascript = ((function () {\r\n\t\t\t\t\t'use strict';\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar keysBeingPressed = [];\r\n\t\t\t\t\tvar keyPressesThatNeedToBeProcessed = [];\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar disableArrowKeyScrolling = " + ((disableArrowKeyScrolling ? "true" : "false") || "") + ";\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar mapKeyToCanonicalKey = function (key) {\r\n\t\t\t\t\t\tif (key === 'A')\r\n\t\t\t\t\t\t\treturn 'a';\r\n\t\t\t\t\t\tif (key === 'B')\r\n\t\t\t\t\t\t\treturn 'b';\r\n\t\t\t\t\t\tif (key === 'C')\r\n\t\t\t\t\t\t\treturn 'c';\r\n\t\t\t\t\t\tif (key === 'D')\r\n\t\t\t\t\t\t\treturn 'd';\r\n\t\t\t\t\t\tif (key === 'E')\r\n\t\t\t\t\t\t\treturn 'e';\r\n\t\t\t\t\t\tif (key === 'F')\r\n\t\t\t\t\t\t\treturn 'f';\r\n\t\t\t\t\t\tif (key === 'G')\r\n\t\t\t\t\t\t\treturn 'g';\r\n\t\t\t\t\t\tif (key === 'H')\r\n\t\t\t\t\t\t\treturn 'h';\r\n\t\t\t\t\t\tif (key === 'I')\r\n\t\t\t\t\t\t\treturn 'i';\r\n\t\t\t\t\t\tif (key === 'J')\r\n\t\t\t\t\t\t\treturn 'j';\r\n\t\t\t\t\t\tif (key === 'K')\r\n\t\t\t\t\t\t\treturn 'k';\r\n\t\t\t\t\t\tif (key === 'L')\r\n\t\t\t\t\t\t\treturn 'l';\r\n\t\t\t\t\t\tif (key === 'M')\r\n\t\t\t\t\t\t\treturn 'm';\r\n\t\t\t\t\t\tif (key === 'N')\r\n\t\t\t\t\t\t\treturn 'n';\r\n\t\t\t\t\t\tif (key === 'O')\r\n\t\t\t\t\t\t\treturn 'o';\r\n\t\t\t\t\t\tif (key === 'P')\r\n\t\t\t\t\t\t\treturn 'p';\r\n\t\t\t\t\t\tif (key === 'Q')\r\n\t\t\t\t\t\t\treturn 'q';\r\n\t\t\t\t\t\tif (key === 'R')\r\n\t\t\t\t\t\t\treturn 'r';\r\n\t\t\t\t\t\tif (key === 'S')\r\n\t\t\t\t\t\t\treturn 's';\r\n\t\t\t\t\t\tif (key === 'T')\r\n\t\t\t\t\t\t\treturn 't';\r\n\t\t\t\t\t\tif (key === 'U')\r\n\t\t\t\t\t\t\treturn 'u';\r\n\t\t\t\t\t\tif (key === 'V')\r\n\t\t\t\t\t\t\treturn 'v';\r\n\t\t\t\t\t\tif (key === 'W')\r\n\t\t\t\t\t\t\treturn 'w';\r\n\t\t\t\t\t\tif (key === 'X')\r\n\t\t\t\t\t\t\treturn 'x';\r\n\t\t\t\t\t\tif (key === 'Y')\r\n\t\t\t\t\t\t\treturn 'y';\r\n\t\t\t\t\t\tif (key === 'Z')\r\n\t\t\t\t\t\t\treturn 'z';\r\n\t\t\t\t\t\tif (key === '!')\r\n\t\t\t\t\t\t\treturn '1';\r\n\t\t\t\t\t\tif (key === '@')\r\n\t\t\t\t\t\t\treturn '2';\r\n\t\t\t\t\t\tif (key === '#')\r\n\t\t\t\t\t\t\treturn '3';\r\n\t\t\t\t\t\tif (key === '$')\r\n\t\t\t\t\t\t\treturn '4';\r\n\t\t\t\t\t\tif (key === '%')\r\n\t\t\t\t\t\t\treturn '5';\r\n\t\t\t\t\t\tif (key === '^')\r\n\t\t\t\t\t\t\treturn '6';\r\n\t\t\t\t\t\tif (key === '&')\r\n\t\t\t\t\t\t\treturn '7';\r\n\t\t\t\t\t\tif (key === '*')\r\n\t\t\t\t\t\t\treturn '8';\r\n\t\t\t\t\t\tif (key === '(')\r\n\t\t\t\t\t\t\treturn '9';\r\n\t\t\t\t\t\tif (key === ')')\r\n\t\t\t\t\t\t\treturn '0';\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\treturn key;\r\n\t\t\t\t\t};\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar keyDownHandler = function (e) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (disableArrowKeyScrolling) {\r\n\t\t\t\t\t\t\tif (e.key === 'ArrowRight' || e.key === 'ArrowLeft' || e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === ' ')\r\n\t\t\t\t\t\t\t\te.preventDefault();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar key = mapKeyToCanonicalKey(e.key);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar shouldAdd = true;\r\n\t\t\t\t\t\tfor (let i = 0; i < keysBeingPressed.length; i++) {\r\n\t\t\t\t\t\t\tif (keysBeingPressed[i] === key) {\r\n\t\t\t\t\t\t\t\tshouldAdd = false;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (shouldAdd)\r\n\t\t\t\t\t\t\tkeysBeingPressed.push(key);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tfor (let i = 0; i < keyPressesThatNeedToBeProcessed.length; i++) {\r\n\t\t\t\t\t\t\tif (keyPressesThatNeedToBeProcessed[i] === key)\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tkeyPressesThatNeedToBeProcessed.push(key);\r\n\t\t\t\t\t};\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar keyUpHandler = function (e) {\r\n\t\t\t\t\t\tvar key = mapKeyToCanonicalKey(e.key);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar newArray = [];\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tfor (var i = 0; i < keysBeingPressed.length; i++) {\r\n\t\t\t\t\t\t\tif (keysBeingPressed[i] !== key)\r\n\t\t\t\t\t\t\t\tnewArray.push(keysBeingPressed[i]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tkeysBeingPressed = newArray;\r\n\t\t\t\t\t};\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar processedInputs = function () {\r\n\t\t\t\t\t\tkeyPressesThatNeedToBeProcessed = [];\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tdocument.addEventListener('keydown', function (e) { keyDownHandler(e); }, false);\r\n\t\t\t\t\tdocument.addEventListener('keyup', function (e) { keyUpHandler(e); }, false);\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar isKeyPressed = function (k) {\r\n\t\t\t\t\t\tfor (let i = 0; i < keysBeingPressed.length; i++) {\r\n\t\t\t\t\t\t\tif (keysBeingPressed[i] === k)\r\n\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor (let i = 0; i < keyPressesThatNeedToBeProcessed.length; i++) {\r\n\t\t\t\t\t\t\tif (keyPressesThatNeedToBeProcessed[i] === k)\r\n\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t};\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tisKeyPressed: isKeyPressed,\r\n\t\t\t\t\t\tprocessedInputs: processedInputs\r\n\t\t\t\t\t};\r\n\t\t\t\t})());\r\n\t\t\t");
            }
        },
        methods: {
            ProcessedInputs: function () {
                window.BridgeKeyboardJavascript.processedInputs();
            },
            IsPressed: function (key) {
                var correspondingKeyCode;

                switch (key) {
                    case DTLibrary.Key.A: 
                        correspondingKeyCode = "a";
                        break;
                    case DTLibrary.Key.B: 
                        correspondingKeyCode = "b";
                        break;
                    case DTLibrary.Key.C: 
                        correspondingKeyCode = "c";
                        break;
                    case DTLibrary.Key.D: 
                        correspondingKeyCode = "d";
                        break;
                    case DTLibrary.Key.E: 
                        correspondingKeyCode = "e";
                        break;
                    case DTLibrary.Key.F: 
                        correspondingKeyCode = "f";
                        break;
                    case DTLibrary.Key.G: 
                        correspondingKeyCode = "g";
                        break;
                    case DTLibrary.Key.H: 
                        correspondingKeyCode = "h";
                        break;
                    case DTLibrary.Key.I: 
                        correspondingKeyCode = "i";
                        break;
                    case DTLibrary.Key.J: 
                        correspondingKeyCode = "j";
                        break;
                    case DTLibrary.Key.K: 
                        correspondingKeyCode = "k";
                        break;
                    case DTLibrary.Key.L: 
                        correspondingKeyCode = "l";
                        break;
                    case DTLibrary.Key.M: 
                        correspondingKeyCode = "m";
                        break;
                    case DTLibrary.Key.N: 
                        correspondingKeyCode = "n";
                        break;
                    case DTLibrary.Key.O: 
                        correspondingKeyCode = "o";
                        break;
                    case DTLibrary.Key.P: 
                        correspondingKeyCode = "p";
                        break;
                    case DTLibrary.Key.Q: 
                        correspondingKeyCode = "q";
                        break;
                    case DTLibrary.Key.R: 
                        correspondingKeyCode = "r";
                        break;
                    case DTLibrary.Key.S: 
                        correspondingKeyCode = "s";
                        break;
                    case DTLibrary.Key.T: 
                        correspondingKeyCode = "t";
                        break;
                    case DTLibrary.Key.U: 
                        correspondingKeyCode = "u";
                        break;
                    case DTLibrary.Key.V: 
                        correspondingKeyCode = "v";
                        break;
                    case DTLibrary.Key.W: 
                        correspondingKeyCode = "w";
                        break;
                    case DTLibrary.Key.X: 
                        correspondingKeyCode = "x";
                        break;
                    case DTLibrary.Key.Y: 
                        correspondingKeyCode = "y";
                        break;
                    case DTLibrary.Key.Z: 
                        correspondingKeyCode = "z";
                        break;
                    case DTLibrary.Key.Zero: 
                        correspondingKeyCode = "0";
                        break;
                    case DTLibrary.Key.One: 
                        correspondingKeyCode = "1";
                        break;
                    case DTLibrary.Key.Two: 
                        correspondingKeyCode = "2";
                        break;
                    case DTLibrary.Key.Three: 
                        correspondingKeyCode = "3";
                        break;
                    case DTLibrary.Key.Four: 
                        correspondingKeyCode = "4";
                        break;
                    case DTLibrary.Key.Five: 
                        correspondingKeyCode = "5";
                        break;
                    case DTLibrary.Key.Six: 
                        correspondingKeyCode = "6";
                        break;
                    case DTLibrary.Key.Seven: 
                        correspondingKeyCode = "7";
                        break;
                    case DTLibrary.Key.Eight: 
                        correspondingKeyCode = "8";
                        break;
                    case DTLibrary.Key.Nine: 
                        correspondingKeyCode = "9";
                        break;
                    case DTLibrary.Key.UpArrow: 
                        correspondingKeyCode = "ArrowUp";
                        break;
                    case DTLibrary.Key.DownArrow: 
                        correspondingKeyCode = "ArrowDown";
                        break;
                    case DTLibrary.Key.LeftArrow: 
                        correspondingKeyCode = "ArrowLeft";
                        break;
                    case DTLibrary.Key.RightArrow: 
                        correspondingKeyCode = "ArrowRight";
                        break;
                    case DTLibrary.Key.Delete: 
                        correspondingKeyCode = "Delete";
                        break;
                    case DTLibrary.Key.Backspace: 
                        correspondingKeyCode = "Backspace";
                        break;
                    case DTLibrary.Key.Enter: 
                        correspondingKeyCode = "Enter";
                        break;
                    case DTLibrary.Key.Shift: 
                        correspondingKeyCode = "Shift";
                        break;
                    case DTLibrary.Key.Space: 
                        correspondingKeyCode = " ";
                        break;
                    case DTLibrary.Key.Esc: 
                        correspondingKeyCode = "Escape";
                        break;
                    default: 
                        throw new System.Exception();
                }

                var result = window.BridgeKeyboardJavascript.isKeyPressed(correspondingKeyCode);

                if (result) {
                    return true;
                }

                return false;

            }
        }
    });

    Bridge.define("ChessCompStompWithHacks.BridgeMouse", {
        inherits: [DTLibrary.IMouse],
        alias: [
            "GetX", "DTLibrary$IMouse$GetX",
            "GetY", "DTLibrary$IMouse$GetY",
            "IsLeftMouseButtonPressed", "DTLibrary$IMouse$IsLeftMouseButtonPressed",
            "IsRightMouseButtonPressed", "DTLibrary$IMouse$IsRightMouseButtonPressed"
        ],
        ctors: {
            ctor: function (canvasScalingFactor) {
                this.$initialize();
                eval("\r\n\t\t\t\twindow.BridgeMouseJavascript = ((function () {\r\n\t\t\t\t\t'use strict';\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar mouseXPosition = -50;\r\n\t\t\t\t\tvar mouseYPosition = -50;\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar canvas = null;\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar mouseMoveHandler = function (e) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tif (canvas === null) {\r\n\t\t\t\t\t\t\tcanvas = document.getElementById('bridgeCanvas');\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif (canvas === null)\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar canvasCssWidth = canvas.offsetWidth;\r\n\t\t\t\t\t\tvar canvasCssHeight = canvas.offsetHeight;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar xPosition = (e.pageX !== null && e.pageX !== undefined ? e.pageX : e.clientX) - canvas.offsetLeft;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar canvasXScaling = canvasCssWidth / canvas.width;\r\n\t\t\t\t\t\tif (canvasXScaling < 0.001)\r\n\t\t\t\t\t\t\tcanvasXScaling = 0.001;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\txPosition = Math.round(xPosition / canvasXScaling);\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (xPosition < -5)\r\n\t\t\t\t\t\t\txPosition = -5;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (xPosition > canvas.width + 5)\r\n\t\t\t\t\t\t\txPosition = canvas.width + 5;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar yPosition = (e.pageY !== null && e.pageY !== undefined ? e.pageY : e.clientY) - canvas.offsetTop;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar canvasYScaling = canvasCssHeight / canvas.height;\r\n\t\t\t\t\t\tif (canvasYScaling < 0.001)\r\n\t\t\t\t\t\t\tcanvasYScaling = 0.001;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tyPosition = Math.round(yPosition / canvasYScaling);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (yPosition < -5)\r\n\t\t\t\t\t\t\tyPosition = -5;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (yPosition > canvas.height + 5)\r\n\t\t\t\t\t\t\tyPosition = canvas.height + 5;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tlet canvasScalingFactor = " + (DTLibrary.StringUtil.ToStringCultureInvariant(canvasScalingFactor) || "") + ";\r\n\t\t\t\t\t\tmouseXPosition = Math.floor(xPosition / canvasScalingFactor);\r\n\t\t\t\t\t\tmouseYPosition = Math.floor((canvas.height - yPosition - 1) / canvasScalingFactor);\r\n\t\t\t\t\t};\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar isLeftMouseButtonPressed = false;\r\n\t\t\t\t\tvar isRightMouseButtonPressed = false;\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar previousIsLeftMouseButtonPressed = false;\r\n\t\t\t\t\tvar previousIsRightMouseButtonPressed = false;\r\n\r\n\t\t\t\t\tvar shouldProcessLeftMouseButtonPress = false;\r\n\t\t\t\t\tvar shouldProcessRightMouseButtonPress = false;\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar checkMouseButtonHandler = function (e) {\r\n\t\t\t\t\t\tif ((e.buttons & 1) === 1) {\r\n\t\t\t\t\t\t\tisLeftMouseButtonPressed = true;\r\n\t\t\t\t\t\t\tif (!previousIsLeftMouseButtonPressed)\r\n\t\t\t\t\t\t\t\tshouldProcessLeftMouseButtonPress = true;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tisLeftMouseButtonPressed = false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif ((e.buttons & 2) === 2) {\r\n\t\t\t\t\t\t\tisRightMouseButtonPressed = true;\r\n\t\t\t\t\t\t\tif (!previousIsRightMouseButtonPressed)\r\n\t\t\t\t\t\t\t\tshouldProcessRightMouseButtonPress = true;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tisRightMouseButtonPressed = false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tvar processedInputs = function () {\r\n\t\t\t\t\t\tpreviousIsLeftMouseButtonPressed = isLeftMouseButtonPressed || shouldProcessLeftMouseButtonPress;\r\n\t\t\t\t\t\tpreviousIsRightMouseButtonPressed = isRightMouseButtonPressed || shouldProcessRightMouseButtonPress;\r\n\t\t\t\t\t\tshouldProcessLeftMouseButtonPress = false;\r\n\t\t\t\t\t\tshouldProcessRightMouseButtonPress = false;\r\n\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\tvar disableContextMenu;\r\n\t\t\t\t\tdisableContextMenu = function () {\r\n\t\t\t\t\t\tif (canvas === null) {\r\n\t\t\t\t\t\t\tcanvas = document.getElementById('bridgeCanvas');\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif (canvas === null) {\r\n\t\t\t\t\t\t\t\tsetTimeout(disableContextMenu, 50);\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcanvas.addEventListener('contextmenu', function (e) { e.preventDefault(); });\r\n\t\t\t\t\t};\r\n\t\t\t\t\tdisableContextMenu();\r\n\t\t\t\t\t\r\n\t\t\t\t\tdocument.addEventListener('pointermove', function (e) { mouseMoveHandler(e); checkMouseButtonHandler(e); });\r\n\t\t\t\t\tdocument.addEventListener('pointerdown', function (e) { mouseMoveHandler(e); checkMouseButtonHandler(e); });\r\n\t\t\t\t\tdocument.addEventListener('pointerup', function (e) { mouseMoveHandler(e); checkMouseButtonHandler(e); });\r\n\t\t\t\t\tdocument.addEventListener('pointercancel', function (e) { mouseMoveHandler(e); checkMouseButtonHandler(e); });\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tisLeftMouseButtonPressed: function () { return isLeftMouseButtonPressed || shouldProcessLeftMouseButtonPress; },\r\n\t\t\t\t\t\tisRightMouseButtonPressed: function () { return isRightMouseButtonPressed || shouldProcessRightMouseButtonPress; },\r\n\t\t\t\t\t\tgetMouseX: function () { return Math.round(mouseXPosition); },\r\n\t\t\t\t\t\tgetMouseY: function () { return Math.round(mouseYPosition); },\r\n\t\t\t\t\t\tprocessedInputs: processedInputs\r\n\t\t\t\t\t};\r\n\t\t\t\t})());\r\n\t\t\t");
            }
        },
        methods: {
            GetX: function () {
                return window.BridgeMouseJavascript.getMouseX();
            },
            GetY: function () {
                return window.BridgeMouseJavascript.getMouseY();
            },
            IsLeftMouseButtonPressed: function () {
                return window.BridgeMouseJavascript.isLeftMouseButtonPressed();
            },
            IsRightMouseButtonPressed: function () {
                return window.BridgeMouseJavascript.isRightMouseButtonPressed();
            },
            ProcessedInputs: function () {
                window.BridgeMouseJavascript.processedInputs();
            }
        }
    });

    Bridge.definei("DTLibrary.IMusic$1", function (MusicEnum) { return {
        inherits: [DTLibrary.IMusicOutput$1(MusicEnum),DTLibrary.IMusicProcessing,DTLibrary.IMusicCleanup],
        $kind: "interface"
    }; });

    Bridge.define("ChessCompStompWithHacksLibrary.GameMusic", {
        $kind: "enum",
        statics: {
            fields: {
                TitleScreen: 0,
                Level1: 1,
                Level2: 2,
                Level3: 3,
                Ending: 4
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.GameSound", {
        $kind: "enum",
        statics: {
            fields: {
                PlayerMove: 0,
                AIMove: 1,
                Win: 2,
                StalemateOrDefeat: 3,
                NukeLaunch: 4,
                NukeExplosion: 5,
                Click: 6,
                Woosh: 7
            }
        }
    });

    Bridge.define("ChessCompStompWithHacks.GameInitializer.CanvasWidthAndHeightInfo", {
        inherits: [ChessCompStompWithHacks.BridgeDisplay.ICanvasWidthAndHeightInfo],
        $kind: "nested class",
        fields: {
            canvasWidth: 0,
            canvasHeight: 0
        },
        alias: [
            "GetCurrentCanvasWidth", "ChessCompStompWithHacks$BridgeDisplay$ICanvasWidthAndHeightInfo$GetCurrentCanvasWidth",
            "GetCurrentCanvasHeight", "ChessCompStompWithHacks$BridgeDisplay$ICanvasWidthAndHeightInfo$GetCurrentCanvasHeight"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                this.canvasWidth = ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH;
                this.canvasHeight = ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT;
            }
        },
        methods: {
            SetCurrentCanvasWidth: function (width) {
                this.canvasWidth = width;
            },
            SetCurrentCanvasHeight: function (height) {
                this.canvasHeight = height;
            },
            GetCurrentCanvasWidth: function () {
                return this.canvasWidth;
            },
            GetCurrentCanvasHeight: function () {
                return this.canvasHeight;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.AIPondering.PonderingLogger", {
        inherits: [DTLibrary.IDTLogger],
        $kind: "nested class",
        fields: {
            underlyingLogger: null,
            beginLogging: false
        },
        alias: [
            "Write", "DTLibrary$IDTLogger$Write",
            "WriteLine$1", "DTLibrary$IDTLogger$WriteLine$1",
            "WriteLine", "DTLibrary$IDTLogger$WriteLine"
        ],
        ctors: {
            ctor: function (underlyingLogger) {
                this.$initialize();
                this.underlyingLogger = underlyingLogger;
                this.beginLogging = false;
            }
        },
        methods: {
            BeginLogging: function () {
                this.beginLogging = true;
            },
            Write: function (str) {
                if (this.beginLogging) {
                    this.underlyingLogger.DTLibrary$IDTLogger$Write(str);
                }
            },
            WriteLine$1: function (str) {
                this.Write((str || "") + "\n");
            },
            WriteLine: function () {
                this.Write("\n");
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.AlphaBetaAI", {
        inherits: [ChessCompStompWithHacksEngine.IChessAI],
        statics: {
            methods: {
                GetDepthOfNextSearch: function (depthOfBestMoveFoundSoFar) {
                    var returnValue = (depthOfBestMoveFoundSoFar + 2) | 0;

                    if (returnValue > 50) {
                        returnValue = 50;
                    }

                    return returnValue;
                }
            }
        },
        fields: {
            startTimeMicroSeconds: System.Int64(0),
            originalGameState: null,
            gameStateWithNoNuke: null,
            timer: null,
            random: null,
            logger: null,
            boardEvaluator: null,
            alphaBetaProcess: null,
            bestMoveFoundSoFar: null,
            depthOfBestMoveFoundSoFar: null,
            bestMoveLogString: null,
            topLevelMoves: null
        },
        alias: [
            "GetStartTimeMicroSeconds", "ChessCompStompWithHacksEngine$IChessAI$GetStartTimeMicroSeconds",
            "GetBestMoveFoundSoFar", "ChessCompStompWithHacksEngine$IChessAI$GetBestMoveFoundSoFar",
            "GetDepthOfBestMoveFoundSoFar", "ChessCompStompWithHacksEngine$IChessAI$GetDepthOfBestMoveFoundSoFar",
            "HasFinishedCalculation", "ChessCompStompWithHacksEngine$IChessAI$HasFinishedCalculation",
            "CalculateBestMove", "ChessCompStompWithHacksEngine$IChessAI$CalculateBestMove"
        ],
        ctors: {
            ctor: function (gameState, timer, random, logger) {
                this.$initialize();
                this.startTimeMicroSeconds = timer.DTLibrary$ITimer$GetNumberOfMicroSeconds();

                this.originalGameState = gameState;
                this.gameStateWithNoNuke = gameState.IsPlayerTurn() && gameState.Abilities.HasTacticalNuke && gameState.HasUsedNuke === false ? gameState : ChessCompStompWithHacksEngine.GameStateUtil.GetGameStateWithoutNukeAbility(gameState);
                this.timer = timer;
                this.random = random;
                this.logger = logger;
                this.boardEvaluator = new ChessCompStompWithHacksEngine.StandardBoardEvaluator(random);

                var result = ChessCompStompWithHacksEngine.ComputeMoves.GetMoves(gameState);

                if (result.GameStatus === ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.InProgress) {
                    this.alphaBetaProcess = null;
                    this.bestMoveFoundSoFar = result.Moves.getItem(random.DTLibrary$IDTRandom$NextInt(result.Moves.Count));
                    this.depthOfBestMoveFoundSoFar = 0;
                    this.bestMoveLogString = "Found best move at depth 0.";

                    var moves = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.Move)).$ctor1(result.Moves);
                    DTLibrary.ListUtil.Shuffle(ChessCompStompWithHacksEngine.Move, moves, random);
                    this.topLevelMoves = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.Move)).ctor();
                    var nonPawnAndCapturingMoves = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.Move)).ctor();
                    for (var i = 0; i < moves.Count; i = (i + 1) | 0) {
                        if (ChessCompStompWithHacksEngine.MoveUtil.IsPawnMove(moves.getItem(i), gameState.Board) || ChessCompStompWithHacksEngine.MoveUtil.IsCapturingMove(moves.getItem(i), gameState.Board)) {
                            this.topLevelMoves.add(moves.getItem(i));
                        } else {
                            nonPawnAndCapturingMoves.add(moves.getItem(i));
                        }
                    }
                    this.topLevelMoves.AddRange(nonPawnAndCapturingMoves);
                } else {
                    this.alphaBetaProcess = null;
                    this.bestMoveFoundSoFar = null;
                    this.depthOfBestMoveFoundSoFar = null;
                    this.bestMoveLogString = null;

                    this.topLevelMoves = null;
                }
            }
        },
        methods: {
            GetStartTimeMicroSeconds: function () {
                return this.startTimeMicroSeconds;
            },
            GetBestMoveFoundSoFar: function () {
                if (this.bestMoveFoundSoFar == null) {
                    throw new System.Exception();
                }

                if (this.bestMoveLogString != null) {
                    this.logger.DTLibrary$IDTLogger$WriteLine$1(this.bestMoveLogString);
                }

                return this.bestMoveFoundSoFar;
            },
            GetDepthOfBestMoveFoundSoFar: function () {
                if (this.depthOfBestMoveFoundSoFar == null) {
                    throw new System.Exception();
                }
                return System.Nullable.getValue(this.depthOfBestMoveFoundSoFar);
            },
            HasFinishedCalculation: function () {
                return false;
            },
            CalculateBestMove: function (millisecondsToThink) {
                if (this.bestMoveFoundSoFar == null) {
                    return;
                }

                var count = 0;
                var startingTimeMillis = this.timer.DTLibrary$ITimer$GetNumberOfMicroSeconds().div(System.Int64(1000));
                while (true) {
                    count = (count + 1) | 0;
                    if (count === 5) {
                        count = 0;
                        var currentTimeMillis = this.timer.DTLibrary$ITimer$GetNumberOfMicroSeconds().div(System.Int64(1000));
                        var elapsedTimeAsLong = currentTimeMillis.sub(startingTimeMillis);
                        var elapsedTimeMillis = System.Int64.clip32(elapsedTimeAsLong);

                        if (elapsedTimeMillis >= millisecondsToThink) {
                            return;
                        }
                    }

                    if (this.alphaBetaProcess == null) {
                        this.alphaBetaProcess = Bridge.getEnumerator(this.BeginAlphaBeta(this.gameStateWithNoNuke, ChessCompStompWithHacksEngine.AlphaBetaAI.GetDepthOfNextSearch(System.Nullable.getValue(this.depthOfBestMoveFoundSoFar))));
                    } else {
                        this.alphaBetaProcess.System$Collections$IEnumerator$moveNext();
                        var value = this.alphaBetaProcess.System$Collections$IEnumerator$Current;
                        if (value != null) {
                            this.bestMoveFoundSoFar = Bridge.cast(value, ChessCompStompWithHacksEngine.Move);
                            this.depthOfBestMoveFoundSoFar = ChessCompStompWithHacksEngine.AlphaBetaAI.GetDepthOfNextSearch(System.Nullable.getValue(this.depthOfBestMoveFoundSoFar));
                            this.alphaBetaProcess = null;
                        }
                    }
                }
            },
            BeginAlphaBeta: function (gameState, depth) {
                return new Bridge.GeneratorEnumerable(Bridge.fn.bind(this, function (gameState, depth) {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        best,
                        bestMove,
                        alpha,
                        i,
                        move,
                        invoke,
                        temp,
                        $t,
                        x,
                        moveValue,
                        $async_e;

                    var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        best = null;
                                            bestMove = null;
                                            alpha = null;
                                            i = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < this.topLevelMoves.Count ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 8;
                                        continue;
                                    }
                                    case 2: {
                                        move = this.topLevelMoves.getItem(i);
                                            invoke = this.AlphaBetaHelper(ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(gameState, move), ((depth - 1) | 0), alpha, null, false);

                                            temp = null;
                                            $t = Bridge.getEnumerator(invoke);
                                            $step = 3;
                                            continue;
                                    }
                                    case 3: {
                                        if ($t.moveNext()) {
                                                x = $t.Current;
                                                $step = 4;
                                                continue;
                                            }
                                        $step = 6;
                                        continue;
                                    }
                                    case 4: {
                                        $enumerator.current = null;
                                            $step = 5;
                                            return true;
                                    }
                                    case 5: {
                                        if (x != null) {
                                                temp = Bridge.cast(Bridge.unbox(x, System.Int32), System.Int32, true);
                                            }
                                        $step = 3;
                                        continue;
                                    }
                                    case 6: {
                                        if (temp == null) {
                                                throw new System.Exception();
                                            }
                                            moveValue = System.Nullable.getValue(temp);

                                            if (best == null || moveValue > System.Nullable.getValue(best)) {
                                                best = moveValue;
                                                bestMove = move;
                                            }

                                            if (alpha == null || System.Nullable.getValue(best) >= System.Nullable.getValue(alpha)) {
                                                alpha = System.Nullable.getValue(best);
                                            }
                                        $step = 7;
                                        continue;
                                    }
                                    case 7: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 8: {
                                        if (bestMove == null) {
                                                throw new System.Exception();
                                            }

                                            this.bestMoveLogString = "Found best move at depth " + (DTLibrary.StringUtil.ToStringCultureInvariant(depth) || "") + " with score: " + ((gameState.IsWhiteTurn ? DTLibrary.StringUtil.ToStringCultureInvariant(System.Nullable.getValue(best)) : DTLibrary.StringUtil.ToStringCultureInvariant((((-System.Nullable.getValue(best)) | 0)))) || "");
                                            $enumerator.current = bestMove;
                                            $step = 9;
                                            return true;
                                    }
                                    case 9: {
                                        return false;
                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }, arguments));
            },
            AlphaBetaHelper: function (gameState, depth, alpha, beta, isCurrentPlayer) {
                return new Bridge.GeneratorEnumerable(Bridge.fn.bind(this, function (gameState, depth, alpha, beta, isCurrentPlayer) {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        returnValue,
                        result,
                        returnValue1,
                        returnValue2,
                        returnValue3,
                        best,
                        i,
                        move,
                        invoke,
                        temp,
                        $t,
                        x,
                        moveValue,
                        best1,
                        i1,
                        move1,
                        invoke1,
                        temp1,
                        $t1,
                        x1,
                        moveValue1,
                        $async_e;

                    var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        if (depth === 0) {
                                                $step = 1;
                                                continue;
                                            } 
                                            $step = 3;
                                            continue;
                                    }
                                    case 1: {
                                        returnValue = this.boardEvaluator.ChessCompStompWithHacksEngine$IBoardEvaluator$Evaluate(gameState, this.originalGameState.IsWhiteTurn);
                                            $enumerator.current = Bridge.box(returnValue, System.Int32, System.Nullable.toString, System.Nullable.getHashCode);
                                            $step = 2;
                                            return true;
                                    }
                                    case 2: {
                                        return false;
                                    }
                                    case 3: {
                                        result = ChessCompStompWithHacksEngine.ComputeMoves.GetMoves(gameState);

                                            if (result.GameStatus === ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.Stalemate) {
                                                $step = 4;
                                                continue;
                                            } 
                                            $step = 6;
                                            continue;
                                    }
                                    case 4: {
                                        returnValue1 = 0;
                                            $enumerator.current = Bridge.box(returnValue1, System.Int32, System.Nullable.toString, System.Nullable.getHashCode);
                                            $step = 5;
                                            return true;
                                    }
                                    case 5: {
                                        return false;
                                    }
                                    case 6: {
                                        if (result.GameStatus === ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.WhiteVictory) {
                                                $step = 7;
                                                continue;
                                            } 
                                            $step = 9;
                                            continue;
                                    }
                                    case 7: {
                                        if (this.originalGameState.IsWhiteTurn) {
                                                returnValue2 = Bridge.Int.clip32(2147482647 + depth);
                                            } else {
                                                returnValue2 = Bridge.Int.clip32(-2147482648 - depth);
                                            }
                                            $enumerator.current = Bridge.box(returnValue2, System.Int32, System.Nullable.toString, System.Nullable.getHashCode);
                                            $step = 8;
                                            return true;
                                    }
                                    case 8: {
                                        return false;
                                    }
                                    case 9: {
                                        if (result.GameStatus === ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.BlackVictory) {
                                                $step = 10;
                                                continue;
                                            } 
                                            $step = 12;
                                            continue;
                                    }
                                    case 10: {
                                        if (this.originalGameState.IsWhiteTurn) {
                                                returnValue3 = Bridge.Int.clip32(-2147482648 - depth);
                                            } else {
                                                returnValue3 = Bridge.Int.clip32(2147482647 + depth);
                                            }
                                            $enumerator.current = Bridge.box(returnValue3, System.Int32, System.Nullable.toString, System.Nullable.getHashCode);
                                            $step = 11;
                                            return true;
                                    }
                                    case 11: {
                                        return false;
                                    }
                                    case 12: {
                                        if (isCurrentPlayer) {
                                                $step = 13;
                                                continue;
                                            } else  {
                                                $step = 23;
                                                continue;
                                            }
                                    }
                                    case 13: {
                                        best = null;
                                            i = 0;
                                            $step = 14;
                                            continue;
                                    }
                                    case 14: {
                                        if ( i < result.Moves.Count ) {
                                                $step = 15;
                                                continue;
                                            }
                                        $step = 21;
                                        continue;
                                    }
                                    case 15: {
                                        move = result.Moves.getItem(i);

                                            invoke = this.AlphaBetaHelper(ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(gameState, move), ((depth - 1) | 0), alpha, beta, false);

                                            temp = null;
                                            $t = Bridge.getEnumerator(invoke);
                                            $step = 16;
                                            continue;
                                    }
                                    case 16: {
                                        if ($t.moveNext()) {
                                                x = $t.Current;
                                                $step = 17;
                                                continue;
                                            }
                                        $step = 19;
                                        continue;
                                    }
                                    case 17: {
                                        $enumerator.current = null;
                                            $step = 18;
                                            return true;
                                    }
                                    case 18: {
                                        if (x != null) {
                                                temp = Bridge.cast(Bridge.unbox(x, System.Int32), System.Int32, true);
                                            }
                                        $step = 16;
                                        continue;
                                    }
                                    case 19: {
                                        if (temp == null) {
                                                throw new System.Exception();
                                            }
                                            moveValue = System.Nullable.getValue(temp);

                                            if (best == null || moveValue >= System.Nullable.getValue(best)) {
                                                best = moveValue;
                                            }

                                            if (alpha == null || System.Nullable.getValue(best) >= System.Nullable.getValue(alpha)) {
                                                alpha = System.Nullable.getValue(best);
                                            }

                                            if (System.Nullable.hasValue(alpha) && System.Nullable.hasValue(beta) && System.Nullable.getValue(alpha) >= System.Nullable.getValue(beta)) {
                                                $step = 21;
                                                continue;
                                            }
                                        $step = 20;
                                        continue;
                                    }
                                    case 20: {
                                        i = (i + 1) | 0;
                                        $step = 14;
                                        continue;
                                    }
                                    case 21: {
                                        if (best == null) {
                                                throw new System.Exception();
                                            }

                                            $enumerator.current = Bridge.box(best, System.Int32, System.Nullable.toString, System.Nullable.getHashCode);
                                            $step = 22;
                                            return true;
                                    }
                                    case 22: {
                                        return false;
                                    }
                                    case 23: {
                                        best1 = null;
                                            i1 = 0;
                                            $step = 24;
                                            continue;
                                    }
                                    case 24: {
                                        if ( i1 < result.Moves.Count ) {
                                                $step = 25;
                                                continue;
                                            }
                                        $step = 31;
                                        continue;
                                    }
                                    case 25: {
                                        move1 = result.Moves.getItem(i1);

                                            invoke1 = this.AlphaBetaHelper(ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(gameState, move1), ((depth - 1) | 0), alpha, beta, true);

                                            temp1 = null;
                                            $t1 = Bridge.getEnumerator(invoke1);
                                            $step = 26;
                                            continue;
                                    }
                                    case 26: {
                                        if ($t1.moveNext()) {
                                                x1 = $t1.Current;
                                                $step = 27;
                                                continue;
                                            }
                                        $step = 29;
                                        continue;
                                    }
                                    case 27: {
                                        $enumerator.current = null;
                                            $step = 28;
                                            return true;
                                    }
                                    case 28: {
                                        if (x1 != null) {
                                                temp1 = Bridge.cast(Bridge.unbox(x1, System.Int32), System.Int32, true);
                                            }
                                        $step = 26;
                                        continue;
                                    }
                                    case 29: {
                                        if (temp1 == null) {
                                                throw new System.Exception();
                                            }
                                            moveValue1 = System.Nullable.getValue(temp1);

                                            if (best1 == null || moveValue1 <= System.Nullable.getValue(best1)) {
                                                best1 = moveValue1;
                                            }

                                            if (beta == null || System.Nullable.getValue(best1) <= System.Nullable.getValue(beta)) {
                                                beta = System.Nullable.getValue(best1);
                                            }

                                            if (System.Nullable.hasValue(alpha) && System.Nullable.hasValue(beta) && System.Nullable.getValue(beta) <= System.Nullable.getValue(alpha)) {
                                                $step = 31;
                                                continue;
                                            }
                                        $step = 30;
                                        continue;
                                    }
                                    case 30: {
                                        i1 = (i1 + 1) | 0;
                                        $step = 24;
                                        continue;
                                    }
                                    case 31: {
                                        if (best1 == null) {
                                                throw new System.Exception();
                                            }
                                            $enumerator.current = Bridge.box(best1, System.Int32, System.Nullable.toString, System.Nullable.getHashCode);
                                            $step = 32;
                                            return true;
                                    }
                                    case 32: {
                                        return false;
                                    }
                                    case 33: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }, arguments));
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.CompositeAI", {
        inherits: [ChessCompStompWithHacksEngine.IChessAI],
        fields: {
            startTimeMicroSeconds: System.Int64(0),
            underlyingAI: null
        },
        alias: [
            "GetStartTimeMicroSeconds", "ChessCompStompWithHacksEngine$IChessAI$GetStartTimeMicroSeconds",
            "GetBestMoveFoundSoFar", "ChessCompStompWithHacksEngine$IChessAI$GetBestMoveFoundSoFar",
            "GetDepthOfBestMoveFoundSoFar", "ChessCompStompWithHacksEngine$IChessAI$GetDepthOfBestMoveFoundSoFar",
            "HasFinishedCalculation", "ChessCompStompWithHacksEngine$IChessAI$HasFinishedCalculation",
            "CalculateBestMove", "ChessCompStompWithHacksEngine$IChessAI$CalculateBestMove"
        ],
        ctors: {
            ctor: function (gameState, timer, random, logger, useDebugAI) {
                this.$initialize();
                this.startTimeMicroSeconds = timer.DTLibrary$ITimer$GetNumberOfMicroSeconds();

                var result = ChessCompStompWithHacksEngine.ComputeMoves.GetMoves(gameState);
                if (result.GameStatus === ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.InProgress && result.Moves.Count === 1) {
                    this.underlyingAI = new ChessCompStompWithHacksEngine.OnlyPossibleMoveAI(result.Moves.getItem(0), timer, logger);
                } else {
                    if (useDebugAI) {
                        this.underlyingAI = new ChessCompStompWithHacksEngine.RandomMoveAI(gameState, timer, random, logger);
                    } else {
                        if (gameState.TurnCount <= 4) {
                            this.underlyingAI = new ChessCompStompWithHacksEngine.RandomMoveAI(gameState, timer, random, logger);
                        } else {
                            if (gameState.TurnCount <= 20) {
                                this.underlyingAI = new ChessCompStompWithHacksEngine.EarlyGameAI(gameState, timer, random, logger);
                            } else {
                                this.underlyingAI = new ChessCompStompWithHacksEngine.AlphaBetaAI(gameState, timer, random, logger);
                            }
                        }
                    }
                }
            }
        },
        methods: {
            GetStartTimeMicroSeconds: function () {
                return this.startTimeMicroSeconds;
            },
            GetBestMoveFoundSoFar: function () {
                return this.underlyingAI.ChessCompStompWithHacksEngine$IChessAI$GetBestMoveFoundSoFar();
            },
            GetDepthOfBestMoveFoundSoFar: function () {
                return this.underlyingAI.ChessCompStompWithHacksEngine$IChessAI$GetDepthOfBestMoveFoundSoFar();
            },
            HasFinishedCalculation: function () {
                return this.underlyingAI.ChessCompStompWithHacksEngine$IChessAI$HasFinishedCalculation();
            },
            CalculateBestMove: function (millisecondsToThink) {
                this.underlyingAI.ChessCompStompWithHacksEngine$IChessAI$CalculateBestMove(millisecondsToThink);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.EarlyGameAI", {
        inherits: [ChessCompStompWithHacksEngine.IChessAI],
        statics: {
            methods: {
                GetDepthOfNextSearch: function (depthOfBestMoveFoundSoFar) {
                    var returnValue = (depthOfBestMoveFoundSoFar + 2) | 0;

                    if (returnValue > 50) {
                        returnValue = 50;
                    }

                    return returnValue;
                }
            }
        },
        fields: {
            startTimeMicroSeconds: System.Int64(0),
            originalGameState: null,
            gameStateWithNoNuke: null,
            timer: null,
            random: null,
            logger: null,
            boardEvaluator: null,
            alphaBetaProcess: null,
            bestMoveFoundSoFar: null,
            depthOfBestMoveFoundSoFar: null,
            bestMoveLogString: null,
            topLevelMoves: null
        },
        alias: [
            "GetStartTimeMicroSeconds", "ChessCompStompWithHacksEngine$IChessAI$GetStartTimeMicroSeconds",
            "GetBestMoveFoundSoFar", "ChessCompStompWithHacksEngine$IChessAI$GetBestMoveFoundSoFar",
            "GetDepthOfBestMoveFoundSoFar", "ChessCompStompWithHacksEngine$IChessAI$GetDepthOfBestMoveFoundSoFar",
            "HasFinishedCalculation", "ChessCompStompWithHacksEngine$IChessAI$HasFinishedCalculation",
            "CalculateBestMove", "ChessCompStompWithHacksEngine$IChessAI$CalculateBestMove"
        ],
        ctors: {
            ctor: function (gameState, timer, random, logger) {
                this.$initialize();
                this.startTimeMicroSeconds = timer.DTLibrary$ITimer$GetNumberOfMicroSeconds();

                this.originalGameState = gameState;
                this.gameStateWithNoNuke = gameState.IsPlayerTurn() && gameState.Abilities.HasTacticalNuke && gameState.HasUsedNuke === false ? gameState : ChessCompStompWithHacksEngine.GameStateUtil.GetGameStateWithoutNukeAbility(gameState);
                this.timer = timer;
                this.random = random;
                this.logger = logger;
                this.boardEvaluator = new ChessCompStompWithHacksEngine.RandomizedBoardEvaluator(random);

                var result = ChessCompStompWithHacksEngine.ComputeMoves.GetMoves(gameState);

                if (result.GameStatus === ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.InProgress) {
                    this.alphaBetaProcess = null;
                    this.bestMoveFoundSoFar = result.Moves.getItem(random.DTLibrary$IDTRandom$NextInt(result.Moves.Count));
                    this.depthOfBestMoveFoundSoFar = 0;
                    this.bestMoveLogString = "Found best move at depth 0.";

                    var moves = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.Move)).$ctor1(result.Moves);
                    DTLibrary.ListUtil.Shuffle(ChessCompStompWithHacksEngine.Move, moves, random);
                    var numberOfMovesToKeep = Math.max(1, ((Bridge.Int.div(Bridge.Int.mul(moves.Count, 3), 4)) | 0));
                    this.topLevelMoves = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.Move)).ctor();
                    for (var i = 0; i < numberOfMovesToKeep; i = (i + 1) | 0) {
                        this.topLevelMoves.add(moves.getItem(i));
                    }
                } else {
                    this.alphaBetaProcess = null;
                    this.bestMoveFoundSoFar = null;
                    this.depthOfBestMoveFoundSoFar = null;
                    this.bestMoveLogString = null;

                    this.topLevelMoves = null;
                }
            }
        },
        methods: {
            GetStartTimeMicroSeconds: function () {
                return this.startTimeMicroSeconds;
            },
            GetBestMoveFoundSoFar: function () {
                if (this.bestMoveFoundSoFar == null) {
                    throw new System.Exception();
                }

                if (this.bestMoveLogString != null) {
                    this.logger.DTLibrary$IDTLogger$WriteLine$1(this.bestMoveLogString);
                }

                return this.bestMoveFoundSoFar;
            },
            GetDepthOfBestMoveFoundSoFar: function () {
                if (this.depthOfBestMoveFoundSoFar == null) {
                    throw new System.Exception();
                }
                return System.Nullable.getValue(this.depthOfBestMoveFoundSoFar);
            },
            HasFinishedCalculation: function () {
                return false;
            },
            CalculateBestMove: function (millisecondsToThink) {
                if (this.bestMoveFoundSoFar == null) {
                    return;
                }

                var count = 0;
                var startingTimeMillis = this.timer.DTLibrary$ITimer$GetNumberOfMicroSeconds().div(System.Int64(1000));
                while (true) {
                    count = (count + 1) | 0;
                    if (count === 5) {
                        count = 0;
                        var currentTimeMillis = this.timer.DTLibrary$ITimer$GetNumberOfMicroSeconds().div(System.Int64(1000));
                        var elapsedTimeAsLong = currentTimeMillis.sub(startingTimeMillis);
                        var elapsedTimeMillis = System.Int64.clip32(elapsedTimeAsLong);

                        if (elapsedTimeMillis >= millisecondsToThink) {
                            return;
                        }
                    }

                    if (this.alphaBetaProcess == null) {
                        this.alphaBetaProcess = Bridge.getEnumerator(this.BeginAlphaBeta(this.gameStateWithNoNuke, ChessCompStompWithHacksEngine.EarlyGameAI.GetDepthOfNextSearch(System.Nullable.getValue(this.depthOfBestMoveFoundSoFar))));
                    } else {
                        this.alphaBetaProcess.System$Collections$IEnumerator$moveNext();
                        var value = this.alphaBetaProcess.System$Collections$IEnumerator$Current;
                        if (value != null) {
                            this.bestMoveFoundSoFar = Bridge.cast(value, ChessCompStompWithHacksEngine.Move);
                            this.depthOfBestMoveFoundSoFar = ChessCompStompWithHacksEngine.EarlyGameAI.GetDepthOfNextSearch(System.Nullable.getValue(this.depthOfBestMoveFoundSoFar));
                            this.alphaBetaProcess = null;
                        }
                    }
                }
            },
            BeginAlphaBeta: function (gameState, depth) {
                return new Bridge.GeneratorEnumerable(Bridge.fn.bind(this, function (gameState, depth) {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        best,
                        bestMove,
                        alpha,
                        i,
                        move,
                        invoke,
                        temp,
                        $t,
                        x,
                        moveValue,
                        $async_e;

                    var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        best = null;
                                            bestMove = null;
                                            alpha = null;
                                            i = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < this.topLevelMoves.Count ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 8;
                                        continue;
                                    }
                                    case 2: {
                                        move = this.topLevelMoves.getItem(i);
                                            invoke = this.AlphaBetaHelper(ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(gameState, move), ((depth - 1) | 0), alpha, null, false);

                                            temp = null;
                                            $t = Bridge.getEnumerator(invoke);
                                            $step = 3;
                                            continue;
                                    }
                                    case 3: {
                                        if ($t.moveNext()) {
                                                x = $t.Current;
                                                $step = 4;
                                                continue;
                                            }
                                        $step = 6;
                                        continue;
                                    }
                                    case 4: {
                                        $enumerator.current = null;
                                            $step = 5;
                                            return true;
                                    }
                                    case 5: {
                                        if (x != null) {
                                                temp = Bridge.cast(Bridge.unbox(x, System.Int32), System.Int32, true);
                                            }
                                        $step = 3;
                                        continue;
                                    }
                                    case 6: {
                                        if (temp == null) {
                                                throw new System.Exception();
                                            }
                                            moveValue = System.Nullable.getValue(temp);

                                            if (best == null || moveValue > System.Nullable.getValue(best)) {
                                                best = moveValue;
                                                bestMove = move;
                                            }

                                            if (alpha == null || System.Nullable.getValue(best) >= System.Nullable.getValue(alpha)) {
                                                alpha = System.Nullable.getValue(best);
                                            }
                                        $step = 7;
                                        continue;
                                    }
                                    case 7: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 8: {
                                        if (bestMove == null) {
                                                throw new System.Exception();
                                            }

                                            this.bestMoveLogString = "Found best move at depth " + (DTLibrary.StringUtil.ToStringCultureInvariant(depth) || "") + " with score: " + ((gameState.IsWhiteTurn ? DTLibrary.StringUtil.ToStringCultureInvariant(System.Nullable.getValue(best)) : DTLibrary.StringUtil.ToStringCultureInvariant((((-System.Nullable.getValue(best)) | 0)))) || "");
                                            $enumerator.current = bestMove;
                                            $step = 9;
                                            return true;
                                    }
                                    case 9: {
                                        return false;
                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }, arguments));
            },
            AlphaBetaHelper: function (gameState, depth, alpha, beta, isCurrentPlayer) {
                return new Bridge.GeneratorEnumerable(Bridge.fn.bind(this, function (gameState, depth, alpha, beta, isCurrentPlayer) {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        returnValue,
                        result,
                        returnValue1,
                        returnValue2,
                        returnValue3,
                        best,
                        i,
                        move,
                        invoke,
                        temp,
                        $t,
                        x,
                        moveValue,
                        best1,
                        i1,
                        move1,
                        invoke1,
                        temp1,
                        $t1,
                        x1,
                        moveValue1,
                        $async_e;

                    var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        if (depth === 0) {
                                                $step = 1;
                                                continue;
                                            } 
                                            $step = 3;
                                            continue;
                                    }
                                    case 1: {
                                        returnValue = this.boardEvaluator.ChessCompStompWithHacksEngine$IBoardEvaluator$Evaluate(gameState, this.originalGameState.IsWhiteTurn);
                                            $enumerator.current = Bridge.box(returnValue, System.Int32, System.Nullable.toString, System.Nullable.getHashCode);
                                            $step = 2;
                                            return true;
                                    }
                                    case 2: {
                                        return false;
                                    }
                                    case 3: {
                                        result = ChessCompStompWithHacksEngine.ComputeMoves.GetMoves(gameState);

                                            if (result.GameStatus === ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.Stalemate) {
                                                $step = 4;
                                                continue;
                                            } 
                                            $step = 6;
                                            continue;
                                    }
                                    case 4: {
                                        returnValue1 = 0;
                                            $enumerator.current = Bridge.box(returnValue1, System.Int32, System.Nullable.toString, System.Nullable.getHashCode);
                                            $step = 5;
                                            return true;
                                    }
                                    case 5: {
                                        return false;
                                    }
                                    case 6: {
                                        if (result.GameStatus === ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.WhiteVictory) {
                                                $step = 7;
                                                continue;
                                            } 
                                            $step = 9;
                                            continue;
                                    }
                                    case 7: {
                                        if (this.originalGameState.IsWhiteTurn) {
                                                returnValue2 = Bridge.Int.clip32(2147482647 + depth);
                                            } else {
                                                returnValue2 = Bridge.Int.clip32(-2147482648 - depth);
                                            }
                                            $enumerator.current = Bridge.box(returnValue2, System.Int32, System.Nullable.toString, System.Nullable.getHashCode);
                                            $step = 8;
                                            return true;
                                    }
                                    case 8: {
                                        return false;
                                    }
                                    case 9: {
                                        if (result.GameStatus === ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.BlackVictory) {
                                                $step = 10;
                                                continue;
                                            } 
                                            $step = 12;
                                            continue;
                                    }
                                    case 10: {
                                        if (this.originalGameState.IsWhiteTurn) {
                                                returnValue3 = Bridge.Int.clip32(-2147482648 - depth);
                                            } else {
                                                returnValue3 = Bridge.Int.clip32(2147482647 + depth);
                                            }
                                            $enumerator.current = Bridge.box(returnValue3, System.Int32, System.Nullable.toString, System.Nullable.getHashCode);
                                            $step = 11;
                                            return true;
                                    }
                                    case 11: {
                                        return false;
                                    }
                                    case 12: {
                                        if (isCurrentPlayer) {
                                                $step = 13;
                                                continue;
                                            } else  {
                                                $step = 23;
                                                continue;
                                            }
                                    }
                                    case 13: {
                                        best = null;
                                            i = 0;
                                            $step = 14;
                                            continue;
                                    }
                                    case 14: {
                                        if ( i < result.Moves.Count ) {
                                                $step = 15;
                                                continue;
                                            }
                                        $step = 21;
                                        continue;
                                    }
                                    case 15: {
                                        move = result.Moves.getItem(i);

                                            invoke = this.AlphaBetaHelper(ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(gameState, move), ((depth - 1) | 0), alpha, beta, false);

                                            temp = null;
                                            $t = Bridge.getEnumerator(invoke);
                                            $step = 16;
                                            continue;
                                    }
                                    case 16: {
                                        if ($t.moveNext()) {
                                                x = $t.Current;
                                                $step = 17;
                                                continue;
                                            }
                                        $step = 19;
                                        continue;
                                    }
                                    case 17: {
                                        $enumerator.current = null;
                                            $step = 18;
                                            return true;
                                    }
                                    case 18: {
                                        if (x != null) {
                                                temp = Bridge.cast(Bridge.unbox(x, System.Int32), System.Int32, true);
                                            }
                                        $step = 16;
                                        continue;
                                    }
                                    case 19: {
                                        if (temp == null) {
                                                throw new System.Exception();
                                            }
                                            moveValue = System.Nullable.getValue(temp);

                                            if (best == null || moveValue >= System.Nullable.getValue(best)) {
                                                best = moveValue;
                                            }

                                            if (alpha == null || System.Nullable.getValue(best) >= System.Nullable.getValue(alpha)) {
                                                alpha = System.Nullable.getValue(best);
                                            }

                                            if (System.Nullable.hasValue(alpha) && System.Nullable.hasValue(beta) && System.Nullable.getValue(alpha) >= System.Nullable.getValue(beta)) {
                                                $step = 21;
                                                continue;
                                            }
                                        $step = 20;
                                        continue;
                                    }
                                    case 20: {
                                        i = (i + 1) | 0;
                                        $step = 14;
                                        continue;
                                    }
                                    case 21: {
                                        if (best == null) {
                                                throw new System.Exception();
                                            }

                                            $enumerator.current = Bridge.box(best, System.Int32, System.Nullable.toString, System.Nullable.getHashCode);
                                            $step = 22;
                                            return true;
                                    }
                                    case 22: {
                                        return false;
                                    }
                                    case 23: {
                                        best1 = null;
                                            i1 = 0;
                                            $step = 24;
                                            continue;
                                    }
                                    case 24: {
                                        if ( i1 < result.Moves.Count ) {
                                                $step = 25;
                                                continue;
                                            }
                                        $step = 31;
                                        continue;
                                    }
                                    case 25: {
                                        move1 = result.Moves.getItem(i1);

                                            invoke1 = this.AlphaBetaHelper(ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(gameState, move1), ((depth - 1) | 0), alpha, beta, true);

                                            temp1 = null;
                                            $t1 = Bridge.getEnumerator(invoke1);
                                            $step = 26;
                                            continue;
                                    }
                                    case 26: {
                                        if ($t1.moveNext()) {
                                                x1 = $t1.Current;
                                                $step = 27;
                                                continue;
                                            }
                                        $step = 29;
                                        continue;
                                    }
                                    case 27: {
                                        $enumerator.current = null;
                                            $step = 28;
                                            return true;
                                    }
                                    case 28: {
                                        if (x1 != null) {
                                                temp1 = Bridge.cast(Bridge.unbox(x1, System.Int32), System.Int32, true);
                                            }
                                        $step = 26;
                                        continue;
                                    }
                                    case 29: {
                                        if (temp1 == null) {
                                                throw new System.Exception();
                                            }
                                            moveValue1 = System.Nullable.getValue(temp1);

                                            if (best1 == null || moveValue1 <= System.Nullable.getValue(best1)) {
                                                best1 = moveValue1;
                                            }

                                            if (beta == null || System.Nullable.getValue(best1) <= System.Nullable.getValue(beta)) {
                                                beta = System.Nullable.getValue(best1);
                                            }

                                            if (System.Nullable.hasValue(alpha) && System.Nullable.hasValue(beta) && System.Nullable.getValue(beta) <= System.Nullable.getValue(alpha)) {
                                                $step = 31;
                                                continue;
                                            }
                                        $step = 30;
                                        continue;
                                    }
                                    case 30: {
                                        i1 = (i1 + 1) | 0;
                                        $step = 24;
                                        continue;
                                    }
                                    case 31: {
                                        if (best1 == null) {
                                                throw new System.Exception();
                                            }
                                            $enumerator.current = Bridge.box(best1, System.Int32, System.Nullable.toString, System.Nullable.getHashCode);
                                            $step = 32;
                                            return true;
                                    }
                                    case 32: {
                                        return false;
                                    }
                                    case 33: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }, arguments));
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.OnlyPossibleMoveAI", {
        inherits: [ChessCompStompWithHacksEngine.IChessAI],
        fields: {
            move: null,
            startTimeMicroSeconds: System.Int64(0),
            logger: null
        },
        alias: [
            "GetStartTimeMicroSeconds", "ChessCompStompWithHacksEngine$IChessAI$GetStartTimeMicroSeconds",
            "GetBestMoveFoundSoFar", "ChessCompStompWithHacksEngine$IChessAI$GetBestMoveFoundSoFar",
            "HasFinishedCalculation", "ChessCompStompWithHacksEngine$IChessAI$HasFinishedCalculation",
            "GetDepthOfBestMoveFoundSoFar", "ChessCompStompWithHacksEngine$IChessAI$GetDepthOfBestMoveFoundSoFar",
            "CalculateBestMove", "ChessCompStompWithHacksEngine$IChessAI$CalculateBestMove"
        ],
        ctors: {
            ctor: function (move, timer, logger) {
                this.$initialize();
                this.move = move;
                this.startTimeMicroSeconds = timer.DTLibrary$ITimer$GetNumberOfMicroSeconds();
                this.logger = logger;
            }
        },
        methods: {
            GetStartTimeMicroSeconds: function () {
                return this.startTimeMicroSeconds;
            },
            GetBestMoveFoundSoFar: function () {
                this.logger.DTLibrary$IDTLogger$WriteLine$1("Found only valid move.");
                return this.move;
            },
            HasFinishedCalculation: function () {
                return true;
            },
            GetDepthOfBestMoveFoundSoFar: function () {
                return 0;
            },
            CalculateBestMove: function (millisecondsToThink) { }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.RandomizedBoardEvaluator", {
        inherits: [ChessCompStompWithHacksEngine.IBoardEvaluator],
        fields: {
            random: null,
            pawnValue: 0,
            knightValue: 0,
            bishopValue: 0,
            rookValue: 0,
            queenValue: 0,
            kingValue: 0
        },
        alias: ["Evaluate", "ChessCompStompWithHacksEngine$IBoardEvaluator$Evaluate"],
        ctors: {
            ctor: function (random) {
                this.$initialize();
                this.random = random;
                this.pawnValue = (random.DTLibrary$IDTRandom$NextInt(61) + 70) | 0;
                this.knightValue = (random.DTLibrary$IDTRandom$NextInt(201) + 200) | 0;
                this.bishopValue = (random.DTLibrary$IDTRandom$NextInt(201) + 200) | 0;
                this.rookValue = (random.DTLibrary$IDTRandom$NextInt(201) + 400) | 0;
                this.queenValue = (random.DTLibrary$IDTRandom$NextInt(201) + 800) | 0;
                this.kingValue = (random.DTLibrary$IDTRandom$NextInt(201) + 300) | 0;
            }
        },
        methods: {
            Evaluate: function (gameState, isWhite) {
                var whiteScore = 0;
                var blackScore = 0;

                for (var i = 0; i < 8; i = (i + 1) | 0) {
                    for (var j = 0; j < 8; j = (j + 1) | 0) {
                        switch (gameState.Board.GetPiece$1(i, j)) {
                            case ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn: 
                                whiteScore = (whiteScore + this.pawnValue) | 0;
                                whiteScore = (whiteScore + (Bridge.Int.mul(10, (((j - 1) | 0))))) | 0;
                                break;
                            case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKnight: 
                                whiteScore = (whiteScore + this.knightValue) | 0;
                                break;
                            case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteBishop: 
                                whiteScore = (whiteScore + this.bishopValue) | 0;
                                break;
                            case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook: 
                                whiteScore = (whiteScore + this.rookValue) | 0;
                                break;
                            case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteQueen: 
                                whiteScore = (whiteScore + this.queenValue) | 0;
                                break;
                            case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKing: 
                                whiteScore = (whiteScore + this.kingValue) | 0;
                                break;
                            case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackPawn: 
                                blackScore = (blackScore + this.pawnValue) | 0;
                                blackScore = (blackScore + (Bridge.Int.mul(10, (((6 - j) | 0))))) | 0;
                                break;
                            case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKnight: 
                                blackScore = (blackScore + this.knightValue) | 0;
                                break;
                            case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackBishop: 
                                blackScore = (blackScore + this.bishopValue) | 0;
                                break;
                            case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackRook: 
                                blackScore = (blackScore + this.rookValue) | 0;
                                break;
                            case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackQueen: 
                                blackScore = (blackScore + this.queenValue) | 0;
                                break;
                            case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKing: 
                                blackScore = (blackScore + this.kingValue) | 0;
                                break;
                            case ChessCompStompWithHacksEngine.ChessSquarePiece.Empty: 
                                break;
                            default: 
                                throw new System.Exception();
                        }
                    }
                }

                var score;
                if (whiteScore > blackScore) {
                    score = (Bridge.Int.div(Bridge.Int.mul(whiteScore, 10000), blackScore)) | 0;
                } else {
                    if (blackScore > whiteScore) {
                        score = (Bridge.Int.div(Bridge.Int.mul(((-blackScore) | 0), 10000), whiteScore)) | 0;
                    } else {
                        score = 0;
                    }
                }

                if (isWhite) {
                    return score;
                } else {
                    return ((-score) | 0);
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.RandomMoveAI", {
        inherits: [ChessCompStompWithHacksEngine.IChessAI],
        fields: {
            startTimeMicroSeconds: System.Int64(0),
            bestMove: null,
            logger: null
        },
        alias: [
            "GetStartTimeMicroSeconds", "ChessCompStompWithHacksEngine$IChessAI$GetStartTimeMicroSeconds",
            "GetBestMoveFoundSoFar", "ChessCompStompWithHacksEngine$IChessAI$GetBestMoveFoundSoFar",
            "HasFinishedCalculation", "ChessCompStompWithHacksEngine$IChessAI$HasFinishedCalculation",
            "GetDepthOfBestMoveFoundSoFar", "ChessCompStompWithHacksEngine$IChessAI$GetDepthOfBestMoveFoundSoFar",
            "CalculateBestMove", "ChessCompStompWithHacksEngine$IChessAI$CalculateBestMove"
        ],
        ctors: {
            ctor: function (gameState, timer, random, logger) {
                this.$initialize();
                this.startTimeMicroSeconds = timer.DTLibrary$ITimer$GetNumberOfMicroSeconds();

                var result = ChessCompStompWithHacksEngine.ComputeMoves.GetMoves(gameState);

                if (result.GameStatus === ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.InProgress) {
                    this.bestMove = result.Moves.getItem(random.DTLibrary$IDTRandom$NextInt(result.Moves.Count));
                } else {
                    this.bestMove = null;
                }

                this.logger = logger;
            }
        },
        methods: {
            GetStartTimeMicroSeconds: function () {
                return this.startTimeMicroSeconds;
            },
            GetBestMoveFoundSoFar: function () {
                if (this.bestMove == null) {
                    throw new System.Exception();
                }

                this.logger.DTLibrary$IDTLogger$WriteLine$1("Found randomly chosen move.");
                return this.bestMove;
            },
            HasFinishedCalculation: function () {
                return true;
            },
            GetDepthOfBestMoveFoundSoFar: function () {
                return 0;
            },
            CalculateBestMove: function (millisecondsToThink) { }
        }
    });

    Bridge.define("ChessCompStompWithHacksEngine.StandardBoardEvaluator", {
        inherits: [ChessCompStompWithHacksEngine.IBoardEvaluator],
        fields: {
            random: null
        },
        alias: ["Evaluate", "ChessCompStompWithHacksEngine$IBoardEvaluator$Evaluate"],
        ctors: {
            ctor: function (random) {
                this.$initialize();
                this.random = random;
            }
        },
        methods: {
            Evaluate: function (gameState, isWhite) {
                var whiteScore = 0;
                var blackScore = 0;

                for (var i = 0; i < 8; i = (i + 1) | 0) {
                    for (var j = 0; j < 8; j = (j + 1) | 0) {
                        switch (gameState.Board.GetPiece$1(i, j)) {
                            case ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn: 
                                whiteScore = (whiteScore + 100) | 0;
                                whiteScore = (whiteScore + (Bridge.Int.mul(10, (((j - 1) | 0))))) | 0;
                                break;
                            case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKnight: 
                                whiteScore = (whiteScore + 300) | 0;
                                break;
                            case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteBishop: 
                                whiteScore = (whiteScore + 300) | 0;
                                break;
                            case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook: 
                                whiteScore = (whiteScore + 500) | 0;
                                break;
                            case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteQueen: 
                                whiteScore = (whiteScore + 900) | 0;
                                break;
                            case ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKing: 
                                whiteScore = (whiteScore + 400) | 0;
                                break;
                            case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackPawn: 
                                blackScore = (blackScore + 100) | 0;
                                blackScore = (blackScore + (Bridge.Int.mul(10, (((6 - j) | 0))))) | 0;
                                break;
                            case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKnight: 
                                blackScore = (blackScore + 300) | 0;
                                break;
                            case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackBishop: 
                                blackScore = (blackScore + 300) | 0;
                                break;
                            case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackRook: 
                                blackScore = (blackScore + 500) | 0;
                                break;
                            case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackQueen: 
                                blackScore = (blackScore + 900) | 0;
                                break;
                            case ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKing: 
                                blackScore = (blackScore + 400) | 0;
                                break;
                            case ChessCompStompWithHacksEngine.ChessSquarePiece.Empty: 
                                break;
                            default: 
                                throw new System.Exception();
                        }
                    }
                }

                var score;
                if (whiteScore > blackScore) {
                    score = (Bridge.Int.div(Bridge.Int.mul(whiteScore, 10000), blackScore)) | 0;
                } else {
                    if (blackScore > whiteScore) {
                        score = (Bridge.Int.div(Bridge.Int.mul(((-blackScore) | 0), 10000), whiteScore)) | 0;
                    } else {
                        score = 0;
                    }
                }

                if (isWhite) {
                    return score;
                } else {
                    return ((-score) | 0);
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.GameLogic.ChessPiecesRendererMouse", {
        inherits: [DTLibrary.IMouse],
        $kind: "nested class",
        fields: {
            mouse: null
        },
        alias: [
            "GetX", "DTLibrary$IMouse$GetX",
            "GetY", "DTLibrary$IMouse$GetY",
            "IsLeftMouseButtonPressed", "DTLibrary$IMouse$IsLeftMouseButtonPressed",
            "IsRightMouseButtonPressed", "DTLibrary$IMouse$IsRightMouseButtonPressed"
        ],
        ctors: {
            ctor: function (mouse, coordinates) {
                this.$initialize();
                this.mouse = new DTLibrary.TranslatedMouse(mouse, ((-coordinates.ChessPiecesRendererX) | 0), ((-coordinates.ChessPiecesRendererY) | 0));
            }
        },
        methods: {
            GetX: function () {
                return this.mouse.GetX();
            },
            GetY: function () {
                return this.mouse.GetY();
            },
            IsLeftMouseButtonPressed: function () {
                return this.mouse.IsLeftMouseButtonPressed();
            },
            IsRightMouseButtonPressed: function () {
                return this.mouse.IsRightMouseButtonPressed();
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.GameLogic.MoveTrackerRendererMouse", {
        inherits: [DTLibrary.IMouse],
        $kind: "nested class",
        fields: {
            mouse: null
        },
        alias: [
            "GetX", "DTLibrary$IMouse$GetX",
            "GetY", "DTLibrary$IMouse$GetY",
            "IsLeftMouseButtonPressed", "DTLibrary$IMouse$IsLeftMouseButtonPressed",
            "IsRightMouseButtonPressed", "DTLibrary$IMouse$IsRightMouseButtonPressed"
        ],
        ctors: {
            ctor: function (mouse, coordinates) {
                this.$initialize();
                this.mouse = new DTLibrary.TranslatedMouse(mouse, ((-coordinates.MoveTrackerRendererX) | 0), ((-coordinates.MoveTrackerRendererY) | 0));
            }
        },
        methods: {
            GetX: function () {
                return this.mouse.GetX();
            },
            GetY: function () {
                return this.mouse.GetY();
            },
            IsLeftMouseButtonPressed: function () {
                return this.mouse.IsLeftMouseButtonPressed();
            },
            IsRightMouseButtonPressed: function () {
                return this.mouse.IsRightMouseButtonPressed();
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.GameLogic.NukeRendererMouse", {
        inherits: [DTLibrary.IMouse],
        $kind: "nested class",
        fields: {
            mouse: null
        },
        alias: [
            "GetX", "DTLibrary$IMouse$GetX",
            "GetY", "DTLibrary$IMouse$GetY",
            "IsLeftMouseButtonPressed", "DTLibrary$IMouse$IsLeftMouseButtonPressed",
            "IsRightMouseButtonPressed", "DTLibrary$IMouse$IsRightMouseButtonPressed"
        ],
        ctors: {
            ctor: function (mouse, coordinates) {
                this.$initialize();
                this.mouse = new DTLibrary.TranslatedMouse(mouse, ((-coordinates.NukeRendererX) | 0), ((-coordinates.NukeRendererY) | 0));
            }
        },
        methods: {
            GetX: function () {
                return this.mouse.GetX();
            },
            GetY: function () {
                return this.mouse.GetY();
            },
            IsLeftMouseButtonPressed: function () {
                return this.mouse.IsLeftMouseButtonPressed();
            },
            IsRightMouseButtonPressed: function () {
                return this.mouse.IsRightMouseButtonPressed();
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackExplanation_AnyPieceCanPromote", {
        inherits: [ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.IHackExplanation],
        statics: {
            methods: {
                GetPossibleMoves: function (pieceToMove, board) {
                    var $t, $t1;
                    var piece = board.GetPiece(pieceToMove);

                    if (piece === ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook || piece === ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteBishop) {
                        var directions = new (System.Collections.Generic.List$1(System.Tuple$2(System.Int32,System.Int32))).ctor();

                        if (piece === ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook) {
                            directions.add({ Item1: 1, Item2: 0 });
                            directions.add({ Item1: -1, Item2: 0 });
                            directions.add({ Item1: 0, Item2: 1 });
                            directions.add({ Item1: 0, Item2: -1 });
                        } else if (piece === ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteBishop) {
                            directions.add({ Item1: 1, Item2: 1 });
                            directions.add({ Item1: 1, Item2: -1 });
                            directions.add({ Item1: -1, Item2: 1 });
                            directions.add({ Item1: -1, Item2: -1 });
                        } else {
                            throw new System.Exception();
                        }

                        var possibleMoves = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor();

                        $t = Bridge.getEnumerator(directions);
                        try {
                            while ($t.moveNext()) {
                                var direction = $t.Current;
                                var i = pieceToMove.File;
                                var j = pieceToMove.Rank;

                                while (true) {
                                    i = (i + direction.Item1) | 0;
                                    j = (j + direction.Item2) | 0;

                                    if (i < 0 || i >= 8 || j < 0 || j >= 8) {
                                        break;
                                    }

                                    if (board.GetPiece$1(i, j) !== ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                                        break;
                                    }

                                    possibleMoves.add(new ChessCompStompWithHacksEngine.ChessSquare(i, j));
                                }
                            }
                        } finally {
                            if (Bridge.is($t, System.IDisposable)) {
                                $t.System$IDisposable$Dispose();
                            }
                        }

                        return possibleMoves;
                    } else if (piece === ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKnight) {
                        var potentialMoves = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor();

                        var i1 = pieceToMove.File;
                        var j1 = pieceToMove.Rank;

                        potentialMoves.add(new ChessCompStompWithHacksEngine.ChessSquare(((i1 + 2) | 0), ((j1 + 1) | 0)));
                        potentialMoves.add(new ChessCompStompWithHacksEngine.ChessSquare(((i1 + 2) | 0), ((j1 - 1) | 0)));
                        potentialMoves.add(new ChessCompStompWithHacksEngine.ChessSquare(((i1 - 2) | 0), ((j1 + 1) | 0)));
                        potentialMoves.add(new ChessCompStompWithHacksEngine.ChessSquare(((i1 - 2) | 0), ((j1 - 1) | 0)));
                        potentialMoves.add(new ChessCompStompWithHacksEngine.ChessSquare(((i1 + 1) | 0), ((j1 + 2) | 0)));
                        potentialMoves.add(new ChessCompStompWithHacksEngine.ChessSquare(((i1 + 1) | 0), ((j1 - 2) | 0)));
                        potentialMoves.add(new ChessCompStompWithHacksEngine.ChessSquare(((i1 - 1) | 0), ((j1 + 2) | 0)));
                        potentialMoves.add(new ChessCompStompWithHacksEngine.ChessSquare(((i1 - 1) | 0), ((j1 - 2) | 0)));

                        var validMoves = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor();

                        $t1 = Bridge.getEnumerator(potentialMoves);
                        try {
                            while ($t1.moveNext()) {
                                var potentialMove = $t1.Current;
                                if (potentialMove.File >= 0 && potentialMove.File < 8 && potentialMove.Rank >= 0 && potentialMove.Rank < 8 && board.GetPiece(potentialMove) === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                                    validMoves.add(potentialMove);
                                }
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }

                        return validMoves;
                    } else {
                        throw new System.Exception();
                    }
                }
            }
        },
        fields: {
            chessPiecesRenderer: null,
            chessPiecesRendererPieceAnimation: null,
            moveCooldown: 0,
            random: null,
            colorTheme: 0,
            board: null,
            pieceToMove: null,
            previousMoveSquares: null,
            possibleMoveSquares: null,
            chessPiecesRendererFadeOutFadeIn: null
        },
        alias: [
            "ProcessFrame", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$ProcessFrame",
            "Render", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$Render"
        ],
        ctors: {
            ctor: function (colorTheme, random) {
                this.$initialize();
                this.chessPiecesRendererFadeOutFadeIn = null;

                this.colorTheme = colorTheme;

                this.random = random;

                this.moveCooldown = ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.ELAPSED_MICROS_BEFORE_PIECE_MOVES;

                this.PopulateInitialBoard(random);

                this.chessPiecesRenderer = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetChessPiecesRenderer(this.board, null, this.previousMoveSquares, true, colorTheme);

                this.chessPiecesRendererPieceAnimation = ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.EmptyChessPiecesRendererPieceAnimation();
            }
        },
        methods: {
            PopulateInitialBoard: function (random) {
                var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18;
                this.previousMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();
                this.possibleMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();

                var boardArray = System.Array.init(8, null, System.Array.type(ChessCompStompWithHacksEngine.ChessSquarePiece));
                for (var i = 0; i < 8; i = (i + 1) | 0) {
                    boardArray[System.Array.index(i, boardArray)] = System.Array.init(8, 0, ChessCompStompWithHacksEngine.ChessSquarePiece);
                    for (var j = 0; j < 8; j = (j + 1) | 0) {
                        ($t = boardArray[System.Array.index(i, boardArray)])[System.Array.index(j, $t)] = ChessCompStompWithHacksEngine.ChessSquarePiece.Empty;
                    }
                }

                ($t1 = boardArray[System.Array.index(((random.DTLibrary$IDTRandom$NextInt(6) + 1) | 0), boardArray)])[System.Array.index(0, $t1)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKing;

                var pawnList = function (_o1) {
                        _o1.add(0);
                        _o1.add(1);
                        _o1.add(2);
                        _o1.add(3);
                        _o1.add(4);
                        _o1.add(5);
                        _o1.add(6);
                        _o1.add(7);
                        return _o1;
                    }(new (System.Collections.Generic.List$1(System.Int32)).ctor());
                DTLibrary.ListUtil.Shuffle(System.Int32, pawnList, random);

                var numPawns = (random.DTLibrary$IDTRandom$NextInt(4) + 3) | 0;
                var pawnRank = 1;
                for (var x = 0; x < numPawns; x = (x + 1) | 0) {
                    if (pawnRank === 1 && x === 2) {
                        pawnRank = (pawnRank + 1) | 0;
                    } else {
                        if (pawnRank < 3) {
                            pawnRank = random.DTLibrary$IDTRandom$NextInt(100) < 30 ? ((pawnRank + 1) | 0) : pawnRank;
                        }
                    }

                    ($t2 = boardArray[System.Array.index(pawnList.getItem(x), boardArray)])[System.Array.index(pawnRank, $t2)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn;
                }

                if (random.DTLibrary$IDTRandom$NextInt(100) < 65) {
                    if (random.DTLibrary$IDTRandom$NextBool()) {
                        if (($t3 = boardArray[System.Array.index(0, boardArray)])[System.Array.index(0, $t3)] === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                            ($t4 = boardArray[System.Array.index(0, boardArray)])[System.Array.index(0, $t4)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook;
                        }
                    } else {
                        if (($t5 = boardArray[System.Array.index(7, boardArray)])[System.Array.index(0, $t5)] === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                            ($t6 = boardArray[System.Array.index(7, boardArray)])[System.Array.index(0, $t6)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook;
                        }
                    }
                }

                if (random.DTLibrary$IDTRandom$NextInt(100) < 65) {
                    var possibleLocations = function (_o2) {
                            _o2.add(new ChessCompStompWithHacksEngine.ChessSquare(1, 0));
                            _o2.add(new ChessCompStompWithHacksEngine.ChessSquare(6, 0));
                            _o2.add(new ChessCompStompWithHacksEngine.ChessSquare(1, 1));
                            _o2.add(new ChessCompStompWithHacksEngine.ChessSquare(2, 1));
                            _o2.add(new ChessCompStompWithHacksEngine.ChessSquare(3, 1));
                            _o2.add(new ChessCompStompWithHacksEngine.ChessSquare(4, 1));
                            _o2.add(new ChessCompStompWithHacksEngine.ChessSquare(5, 1));
                            _o2.add(new ChessCompStompWithHacksEngine.ChessSquare(6, 1));
                            _o2.add(new ChessCompStompWithHacksEngine.ChessSquare(2, 2));
                            _o2.add(new ChessCompStompWithHacksEngine.ChessSquare(3, 2));
                            _o2.add(new ChessCompStompWithHacksEngine.ChessSquare(4, 2));
                            _o2.add(new ChessCompStompWithHacksEngine.ChessSquare(5, 2));
                            return _o2;
                        }(new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor());
                    DTLibrary.ListUtil.Shuffle(ChessCompStompWithHacksEngine.ChessSquare, possibleLocations, random);

                    $t7 = Bridge.getEnumerator(possibleLocations);
                    try {
                        while ($t7.moveNext()) {
                            var location = $t7.Current;
                            if (($t8 = boardArray[System.Array.index(location.File, boardArray)])[System.Array.index(location.Rank, $t8)] === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                                ($t9 = boardArray[System.Array.index(location.File, boardArray)])[System.Array.index(location.Rank, $t9)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKnight;
                                break;
                            }
                        }
                    } finally {
                        if (Bridge.is($t7, System.IDisposable)) {
                            $t7.System$IDisposable$Dispose();
                        }
                    }
                }

                var hasEvenBishop = false;
                var hasOddBishop = false;

                if (random.DTLibrary$IDTRandom$NextInt(100) < 65) {
                    var possibleLocations1 = function (_o3) {
                            _o3.add(new ChessCompStompWithHacksEngine.ChessSquare(2, 0));
                            _o3.add(new ChessCompStompWithHacksEngine.ChessSquare(5, 0));
                            _o3.add(new ChessCompStompWithHacksEngine.ChessSquare(1, 1));
                            _o3.add(new ChessCompStompWithHacksEngine.ChessSquare(3, 1));
                            _o3.add(new ChessCompStompWithHacksEngine.ChessSquare(4, 1));
                            _o3.add(new ChessCompStompWithHacksEngine.ChessSquare(6, 1));
                            _o3.add(new ChessCompStompWithHacksEngine.ChessSquare(0, 2));
                            _o3.add(new ChessCompStompWithHacksEngine.ChessSquare(3, 2));
                            _o3.add(new ChessCompStompWithHacksEngine.ChessSquare(4, 2));
                            _o3.add(new ChessCompStompWithHacksEngine.ChessSquare(7, 2));
                            return _o3;
                        }(new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor());
                    DTLibrary.ListUtil.Shuffle(ChessCompStompWithHacksEngine.ChessSquare, possibleLocations1, random);

                    $t10 = Bridge.getEnumerator(possibleLocations1);
                    try {
                        while ($t10.moveNext()) {
                            var location1 = $t10.Current;
                            if (($t11 = boardArray[System.Array.index(location1.File, boardArray)])[System.Array.index(location1.Rank, $t11)] === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                                ($t12 = boardArray[System.Array.index(location1.File, boardArray)])[System.Array.index(location1.Rank, $t12)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteBishop;

                                if ((((location1.File + location1.Rank) | 0)) % 2 === 0) {
                                    hasEvenBishop = true;
                                } else {
                                    hasOddBishop = true;
                                }

                                break;
                            }
                        }
                    } finally {
                        if (Bridge.is($t10, System.IDisposable)) {
                            $t10.System$IDisposable$Dispose();
                        }
                    }
                }

                if (random.DTLibrary$IDTRandom$NextInt(100) < 65) {
                    var possibleLocations2 = function (_o4) {
                            _o4.add(new ChessCompStompWithHacksEngine.ChessSquare(3, 0));
                            _o4.add(new ChessCompStompWithHacksEngine.ChessSquare(4, 0));
                            _o4.add(new ChessCompStompWithHacksEngine.ChessSquare(2, 1));
                            _o4.add(new ChessCompStompWithHacksEngine.ChessSquare(3, 1));
                            _o4.add(new ChessCompStompWithHacksEngine.ChessSquare(4, 1));
                            _o4.add(new ChessCompStompWithHacksEngine.ChessSquare(5, 1));
                            return _o4;
                        }(new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor());
                    DTLibrary.ListUtil.Shuffle(ChessCompStompWithHacksEngine.ChessSquare, possibleLocations2, random);

                    $t13 = Bridge.getEnumerator(possibleLocations2);
                    try {
                        while ($t13.moveNext()) {
                            var location2 = $t13.Current;
                            if (($t14 = boardArray[System.Array.index(location2.File, boardArray)])[System.Array.index(location2.Rank, $t14)] === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                                ($t15 = boardArray[System.Array.index(location2.File, boardArray)])[System.Array.index(location2.Rank, $t15)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteQueen;
                                break;
                            }
                        }
                    } finally {
                        if (Bridge.is($t13, System.IDisposable)) {
                            $t13.System$IDisposable$Dispose();
                        }
                    }
                }

                if (random.DTLibrary$IDTRandom$NextInt(3) === 0) {
                    var possibleLocations3 = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor();
                    for (var i1 = 0; i1 < 8; i1 = (i1 + 1) | 0) {
                        possibleLocations3.add(new ChessCompStompWithHacksEngine.ChessSquare(i1, 4));
                        possibleLocations3.add(new ChessCompStompWithHacksEngine.ChessSquare(i1, 5));
                    }
                    DTLibrary.ListUtil.Shuffle(ChessCompStompWithHacksEngine.ChessSquare, possibleLocations3, random);

                    this.pieceToMove = possibleLocations3.getItem(0);
                    ($t16 = boardArray[System.Array.index(this.pieceToMove.File, boardArray)])[System.Array.index(this.pieceToMove.Rank, $t16)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook;
                } else if (random.DTLibrary$IDTRandom$NextBool()) {
                    var possibleLocations4 = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor();
                    for (var i2 = 0; i2 < 8; i2 = (i2 + 1) | 0) {
                        possibleLocations4.add(new ChessCompStompWithHacksEngine.ChessSquare(i2, 4));
                        possibleLocations4.add(new ChessCompStompWithHacksEngine.ChessSquare(i2, 5));
                    }
                    DTLibrary.ListUtil.Shuffle(ChessCompStompWithHacksEngine.ChessSquare, possibleLocations4, random);

                    var index = 0;
                    while (true) {
                        this.pieceToMove = possibleLocations4.getItem(index);
                        index = (index + 1) | 0;

                        var isEven = (((this.pieceToMove.File + this.pieceToMove.Rank) | 0)) % 2 === 0;

                        if (isEven && hasEvenBishop || !isEven && hasOddBishop) {
                            continue;
                        }

                        ($t17 = boardArray[System.Array.index(this.pieceToMove.File, boardArray)])[System.Array.index(this.pieceToMove.Rank, $t17)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteBishop;
                        break;
                    }
                } else {
                    var possibleLocations5 = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor();
                    for (var i3 = 0; i3 < 8; i3 = (i3 + 1) | 0) {
                        possibleLocations5.add(new ChessCompStompWithHacksEngine.ChessSquare(i3, 5));
                        possibleLocations5.add(new ChessCompStompWithHacksEngine.ChessSquare(i3, 6));
                    }
                    DTLibrary.ListUtil.Shuffle(ChessCompStompWithHacksEngine.ChessSquare, possibleLocations5, random);

                    this.pieceToMove = possibleLocations5.getItem(0);
                    ($t18 = boardArray[System.Array.index(this.pieceToMove.File, boardArray)])[System.Array.index(this.pieceToMove.Rank, $t18)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKnight;
                }

                this.board = new ChessCompStompWithHacksEngine.ChessSquarePieceArray.$ctor1(boardArray);
            },
            ProcessFrame: function (mouseInput, previousMouseInput, displayProcessing, elapsedMicrosPerFrame) {
                if (this.chessPiecesRendererFadeOutFadeIn != null) {
                    this.chessPiecesRendererFadeOutFadeIn.ProcessFrame(elapsedMicrosPerFrame);

                    if (this.chessPiecesRendererFadeOutFadeIn.HasFinishedFadingOut() && this.previousMoveSquares.Count > 0) {
                        this.PopulateInitialBoard(this.random);
                    }

                    if (this.chessPiecesRendererFadeOutFadeIn.HasFinishedFadingIn()) {
                        this.chessPiecesRendererFadeOutFadeIn = null;
                    }
                } else {
                    this.moveCooldown = (this.moveCooldown - elapsedMicrosPerFrame) | 0;
                    if (this.moveCooldown <= 0) {
                        this.moveCooldown = (this.moveCooldown + ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.ELAPSED_MICROS_BEFORE_PIECE_MOVES) | 0;
                        if (this.moveCooldown <= 0) {
                            this.moveCooldown = 0;
                        }

                        if (this.previousMoveSquares.Count > 0) {
                            this.chessPiecesRendererFadeOutFadeIn = new ChessCompStompWithHacksLibrary.ChessPiecesRendererFadeOutFadeIn(this.colorTheme);
                        } else {
                            if (this.possibleMoveSquares.Count === 0) {
                                this.possibleMoveSquares = new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor2(ChessCompStompWithHacksLibrary.HackExplanation_AnyPieceCanPromote.GetPossibleMoves(this.pieceToMove, this.board));
                            } else {
                                var promotionMoves = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor();

                                for (var x = 0; x < this.possibleMoveSquares.Count; x = (x + 1) | 0) {
                                    if (this.possibleMoveSquares.getItem(x).Rank === 7) {
                                        promotionMoves.add(this.possibleMoveSquares.getItem(x));
                                    }
                                }
                                DTLibrary.ListUtil.Shuffle(ChessCompStompWithHacksEngine.ChessSquare, promotionMoves, this.random);

                                this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.AddRawMove(this.pieceToMove.File, this.pieceToMove.Rank, promotionMoves.getItem(0).File, promotionMoves.getItem(0).Rank, this.board.GetPiece(this.pieceToMove));

                                this.board = this.board.SetPiece(this.pieceToMove.File, this.pieceToMove.Rank, ChessCompStompWithHacksEngine.ChessSquarePiece.Empty);
                                this.board = this.board.SetPiece(promotionMoves.getItem(0).File, promotionMoves.getItem(0).Rank, ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteQueen);

                                this.previousMoveSquares = new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor1(Bridge.fn.bind(this, function (_o1) {
                                        _o1.add(this.pieceToMove);
                                        _o1.add(promotionMoves.getItem(0));
                                        return _o1;
                                    })(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor()));
                                this.possibleMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();
                            }
                        }
                    }
                }

                this.chessPiecesRenderer = this.chessPiecesRenderer.ProcessFrame(this.board, null, this.previousMoveSquares, this.possibleMoveSquares.Count > 0 ? this.pieceToMove : null, this.possibleMoveSquares, null, null, null, elapsedMicrosPerFrame);

                this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.ProcessFrame(elapsedMicrosPerFrame);
            },
            Render: function (displayOutput, isMobileDisplayType) {
                var isMobilePortrait = isMobileDisplayType && !DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? 155 : 305, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, ChessCompStompWithHacksLibrary.HackUtil.GetHackNameForHackExplanationPanel(ChessCompStompWithHacksEngine.Hack.AnyPieceCanPromote), ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                var explanation;

                if (isMobilePortrait) {
                    explanation = "Your rooks, knights, bishops, and queen may\npromote upon reaching the last rank.";
                } else {
                    explanation = "Your rooks, knights, bishops,\nand queen may promote upon\nreaching the last rank.";
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, explanation, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, DTLibrary.DTColor.Black());

                this.chessPiecesRenderer.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE), this.chessPiecesRendererPieceAnimation, ChessCompStompWithHacksLibrary.GameImageUtil.HackExplanationChessPieceScalingFactor, isMobileDisplayType);

                if (this.chessPiecesRendererFadeOutFadeIn != null) {
                    this.chessPiecesRendererFadeOutFadeIn.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE), ChessCompStompWithHacksLibrary.GameImageUtil.HackExplanationChessPieceScalingFactor);
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackExplanation_ExtraPawnFirst", {
        inherits: [ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.IHackExplanation],
        fields: {
            chessPiecesRenderer: null,
            chessPiecesRendererPieceAnimation: null
        },
        alias: [
            "ProcessFrame", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$ProcessFrame",
            "Render", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$Render"
        ],
        ctors: {
            ctor: function (colorTheme, elapsedMicrosPerFrame) {
                this.$initialize();
                var gameState = ChessCompStompWithHacksLibrary.NewGameCreation.CreateNewGame(true, new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.Hack)).$ctor1(function (_o1) {
                        _o1.add(ChessCompStompWithHacksEngine.Hack.ExtraPawnFirst);
                        return _o1;
                    }(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.Hack)).ctor())), ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.Initial);

                this.chessPiecesRenderer = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetChessPiecesRenderer(gameState.Board, null, DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList(), true, colorTheme);

                this.chessPiecesRenderer = this.chessPiecesRenderer.ProcessFrame(gameState.Board, null, DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList(), null, DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList(), null, null, null, elapsedMicrosPerFrame);

                this.chessPiecesRendererPieceAnimation = ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.EmptyChessPiecesRendererPieceAnimation();
                this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.ProcessFrame(elapsedMicrosPerFrame);
            }
        },
        methods: {
            ProcessFrame: function (mouseInput, previousMouseInput, displayProcessing, elapsedMicrosPerFrame) { },
            Render: function (displayOutput, isMobileDisplayType) {
                var isMobilePortrait = isMobileDisplayType && !DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? 223 : 373, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, ChessCompStompWithHacksLibrary.HackUtil.GetHackNameForHackExplanationPanel(ChessCompStompWithHacksEngine.Hack.ExtraPawnFirst), ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                var explanation;

                if (isMobilePortrait) {
                    explanation = "Start with an extra pawn.\n\nLike other pawns, this extra pawn may\nadvance 2 squares on its first move.\n\nThis pawn may not be captured en passant.";
                } else {
                    explanation = "Start with an extra pawn.\n\nLike other pawns, this extra\npawn may advance 2 squares\non its first move.\n\nThis pawn may not be\ncaptured en passant.";
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, explanation, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, DTLibrary.DTColor.Black());

                this.chessPiecesRenderer.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE), this.chessPiecesRendererPieceAnimation, ChessCompStompWithHacksLibrary.GameImageUtil.HackExplanationChessPieceScalingFactor, isMobileDisplayType);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackExplanation_ExtraPawnSecond", {
        inherits: [ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.IHackExplanation],
        fields: {
            chessPiecesRenderer: null,
            chessPiecesRendererPieceAnimation: null
        },
        alias: [
            "ProcessFrame", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$ProcessFrame",
            "Render", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$Render"
        ],
        ctors: {
            ctor: function (colorTheme, hasExtraPawnFirstHack, elapsedMicrosPerFrame) {
                this.$initialize();
                var hacks = new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.Hack)).ctor();
                if (hasExtraPawnFirstHack) {
                    hacks.add(ChessCompStompWithHacksEngine.Hack.ExtraPawnFirst);
                }
                hacks.add(ChessCompStompWithHacksEngine.Hack.ExtraPawnSecond);

                var gameState = ChessCompStompWithHacksLibrary.NewGameCreation.CreateNewGame(true, new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.Hack)).$ctor1(hacks), ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.Initial);

                this.chessPiecesRenderer = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetChessPiecesRenderer(gameState.Board, null, DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList(), true, colorTheme);

                this.chessPiecesRenderer = this.chessPiecesRenderer.ProcessFrame(gameState.Board, null, DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList(), null, DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList(), null, null, null, elapsedMicrosPerFrame);

                this.chessPiecesRendererPieceAnimation = ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.EmptyChessPiecesRendererPieceAnimation();
                this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.ProcessFrame(elapsedMicrosPerFrame);
            }
        },
        methods: {
            ProcessFrame: function (mouseInput, previousMouseInput, displayProcessing, elapsedMicrosPerFrame) { },
            Render: function (displayOutput, isMobileDisplayType) {
                var isMobilePortrait = isMobileDisplayType && !DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? 166 : 316, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, ChessCompStompWithHacksLibrary.HackUtil.GetHackNameForHackExplanationPanel(ChessCompStompWithHacksEngine.Hack.ExtraPawnSecond), ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                var explanation;

                if (isMobilePortrait) {
                    explanation = "Start with another extra pawn.\n\nLike other pawns, this extra pawn may\nadvance 2 squares on its first move.\n\nThis pawn may not be captured en passant.";
                } else {
                    explanation = "Start with another extra\npawn.\n\nLike other pawns, this extra\npawn may advance 2 squares\non its first move.\n\nThis pawn may not be\ncaptured en passant.";
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, explanation, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, DTLibrary.DTColor.Black());

                this.chessPiecesRenderer.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE), this.chessPiecesRendererPieceAnimation, ChessCompStompWithHacksLibrary.GameImageUtil.HackExplanationChessPieceScalingFactor, isMobileDisplayType);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackExplanation_ExtraQueen", {
        inherits: [ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.IHackExplanation],
        fields: {
            chessPiecesRenderer: null,
            chessPiecesRendererPieceAnimation: null
        },
        alias: [
            "ProcessFrame", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$ProcessFrame",
            "Render", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$Render"
        ],
        ctors: {
            ctor: function (colorTheme, elapsedMicrosPerFrame) {
                this.$initialize();
                var gameState = ChessCompStompWithHacksLibrary.NewGameCreation.CreateNewGame(true, new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.Hack)).$ctor1(function (_o1) {
                        _o1.add(ChessCompStompWithHacksEngine.Hack.ExtraQueen);
                        return _o1;
                    }(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.Hack)).ctor())), ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.Initial);

                this.chessPiecesRenderer = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetChessPiecesRenderer(gameState.Board, null, DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList(), true, colorTheme);

                this.chessPiecesRenderer = this.chessPiecesRenderer.ProcessFrame(gameState.Board, null, DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList(), null, DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList(), null, null, null, elapsedMicrosPerFrame);

                this.chessPiecesRendererPieceAnimation = ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.EmptyChessPiecesRendererPieceAnimation();
                this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.ProcessFrame(elapsedMicrosPerFrame);
            }
        },
        methods: {
            ProcessFrame: function (mouseInput, previousMouseInput, displayProcessing, elapsedMicrosPerFrame) { },
            Render: function (displayOutput, isMobileDisplayType) {
                var isMobilePortrait = isMobileDisplayType && !DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? 218 : 368, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, ChessCompStompWithHacksLibrary.HackUtil.GetHackNameForHackExplanationPanel(ChessCompStompWithHacksEngine.Hack.ExtraQueen), ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                var explanation = "Start with an extra queen.";

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, explanation, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, DTLibrary.DTColor.Black());

                this.chessPiecesRenderer.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE), this.chessPiecesRendererPieceAnimation, ChessCompStompWithHacksLibrary.GameImageUtil.HackExplanationChessPieceScalingFactor, isMobileDisplayType);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackExplanation_KnightsCanMakeLargeKnightsMove", {
        inherits: [ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.IHackExplanation],
        statics: {
            methods: {
                GetPossibleLargeKnightMoves: function (knightSquare) {
                    var $t;
                    var list = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor();

                    var i = knightSquare.File;
                    var j = knightSquare.Rank;

                    var knightMoves = new (System.Collections.Generic.List$1(System.Tuple$2(System.Int32,System.Int32))).ctor();
                    knightMoves.add({ Item1: ((i + 1) | 0), Item2: ((j + 3) | 0) });
                    knightMoves.add({ Item1: ((i + 1) | 0), Item2: ((j - 3) | 0) });
                    knightMoves.add({ Item1: ((i - 1) | 0), Item2: ((j + 3) | 0) });
                    knightMoves.add({ Item1: ((i - 1) | 0), Item2: ((j - 3) | 0) });
                    knightMoves.add({ Item1: ((i + 3) | 0), Item2: ((j + 1) | 0) });
                    knightMoves.add({ Item1: ((i + 3) | 0), Item2: ((j - 1) | 0) });
                    knightMoves.add({ Item1: ((i - 3) | 0), Item2: ((j + 1) | 0) });
                    knightMoves.add({ Item1: ((i - 3) | 0), Item2: ((j - 1) | 0) });

                    $t = Bridge.getEnumerator(knightMoves);
                    try {
                        while ($t.moveNext()) {
                            var knightMove = $t.Current;
                            if (0 <= knightMove.Item1 && knightMove.Item1 < 8 && 0 <= knightMove.Item2 && knightMove.Item2 < 8) {
                                list.add(new ChessCompStompWithHacksEngine.ChessSquare(knightMove.Item1, knightMove.Item2));
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    return list;
                },
                GetPossibleNormalKnightMoves: function (knightSquare) {
                    var $t;
                    var list = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor();

                    var i = knightSquare.File;
                    var j = knightSquare.Rank;

                    var knightMoves = new (System.Collections.Generic.List$1(System.Tuple$2(System.Int32,System.Int32))).ctor();
                    knightMoves.add({ Item1: ((i + 1) | 0), Item2: ((j + 2) | 0) });
                    knightMoves.add({ Item1: ((i + 1) | 0), Item2: ((j - 2) | 0) });
                    knightMoves.add({ Item1: ((i - 1) | 0), Item2: ((j + 2) | 0) });
                    knightMoves.add({ Item1: ((i - 1) | 0), Item2: ((j - 2) | 0) });
                    knightMoves.add({ Item1: ((i + 2) | 0), Item2: ((j + 1) | 0) });
                    knightMoves.add({ Item1: ((i + 2) | 0), Item2: ((j - 1) | 0) });
                    knightMoves.add({ Item1: ((i - 2) | 0), Item2: ((j + 1) | 0) });
                    knightMoves.add({ Item1: ((i - 2) | 0), Item2: ((j - 1) | 0) });

                    $t = Bridge.getEnumerator(knightMoves);
                    try {
                        while ($t.moveNext()) {
                            var knightMove = $t.Current;
                            if (0 <= knightMove.Item1 && knightMove.Item1 < 8 && 0 <= knightMove.Item2 && knightMove.Item2 < 8) {
                                list.add(new ChessCompStompWithHacksEngine.ChessSquare(knightMove.Item1, knightMove.Item2));
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    return list;
                }
            }
        },
        fields: {
            chessPiecesRenderer: null,
            chessPiecesRendererPieceAnimation: null,
            knightSquare: null,
            potentialNormalKnightMoves: null,
            potentialLargeKnightMoves: null,
            previousMoveSquares: null,
            moveCooldown: 0,
            random: null,
            colorTheme: 0
        },
        alias: [
            "ProcessFrame", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$ProcessFrame",
            "Render", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$Render"
        ],
        ctors: {
            ctor: function (colorTheme, random) {
                this.$initialize();
                this.colorTheme = colorTheme;

                this.random = random;

                this.knightSquare = new ChessCompStompWithHacksEngine.ChessSquare(random.DTLibrary$IDTRandom$NextInt(8), random.DTLibrary$IDTRandom$NextInt(8));

                this.potentialNormalKnightMoves = ChessCompStompWithHacksLibrary.HackExplanation_KnightsCanMakeLargeKnightsMove.GetPossibleNormalKnightMoves(this.knightSquare);
                this.potentialLargeKnightMoves = ChessCompStompWithHacksLibrary.HackExplanation_KnightsCanMakeLargeKnightsMove.GetPossibleLargeKnightMoves(this.knightSquare);

                this.moveCooldown = ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.ELAPSED_MICROS_BEFORE_PIECE_MOVES;

                var board = ChessCompStompWithHacksEngine.ChessSquarePieceArray.EmptyBoard();
                board = board.SetPiece(this.knightSquare.File, this.knightSquare.Rank, ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKnight);

                this.previousMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();

                this.chessPiecesRenderer = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetChessPiecesRenderer(board, null, this.previousMoveSquares, true, colorTheme);

                this.chessPiecesRendererPieceAnimation = ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.EmptyChessPiecesRendererPieceAnimation();
            }
        },
        methods: {
            ProcessFrame: function (mouseInput, previousMouseInput, displayProcessing, elapsedMicrosPerFrame) {
                this.moveCooldown = (this.moveCooldown - elapsedMicrosPerFrame) | 0;
                if (this.moveCooldown <= 0) {
                    this.moveCooldown = (this.moveCooldown + ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.ELAPSED_MICROS_BEFORE_PIECE_MOVES) | 0;
                    if (this.moveCooldown <= 0) {
                        this.moveCooldown = 0;
                    }

                    var originalKnightSquare = this.knightSquare;

                    if (this.random.DTLibrary$IDTRandom$NextInt(100) < 70) {
                        this.knightSquare = this.potentialLargeKnightMoves.getItem(this.random.DTLibrary$IDTRandom$NextInt(this.potentialLargeKnightMoves.Count));
                    } else {
                        this.knightSquare = this.potentialNormalKnightMoves.getItem(this.random.DTLibrary$IDTRandom$NextInt(this.potentialNormalKnightMoves.Count));
                    }

                    this.potentialNormalKnightMoves = ChessCompStompWithHacksLibrary.HackExplanation_KnightsCanMakeLargeKnightsMove.GetPossibleNormalKnightMoves(this.knightSquare);
                    this.potentialLargeKnightMoves = ChessCompStompWithHacksLibrary.HackExplanation_KnightsCanMakeLargeKnightsMove.GetPossibleLargeKnightMoves(this.knightSquare);

                    this.previousMoveSquares = new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor1(Bridge.fn.bind(this, function (_o1) {
                            _o1.add(originalKnightSquare);
                            _o1.add(this.knightSquare);
                            return _o1;
                        })(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor()));

                    this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.AddRawMove(originalKnightSquare.File, originalKnightSquare.Rank, this.knightSquare.File, this.knightSquare.Rank, ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKnight);
                }

                var board = ChessCompStompWithHacksEngine.ChessSquarePieceArray.EmptyBoard();
                board = board.SetPiece(this.knightSquare.File, this.knightSquare.Rank, ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKnight);

                var allKnightMoves = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor();
                allKnightMoves.AddRange(this.potentialNormalKnightMoves);
                allKnightMoves.AddRange(this.potentialLargeKnightMoves);

                this.chessPiecesRenderer = this.chessPiecesRenderer.ProcessFrame(board, null, this.previousMoveSquares, null, DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).AsImmutableList(allKnightMoves), null, null, null, elapsedMicrosPerFrame);

                this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.ProcessFrame(elapsedMicrosPerFrame);
            },
            Render: function (displayOutput, isMobileDisplayType) {
                var isMobilePortrait = isMobileDisplayType && !DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? 184 : 334, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, ChessCompStompWithHacksLibrary.HackUtil.GetHackNameForHackExplanationPanel(ChessCompStompWithHacksEngine.Hack.KnightsCanMakeLargeKnightsMove), ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                var explanation;

                if (isMobilePortrait) {
                    explanation = "Your knights may make large knight's moves\n(moving forward 3 squares and 1 square to\nthe side).";
                } else {
                    explanation = "Your knights may make large\nknight's moves (moving\nforward 3 squares and 1\nsquare to the side).";
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, explanation, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, DTLibrary.DTColor.Black());

                this.chessPiecesRenderer.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE), this.chessPiecesRendererPieceAnimation, ChessCompStompWithHacksLibrary.GameImageUtil.HackExplanationChessPieceScalingFactor, isMobileDisplayType);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackExplanation_OpponentMustCaptureWhenPossible", {
        inherits: [ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.IHackExplanation],
        fields: {
            chessPiecesRenderer: null,
            chessPiecesRendererPieceAnimation: null,
            moveCooldown: 0,
            random: null,
            colorTheme: 0,
            gameState: null,
            playerMove: null,
            status: 0,
            nextMove: null,
            previousMoveSquares: null,
            possibleMoveSquares: null,
            chessPiecesRendererFadeOutFadeIn: null,
            lastRandomValue: null
        },
        alias: [
            "ProcessFrame", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$ProcessFrame",
            "Render", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$Render"
        ],
        ctors: {
            ctor: function (colorTheme, random) {
                this.$initialize();
                this.lastRandomValue = null;

                this.chessPiecesRendererFadeOutFadeIn = null;

                this.colorTheme = colorTheme;

                this.random = random;

                this.moveCooldown = 750000;

                this.PopulateInitialBoard(random);

                this.chessPiecesRenderer = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetChessPiecesRenderer(this.gameState.Board, null, this.previousMoveSquares, true, colorTheme);

                this.chessPiecesRendererPieceAnimation = ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.EmptyChessPiecesRendererPieceAnimation();
            }
        },
        methods: {
            PopulateInitialBoard: function (random) {
                this.gameState = ChessCompStompWithHacksLibrary.NewGameCreation.CreateNewGame(true, new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.Hack)).$ctor1(function (_o1) {
                        _o1.add(ChessCompStompWithHacksEngine.Hack.OpponentMustCaptureWhenPossible);
                        return _o1;
                    }(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.Hack)).ctor())), ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.Initial);

                if (this.lastRandomValue == null) {
                    this.lastRandomValue = random.DTLibrary$IDTRandom$NextInt(3);
                } else {
                    var possibleValues = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    if (System.Nullable.getValue(this.lastRandomValue) !== 0) {
                        possibleValues.add(0);
                    }
                    if (System.Nullable.getValue(this.lastRandomValue) !== 1) {
                        possibleValues.add(1);
                    }
                    if (System.Nullable.getValue(this.lastRandomValue) !== 2) {
                        possibleValues.add(2);
                    }

                    this.lastRandomValue = possibleValues.getItem(random.DTLibrary$IDTRandom$NextInt(possibleValues.Count));
                }

                switch (System.Nullable.getValue(this.lastRandomValue)) {
                    case 0: 
                        this.gameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(this.gameState, ChessCompStompWithHacksEngine.Move.NormalMove(4, 1, 4, 3));
                        this.gameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(this.gameState, ChessCompStompWithHacksEngine.Move.NormalMove(4, 6, 4, 4));
                        this.playerMove = ChessCompStompWithHacksEngine.Move.NormalMove(7, 1, 7, 3);
                        break;
                    case 1: 
                        this.gameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(this.gameState, ChessCompStompWithHacksEngine.Move.NormalMove(6, 0, 5, 2));
                        this.gameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(this.gameState, ChessCompStompWithHacksEngine.Move.NormalMove(1, 7, 2, 5));
                        this.playerMove = ChessCompStompWithHacksEngine.Move.NormalMove(3, 1, 3, 3);
                        break;
                    case 2: 
                        this.gameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(this.gameState, ChessCompStompWithHacksEngine.Move.NormalMove(1, 0, 2, 2));
                        this.gameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(this.gameState, ChessCompStompWithHacksEngine.Move.NormalMove(4, 6, 4, 4));
                        this.playerMove = ChessCompStompWithHacksEngine.Move.NormalMove(0, 1, 0, 2);
                        break;
                    default: 
                        throw new System.Exception();
                }

                this.previousMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();
                this.possibleMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();

                this.status = ChessCompStompWithHacksLibrary.HackExplanation_OpponentMustCaptureWhenPossible.Status.PlayerAboutToClickFirstPiece;

                this.nextMove = this.playerMove;
            },
            ProcessFrame: function (mouseInput, previousMouseInput, displayProcessing, elapsedMicrosPerFrame) {
                if (this.chessPiecesRendererFadeOutFadeIn != null) {
                    this.chessPiecesRendererFadeOutFadeIn.ProcessFrame(elapsedMicrosPerFrame);

                    if (this.chessPiecesRendererFadeOutFadeIn.HasFinishedFadingOut() && this.status !== ChessCompStompWithHacksLibrary.HackExplanation_OpponentMustCaptureWhenPossible.Status.PlayerAboutToClickFirstPiece) {
                        this.PopulateInitialBoard(this.random);
                    }

                    if (this.chessPiecesRendererFadeOutFadeIn.HasFinishedFadingIn()) {
                        this.chessPiecesRendererFadeOutFadeIn = null;
                    }
                } else {
                    this.moveCooldown = (this.moveCooldown - elapsedMicrosPerFrame) | 0;
                    if (this.moveCooldown <= 0) {
                        this.moveCooldown = (this.moveCooldown + (750000)) | 0;

                        if (this.status === ChessCompStompWithHacksLibrary.HackExplanation_OpponentMustCaptureWhenPossible.Status.PlayerAboutToMakeSecondMove) {
                            this.moveCooldown = (this.moveCooldown + (750000)) | 0;
                        }

                        if (this.moveCooldown <= 0) {
                            this.moveCooldown = 0;
                        }

                        switch (this.status) {
                            case ChessCompStompWithHacksLibrary.HackExplanation_OpponentMustCaptureWhenPossible.Status.PlayerAboutToClickFirstPiece: 
                                this.status = ChessCompStompWithHacksLibrary.HackExplanation_OpponentMustCaptureWhenPossible.Status.PlayerAboutToMakeFirstMove;
                                this.possibleMoveSquares = new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor2(System.Linq.Enumerable.from(ChessCompStompWithHacksEngine.ComputeMoves.GetMoves(this.gameState).Moves).where(Bridge.fn.bind(this, function (x) {
                                        return System.Nullable.hasValue(x.StartingFile) && System.Nullable.getValue(x.StartingFile) === System.Nullable.getValue(this.playerMove.StartingFile) && System.Nullable.hasValue(x.StartingRank) && System.Nullable.getValue(x.StartingRank) === System.Nullable.getValue(this.playerMove.StartingRank);
                                    })).select(function (x) {
                                    return new ChessCompStompWithHacksEngine.ChessSquare(x.EndingFile, x.EndingRank);
                                }).toList(ChessCompStompWithHacksEngine.ChessSquare));
                                break;
                            case ChessCompStompWithHacksLibrary.HackExplanation_OpponentMustCaptureWhenPossible.Status.PlayerAboutToMakeFirstMove: 
                                this.status = ChessCompStompWithHacksLibrary.HackExplanation_OpponentMustCaptureWhenPossible.Status.OpponentAboutToClickPiece;
                                this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.AddMove$1(this.gameState, this.playerMove, false);
                                this.gameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(this.gameState, this.playerMove);
                                this.possibleMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();
                                this.previousMoveSquares = new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor1(Bridge.fn.bind(this, function (_o1) {
                                        _o1.add(new ChessCompStompWithHacksEngine.ChessSquare(System.Nullable.getValue(this.playerMove.StartingFile), System.Nullable.getValue(this.playerMove.StartingRank)));
                                        _o1.add(new ChessCompStompWithHacksEngine.ChessSquare(this.playerMove.EndingFile, this.playerMove.EndingRank));
                                        return _o1;
                                    })(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor()));
                                this.nextMove = ChessCompStompWithHacksEngine.ComputeMoves.GetMoves(this.gameState).Moves.getItem(0);
                                break;
                            case ChessCompStompWithHacksLibrary.HackExplanation_OpponentMustCaptureWhenPossible.Status.OpponentAboutToClickPiece: 
                                this.status = ChessCompStompWithHacksLibrary.HackExplanation_OpponentMustCaptureWhenPossible.Status.OpponentAboutToMakeMove;
                                break;
                            case ChessCompStompWithHacksLibrary.HackExplanation_OpponentMustCaptureWhenPossible.Status.OpponentAboutToMakeMove: 
                                this.status = ChessCompStompWithHacksLibrary.HackExplanation_OpponentMustCaptureWhenPossible.Status.PlayerAboutToClickSecondPiece;
                                this.previousMoveSquares = new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor1(Bridge.fn.bind(this, function (_o2) {
                                        _o2.add(new ChessCompStompWithHacksEngine.ChessSquare(System.Nullable.getValue(this.nextMove.StartingFile), System.Nullable.getValue(this.nextMove.StartingRank)));
                                        _o2.add(new ChessCompStompWithHacksEngine.ChessSquare(this.nextMove.EndingFile, this.nextMove.EndingRank));
                                        return _o2;
                                    })(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor()));
                                this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.AddMove$1(this.gameState, this.nextMove, false);
                                this.gameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(this.gameState, this.nextMove);
                                var possibleNextMoves = System.Linq.Enumerable.from(ChessCompStompWithHacksEngine.ComputeMoves.GetMoves(this.gameState).Moves).where(Bridge.fn.bind(this, function (x) {
                                        return x.EndingFile === this.nextMove.EndingFile && x.EndingRank === this.nextMove.EndingRank;
                                    })).toList(ChessCompStompWithHacksEngine.Move);
                                DTLibrary.ListUtil.Shuffle(ChessCompStompWithHacksEngine.Move, possibleNextMoves, this.random);
                                this.nextMove = possibleNextMoves.getItem(0);
                                break;
                            case ChessCompStompWithHacksLibrary.HackExplanation_OpponentMustCaptureWhenPossible.Status.PlayerAboutToClickSecondPiece: 
                                this.status = ChessCompStompWithHacksLibrary.HackExplanation_OpponentMustCaptureWhenPossible.Status.PlayerAboutToMakeSecondMove;
                                this.possibleMoveSquares = new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor2(System.Linq.Enumerable.from(ChessCompStompWithHacksEngine.ComputeMoves.GetMoves(this.gameState).Moves).where(Bridge.fn.bind(this, function (x) {
                                        return System.Nullable.hasValue(x.StartingFile) && System.Nullable.getValue(x.StartingFile) === System.Nullable.getValue(this.nextMove.StartingFile) && System.Nullable.hasValue(x.StartingRank) && System.Nullable.getValue(x.StartingRank) === System.Nullable.getValue(this.nextMove.StartingRank);
                                    })).select(function (x) {
                                    return new ChessCompStompWithHacksEngine.ChessSquare(x.EndingFile, x.EndingRank);
                                }).toList(ChessCompStompWithHacksEngine.ChessSquare));
                                break;
                            case ChessCompStompWithHacksLibrary.HackExplanation_OpponentMustCaptureWhenPossible.Status.PlayerAboutToMakeSecondMove: 
                                this.status = ChessCompStompWithHacksLibrary.HackExplanation_OpponentMustCaptureWhenPossible.Status.Finished;
                                this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.AddMove$1(this.gameState, this.nextMove, false);
                                this.gameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(this.gameState, this.nextMove);
                                this.possibleMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();
                                this.previousMoveSquares = new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor1(Bridge.fn.bind(this, function (_o3) {
                                        _o3.add(new ChessCompStompWithHacksEngine.ChessSquare(System.Nullable.getValue(this.nextMove.StartingFile), System.Nullable.getValue(this.nextMove.StartingRank)));
                                        _o3.add(new ChessCompStompWithHacksEngine.ChessSquare(this.nextMove.EndingFile, this.nextMove.EndingRank));
                                        return _o3;
                                    })(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor()));
                                this.nextMove = null;
                                break;
                            case ChessCompStompWithHacksLibrary.HackExplanation_OpponentMustCaptureWhenPossible.Status.Finished: 
                                this.chessPiecesRendererFadeOutFadeIn = new ChessCompStompWithHacksLibrary.ChessPiecesRendererFadeOutFadeIn(this.colorTheme);
                                break;
                            default: 
                                throw new System.Exception();
                        }
                    }
                }

                this.chessPiecesRenderer = this.chessPiecesRenderer.ProcessFrame(this.gameState.Board, null, this.previousMoveSquares, this.status === ChessCompStompWithHacksLibrary.HackExplanation_OpponentMustCaptureWhenPossible.Status.PlayerAboutToMakeFirstMove || this.status === ChessCompStompWithHacksLibrary.HackExplanation_OpponentMustCaptureWhenPossible.Status.PlayerAboutToMakeSecondMove ? new ChessCompStompWithHacksEngine.ChessSquare(System.Nullable.getValue(this.nextMove.StartingFile), System.Nullable.getValue(this.nextMove.StartingRank)) : null, this.possibleMoveSquares, null, null, null, elapsedMicrosPerFrame);

                this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.ProcessFrame(elapsedMicrosPerFrame);
            },
            Render: function (displayOutput, isMobileDisplayType) {
                var isMobilePortrait = isMobileDisplayType && !DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? 161 : 311, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, ChessCompStompWithHacksLibrary.HackUtil.GetHackNameForHackExplanationPanel(ChessCompStompWithHacksEngine.Hack.OpponentMustCaptureWhenPossible), ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                var explanation;

                if (isMobilePortrait) {
                    explanation = "Capturing is compulsory for your opponent\n(if your opponent can capture a piece, your\nopponent must capture a piece).";
                } else {
                    explanation = "Capturing is compulsory for\nyour opponent (if your\nopponent can capture a piece,\nyour opponent must capture\na piece).";
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, explanation, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, DTLibrary.DTColor.Black());

                this.chessPiecesRenderer.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE), this.chessPiecesRendererPieceAnimation, ChessCompStompWithHacksLibrary.GameImageUtil.HackExplanationChessPieceScalingFactor, isMobileDisplayType);

                if (this.chessPiecesRendererFadeOutFadeIn != null) {
                    this.chessPiecesRendererFadeOutFadeIn.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE), ChessCompStompWithHacksLibrary.GameImageUtil.HackExplanationChessPieceScalingFactor);
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackExplanation_PawnsCanMoveThreeSpacesInitially", {
        inherits: [ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.IHackExplanation],
        statics: {
            methods: {
                GetInitialBoard: function () {
                    var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9;
                    var boardArray = System.Array.init(8, null, System.Array.type(ChessCompStompWithHacksEngine.ChessSquarePiece));
                    for (var i = 0; i < 8; i = (i + 1) | 0) {
                        boardArray[System.Array.index(i, boardArray)] = System.Array.init(8, 0, ChessCompStompWithHacksEngine.ChessSquarePiece);
                        for (var j = 0; j < 8; j = (j + 1) | 0) {
                            ($t = boardArray[System.Array.index(i, boardArray)])[System.Array.index(j, $t)] = ChessCompStompWithHacksEngine.ChessSquarePiece.Empty;
                        }
                    }

                    for (var i1 = 0; i1 < 8; i1 = (i1 + 1) | 0) {
                        ($t1 = boardArray[System.Array.index(i1, boardArray)])[System.Array.index(1, $t1)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn;
                    }

                    ($t2 = boardArray[System.Array.index(0, boardArray)])[System.Array.index(0, $t2)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook;
                    ($t3 = boardArray[System.Array.index(1, boardArray)])[System.Array.index(0, $t3)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKnight;
                    ($t4 = boardArray[System.Array.index(2, boardArray)])[System.Array.index(0, $t4)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteBishop;
                    ($t5 = boardArray[System.Array.index(3, boardArray)])[System.Array.index(0, $t5)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteQueen;
                    ($t6 = boardArray[System.Array.index(4, boardArray)])[System.Array.index(0, $t6)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKing;
                    ($t7 = boardArray[System.Array.index(5, boardArray)])[System.Array.index(0, $t7)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteBishop;
                    ($t8 = boardArray[System.Array.index(6, boardArray)])[System.Array.index(0, $t8)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKnight;
                    ($t9 = boardArray[System.Array.index(7, boardArray)])[System.Array.index(0, $t9)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook;

                    return new ChessCompStompWithHacksEngine.ChessSquarePieceArray.$ctor1(boardArray);
                },
                GetPawnFilesThatHaveNotYetMoved: function (board) {
                    var pawnFilesThatHaveNotYetMoved = new (System.Collections.Generic.List$1(System.Int32)).ctor();

                    for (var i = 0; i < 8; i = (i + 1) | 0) {
                        if (board.GetPiece$1(i, 1) === ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn) {
                            pawnFilesThatHaveNotYetMoved.add(i);
                        }
                    }

                    return pawnFilesThatHaveNotYetMoved;
                }
            }
        },
        fields: {
            chessPiecesRenderer: null,
            chessPiecesRendererPieceAnimation: null,
            moveCooldown: 0,
            random: null,
            colorTheme: 0,
            board: null,
            previousMoveSquares: null,
            possibleMoveSquares: null,
            chessPiecesRendererFadeOutFadeIn: null
        },
        alias: [
            "ProcessFrame", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$ProcessFrame",
            "Render", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$Render"
        ],
        ctors: {
            ctor: function (colorTheme, random) {
                this.$initialize();
                this.chessPiecesRendererFadeOutFadeIn = null;

                this.colorTheme = colorTheme;

                this.random = random;

                this.moveCooldown = ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.ELAPSED_MICROS_BEFORE_PIECE_MOVES;

                this.board = ChessCompStompWithHacksLibrary.HackExplanation_PawnsCanMoveThreeSpacesInitially.GetInitialBoard();

                this.previousMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();
                this.possibleMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();

                this.chessPiecesRenderer = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetChessPiecesRenderer(this.board, null, this.previousMoveSquares, true, colorTheme);

                this.chessPiecesRendererPieceAnimation = ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.EmptyChessPiecesRendererPieceAnimation();
            }
        },
        methods: {
            ProcessFrame: function (mouseInput, previousMouseInput, displayProcessing, elapsedMicrosPerFrame) {
                if (this.chessPiecesRendererFadeOutFadeIn != null) {
                    this.chessPiecesRendererFadeOutFadeIn.ProcessFrame(elapsedMicrosPerFrame);

                    if (this.chessPiecesRendererFadeOutFadeIn.HasFinishedFadingOut() && ChessCompStompWithHacksLibrary.HackExplanation_PawnsCanMoveThreeSpacesInitially.GetPawnFilesThatHaveNotYetMoved(this.board).Count === 0) {
                        this.board = ChessCompStompWithHacksLibrary.HackExplanation_PawnsCanMoveThreeSpacesInitially.GetInitialBoard();
                        this.previousMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();
                        this.possibleMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();
                    }

                    if (this.chessPiecesRendererFadeOutFadeIn.HasFinishedFadingIn()) {
                        this.chessPiecesRendererFadeOutFadeIn = null;
                    }
                } else {
                    this.moveCooldown = (this.moveCooldown - elapsedMicrosPerFrame) | 0;
                    if (this.moveCooldown <= 0) {
                        this.moveCooldown = (this.moveCooldown + ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.ELAPSED_MICROS_BEFORE_PIECE_MOVES) | 0;
                        if (this.moveCooldown <= 0) {
                            this.moveCooldown = 0;
                        }

                        if (this.possibleMoveSquares.Count === 0) {
                            var pawnFilesThatHaveNotYetMoved = ChessCompStompWithHacksLibrary.HackExplanation_PawnsCanMoveThreeSpacesInitially.GetPawnFilesThatHaveNotYetMoved(this.board);
                            if (pawnFilesThatHaveNotYetMoved.Count > 0) {
                                var file = pawnFilesThatHaveNotYetMoved.getItem(this.random.DTLibrary$IDTRandom$NextInt(pawnFilesThatHaveNotYetMoved.Count));
                                this.possibleMoveSquares = new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor1(function (_o1) {
                                        _o1.add(new ChessCompStompWithHacksEngine.ChessSquare(file, 2));
                                        _o1.add(new ChessCompStompWithHacksEngine.ChessSquare(file, 3));
                                        _o1.add(new ChessCompStompWithHacksEngine.ChessSquare(file, 4));
                                        return _o1;
                                    }(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor()));
                            } else {
                                this.chessPiecesRendererFadeOutFadeIn = new ChessCompStompWithHacksLibrary.ChessPiecesRendererFadeOutFadeIn(this.colorTheme);
                            }
                        } else {
                            var endingRank;
                            if (this.random.DTLibrary$IDTRandom$NextInt(100) < 70) {
                                endingRank = 4;
                            } else {
                                endingRank = this.random.DTLibrary$IDTRandom$NextBool() ? 3 : 2;
                            }

                            var file1 = this.possibleMoveSquares.getItem(0).File;

                            this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.AddRawMove(file1, 1, file1, endingRank, ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn);

                            this.board = this.board.SetPiece(file1, 1, ChessCompStompWithHacksEngine.ChessSquarePiece.Empty);
                            this.board = this.board.SetPiece(file1, endingRank, ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn);

                            this.previousMoveSquares = new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor1(function (_o2) {
                                    _o2.add(new ChessCompStompWithHacksEngine.ChessSquare(file1, 1));
                                    _o2.add(new ChessCompStompWithHacksEngine.ChessSquare(file1, endingRank));
                                    return _o2;
                                }(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor()));
                            this.possibleMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();
                        }
                    }
                }

                this.chessPiecesRenderer = this.chessPiecesRenderer.ProcessFrame(this.board, null, this.previousMoveSquares, this.possibleMoveSquares.Count > 0 ? new ChessCompStompWithHacksEngine.ChessSquare(this.possibleMoveSquares.getItem(0).File, 1) : null, this.possibleMoveSquares, null, null, null, elapsedMicrosPerFrame);

                this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.ProcessFrame(elapsedMicrosPerFrame);
            },
            Render: function (displayOutput, isMobileDisplayType) {
                var isMobilePortrait = isMobileDisplayType && !DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? 221 : 371, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, ChessCompStompWithHacksLibrary.HackUtil.GetHackNameForHackExplanationPanel(ChessCompStompWithHacksEngine.Hack.PawnsCanMoveThreeSpacesInitially), ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                var explanation;

                if (isMobilePortrait) {
                    explanation = "The first time a pawn moves, the pawn may\nmove forward 3 squares.\n\nA pawn that moves forward 3 squares cannot\nbe captured en passant.";
                } else {
                    explanation = "The first time a pawn moves,\nthe pawn may move forward\n3 squares.\n\nA pawn that moves forward\n3 squares cannot be\ncaptured en passant.";
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, explanation, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, DTLibrary.DTColor.Black());

                this.chessPiecesRenderer.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE), this.chessPiecesRendererPieceAnimation, ChessCompStompWithHacksLibrary.GameImageUtil.HackExplanationChessPieceScalingFactor, isMobileDisplayType);

                if (this.chessPiecesRendererFadeOutFadeIn != null) {
                    this.chessPiecesRendererFadeOutFadeIn.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE), ChessCompStompWithHacksLibrary.GameImageUtil.HackExplanationChessPieceScalingFactor);
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackExplanation_PawnsDestroyCapturingPiece", {
        inherits: [ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.IHackExplanation],
        fields: {
            chessPiecesRenderer: null,
            chessPiecesRendererPieceAnimation: null,
            moveCooldown: 0,
            random: null,
            colorTheme: 0,
            gameState: null,
            playerMove: null,
            opponentMove: null,
            status: 0,
            previousMoveSquares: null,
            possibleMoveSquares: null,
            chessPiecesRendererFadeOutFadeIn: null,
            lastRandomValue: null
        },
        alias: [
            "ProcessFrame", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$ProcessFrame",
            "Render", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$Render"
        ],
        ctors: {
            ctor: function (colorTheme, random) {
                this.$initialize();
                this.lastRandomValue = null;

                this.chessPiecesRendererFadeOutFadeIn = null;

                this.colorTheme = colorTheme;

                this.random = random;

                this.moveCooldown = 750000;

                this.PopulateInitialBoard(random);

                this.chessPiecesRenderer = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetChessPiecesRenderer(this.gameState.Board, null, this.previousMoveSquares, true, colorTheme);

                this.chessPiecesRendererPieceAnimation = ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.EmptyChessPiecesRendererPieceAnimation();
            }
        },
        methods: {
            PopulateInitialBoard: function (random) {
                this.gameState = ChessCompStompWithHacksLibrary.NewGameCreation.CreateNewGame(true, new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.Hack)).$ctor1(function (_o1) {
                        _o1.add(ChessCompStompWithHacksEngine.Hack.PawnsDestroyCapturingPiece);
                        return _o1;
                    }(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.Hack)).ctor())), ChessCompStompWithHacksLibrary.SessionState.AIHackLevel.Initial);

                if (this.lastRandomValue == null) {
                    this.lastRandomValue = random.DTLibrary$IDTRandom$NextInt(3);
                } else {
                    var possibleValues = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    if (System.Nullable.getValue(this.lastRandomValue) !== 0) {
                        possibleValues.add(0);
                    }
                    if (System.Nullable.getValue(this.lastRandomValue) !== 1) {
                        possibleValues.add(1);
                    }
                    if (System.Nullable.getValue(this.lastRandomValue) !== 2) {
                        possibleValues.add(2);
                    }

                    this.lastRandomValue = possibleValues.getItem(random.DTLibrary$IDTRandom$NextInt(possibleValues.Count));
                }

                switch (System.Nullable.getValue(this.lastRandomValue)) {
                    case 0: 
                        this.gameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(this.gameState, ChessCompStompWithHacksEngine.Move.NormalMove(5, 1, 5, 3));
                        this.gameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(this.gameState, ChessCompStompWithHacksEngine.Move.NormalMove(3, 6, 3, 4));
                        this.playerMove = ChessCompStompWithHacksEngine.Move.NormalMove(5, 3, 5, 4);
                        this.opponentMove = ChessCompStompWithHacksEngine.Move.NormalMove(2, 7, 5, 4);
                        break;
                    case 1: 
                        this.gameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(this.gameState, ChessCompStompWithHacksEngine.Move.NormalMove(4, 1, 4, 3));
                        this.gameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(this.gameState, ChessCompStompWithHacksEngine.Move.NormalMove(2, 6, 2, 4));
                        this.gameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(this.gameState, ChessCompStompWithHacksEngine.Move.NormalMove(0, 1, 0, 3));
                        this.gameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(this.gameState, ChessCompStompWithHacksEngine.Move.NormalMove(1, 7, 2, 5));
                        this.playerMove = ChessCompStompWithHacksEngine.Move.NormalMove(0, 3, 0, 4);
                        this.opponentMove = random.DTLibrary$IDTRandom$NextBool() ? ChessCompStompWithHacksEngine.Move.NormalMove(3, 7, 0, 4) : ChessCompStompWithHacksEngine.Move.NormalMove(2, 5, 0, 4);
                        break;
                    case 2: 
                        this.gameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(this.gameState, ChessCompStompWithHacksEngine.Move.NormalMove(3, 1, 3, 3));
                        this.gameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(this.gameState, ChessCompStompWithHacksEngine.Move.NormalMove(3, 6, 3, 4));
                        this.playerMove = ChessCompStompWithHacksEngine.Move.NormalMove(2, 1, 2, 3);
                        this.opponentMove = ChessCompStompWithHacksEngine.Move.NormalMove(3, 4, 2, 3);
                        break;
                    default: 
                        throw new System.Exception();
                }

                this.previousMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();
                this.possibleMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();

                this.status = ChessCompStompWithHacksLibrary.HackExplanation_PawnsDestroyCapturingPiece.Status.PlayerAboutToClickPiece;
            },
            ProcessFrame: function (mouseInput, previousMouseInput, displayProcessing, elapsedMicrosPerFrame) {
                if (this.chessPiecesRendererFadeOutFadeIn != null) {
                    this.chessPiecesRendererFadeOutFadeIn.ProcessFrame(elapsedMicrosPerFrame);

                    if (this.chessPiecesRendererFadeOutFadeIn.HasFinishedFadingOut() && this.status !== ChessCompStompWithHacksLibrary.HackExplanation_PawnsDestroyCapturingPiece.Status.PlayerAboutToClickPiece) {
                        this.PopulateInitialBoard(this.random);
                    }

                    if (this.chessPiecesRendererFadeOutFadeIn.HasFinishedFadingIn()) {
                        this.chessPiecesRendererFadeOutFadeIn = null;
                    }
                } else {
                    this.moveCooldown = (this.moveCooldown - elapsedMicrosPerFrame) | 0;
                    if (this.moveCooldown <= 0) {
                        this.moveCooldown = (this.moveCooldown + (750000)) | 0;

                        if (this.status === ChessCompStompWithHacksLibrary.HackExplanation_PawnsDestroyCapturingPiece.Status.OpponentAboutToMakeMove) {
                            this.moveCooldown = (this.moveCooldown + (750000)) | 0;
                        }

                        if (this.moveCooldown <= 0) {
                            this.moveCooldown = 0;
                        }

                        switch (this.status) {
                            case ChessCompStompWithHacksLibrary.HackExplanation_PawnsDestroyCapturingPiece.Status.PlayerAboutToClickPiece: 
                                this.status = ChessCompStompWithHacksLibrary.HackExplanation_PawnsDestroyCapturingPiece.Status.PlayerAboutToMakeMove;
                                this.possibleMoveSquares = new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor2(System.Linq.Enumerable.from(ChessCompStompWithHacksEngine.ComputeMoves.GetMoves(this.gameState).Moves).where(Bridge.fn.bind(this, function (x) {
                                        return System.Nullable.hasValue(x.StartingFile) && System.Nullable.getValue(x.StartingFile) === System.Nullable.getValue(this.playerMove.StartingFile) && System.Nullable.hasValue(x.StartingRank) && System.Nullable.getValue(x.StartingRank) === System.Nullable.getValue(this.playerMove.StartingRank);
                                    })).select(function (x) {
                                    return new ChessCompStompWithHacksEngine.ChessSquare(x.EndingFile, x.EndingRank);
                                }).toList(ChessCompStompWithHacksEngine.ChessSquare));
                                break;
                            case ChessCompStompWithHacksLibrary.HackExplanation_PawnsDestroyCapturingPiece.Status.PlayerAboutToMakeMove: 
                                this.status = ChessCompStompWithHacksLibrary.HackExplanation_PawnsDestroyCapturingPiece.Status.OpponentAboutToClickPiece;
                                this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.AddMove$1(this.gameState, this.playerMove, false);
                                this.gameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(this.gameState, this.playerMove);
                                this.possibleMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();
                                this.previousMoveSquares = new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor1(Bridge.fn.bind(this, function (_o1) {
                                        _o1.add(new ChessCompStompWithHacksEngine.ChessSquare(System.Nullable.getValue(this.playerMove.StartingFile), System.Nullable.getValue(this.playerMove.StartingRank)));
                                        _o1.add(new ChessCompStompWithHacksEngine.ChessSquare(this.playerMove.EndingFile, this.playerMove.EndingRank));
                                        return _o1;
                                    })(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor()));
                                break;
                            case ChessCompStompWithHacksLibrary.HackExplanation_PawnsDestroyCapturingPiece.Status.OpponentAboutToClickPiece: 
                                this.status = ChessCompStompWithHacksLibrary.HackExplanation_PawnsDestroyCapturingPiece.Status.OpponentAboutToMakeMove;
                                break;
                            case ChessCompStompWithHacksLibrary.HackExplanation_PawnsDestroyCapturingPiece.Status.OpponentAboutToMakeMove: 
                                this.status = ChessCompStompWithHacksLibrary.HackExplanation_PawnsDestroyCapturingPiece.Status.Finished;
                                this.previousMoveSquares = new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor1(Bridge.fn.bind(this, function (_o2) {
                                        _o2.add(new ChessCompStompWithHacksEngine.ChessSquare(System.Nullable.getValue(this.opponentMove.StartingFile), System.Nullable.getValue(this.opponentMove.StartingRank)));
                                        _o2.add(new ChessCompStompWithHacksEngine.ChessSquare(this.opponentMove.EndingFile, this.opponentMove.EndingRank));
                                        return _o2;
                                    })(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor()));
                                this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.AddMove$1(this.gameState, this.opponentMove, false);
                                this.gameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(this.gameState, this.opponentMove);
                                break;
                            case ChessCompStompWithHacksLibrary.HackExplanation_PawnsDestroyCapturingPiece.Status.Finished: 
                                this.chessPiecesRendererFadeOutFadeIn = new ChessCompStompWithHacksLibrary.ChessPiecesRendererFadeOutFadeIn(this.colorTheme);
                                break;
                            default: 
                                throw new System.Exception();
                        }
                    }
                }

                this.chessPiecesRenderer = this.chessPiecesRenderer.ProcessFrame(this.gameState.Board, null, this.previousMoveSquares, this.status === ChessCompStompWithHacksLibrary.HackExplanation_PawnsDestroyCapturingPiece.Status.PlayerAboutToMakeMove ? new ChessCompStompWithHacksEngine.ChessSquare(System.Nullable.getValue(this.playerMove.StartingFile), System.Nullable.getValue(this.playerMove.StartingRank)) : null, this.possibleMoveSquares, null, null, null, elapsedMicrosPerFrame);

                this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.ProcessFrame(elapsedMicrosPerFrame);
            },
            Render: function (displayOutput, isMobileDisplayType) {
                var isMobilePortrait = isMobileDisplayType && !DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? 181 : 331, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, ChessCompStompWithHacksLibrary.HackUtil.GetHackNameForHackExplanationPanel(ChessCompStompWithHacksEngine.Hack.PawnsDestroyCapturingPiece), ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                var explanation;

                if (isMobilePortrait) {
                    explanation = "When any of your pawns are captured, the\ncapturing piece is also removed from the\nboard.\n\nYour opponent's king cannot capture your\npawns.";
                } else {
                    explanation = "When any of your pawns are\ncaptured, the capturing piece\nis also removed from the\nboard.\n\nYour opponent's king cannot\ncapture your pawns.";
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, explanation, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, DTLibrary.DTColor.Black());

                this.chessPiecesRenderer.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE), this.chessPiecesRendererPieceAnimation, ChessCompStompWithHacksLibrary.GameImageUtil.HackExplanationChessPieceScalingFactor, isMobileDisplayType);

                if (this.chessPiecesRendererFadeOutFadeIn != null) {
                    this.chessPiecesRendererFadeOutFadeIn.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE), ChessCompStompWithHacksLibrary.GameImageUtil.HackExplanationChessPieceScalingFactor);
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackExplanation_QueensCanMoveLikeKnights", {
        inherits: [ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.IHackExplanation],
        statics: {
            methods: {
                GetPossibleKnightQueenMoves: function (queenSquare) {
                    var $t;
                    var list = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor();

                    var i = queenSquare.File;
                    var j = queenSquare.Rank;

                    var knightMoves = new (System.Collections.Generic.List$1(System.Tuple$2(System.Int32,System.Int32))).ctor();
                    knightMoves.add({ Item1: ((i + 1) | 0), Item2: ((j + 2) | 0) });
                    knightMoves.add({ Item1: ((i + 1) | 0), Item2: ((j - 2) | 0) });
                    knightMoves.add({ Item1: ((i - 1) | 0), Item2: ((j + 2) | 0) });
                    knightMoves.add({ Item1: ((i - 1) | 0), Item2: ((j - 2) | 0) });
                    knightMoves.add({ Item1: ((i + 2) | 0), Item2: ((j + 1) | 0) });
                    knightMoves.add({ Item1: ((i + 2) | 0), Item2: ((j - 1) | 0) });
                    knightMoves.add({ Item1: ((i - 2) | 0), Item2: ((j + 1) | 0) });
                    knightMoves.add({ Item1: ((i - 2) | 0), Item2: ((j - 1) | 0) });

                    $t = Bridge.getEnumerator(knightMoves);
                    try {
                        while ($t.moveNext()) {
                            var knightMove = $t.Current;
                            if (0 <= knightMove.Item1 && knightMove.Item1 < 8 && 0 <= knightMove.Item2 && knightMove.Item2 < 8) {
                                list.add(new ChessCompStompWithHacksEngine.ChessSquare(knightMove.Item1, knightMove.Item2));
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    return list;
                },
                GetPossibleNormalQueenMoves: function (queenSquare) {
                    var $t;
                    var list = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor();

                    var i = queenSquare.File;
                    var j = queenSquare.Rank;

                    var deltas = new (System.Collections.Generic.List$1(System.Tuple$2(System.Int32,System.Int32))).ctor();
                    deltas.add({ Item1: 0, Item2: 1 });
                    deltas.add({ Item1: 0, Item2: -1 });
                    deltas.add({ Item1: 1, Item2: 0 });
                    deltas.add({ Item1: -1, Item2: 0 });
                    deltas.add({ Item1: 1, Item2: 1 });
                    deltas.add({ Item1: 1, Item2: -1 });
                    deltas.add({ Item1: -1, Item2: 1 });
                    deltas.add({ Item1: -1, Item2: -1 });

                    $t = Bridge.getEnumerator(deltas);
                    try {
                        while ($t.moveNext()) {
                            var delta = $t.Current;
                            var endI = i;
                            var endJ = j;
                            while (true) {
                                endI = (endI + delta.Item1) | 0;
                                endJ = (endJ + delta.Item2) | 0;
                                if (endI < 0 || endI >= 8 || endJ < 0 || endJ >= 8) {
                                    break;
                                }

                                list.add(new ChessCompStompWithHacksEngine.ChessSquare(endI, endJ));
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    return list;
                }
            }
        },
        fields: {
            chessPiecesRenderer: null,
            chessPiecesRendererPieceAnimation: null,
            queenSquare: null,
            potentialNormalQueenMoves: null,
            potentialKnightQueenMoves: null,
            previousMoveSquares: null,
            moveCooldown: 0,
            random: null,
            colorTheme: 0
        },
        alias: [
            "ProcessFrame", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$ProcessFrame",
            "Render", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$Render"
        ],
        ctors: {
            ctor: function (colorTheme, random) {
                this.$initialize();
                this.colorTheme = colorTheme;

                this.random = random;

                this.queenSquare = new ChessCompStompWithHacksEngine.ChessSquare(random.DTLibrary$IDTRandom$NextInt(8), random.DTLibrary$IDTRandom$NextInt(8));

                this.potentialNormalQueenMoves = ChessCompStompWithHacksLibrary.HackExplanation_QueensCanMoveLikeKnights.GetPossibleNormalQueenMoves(this.queenSquare);
                this.potentialKnightQueenMoves = ChessCompStompWithHacksLibrary.HackExplanation_QueensCanMoveLikeKnights.GetPossibleKnightQueenMoves(this.queenSquare);

                this.moveCooldown = ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.ELAPSED_MICROS_BEFORE_PIECE_MOVES;

                var board = ChessCompStompWithHacksEngine.ChessSquarePieceArray.EmptyBoard();
                board = board.SetPiece(this.queenSquare.File, this.queenSquare.Rank, ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteQueen);

                this.previousMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();

                this.chessPiecesRenderer = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetChessPiecesRenderer(board, null, this.previousMoveSquares, true, this.colorTheme);

                this.chessPiecesRendererPieceAnimation = ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.EmptyChessPiecesRendererPieceAnimation();
            }
        },
        methods: {
            ProcessFrame: function (mouseInput, previousMouseInput, displayProcessing, elapsedMicrosPerFrame) {
                this.moveCooldown = (this.moveCooldown - elapsedMicrosPerFrame) | 0;
                if (this.moveCooldown <= 0) {
                    this.moveCooldown = (this.moveCooldown + ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.ELAPSED_MICROS_BEFORE_PIECE_MOVES) | 0;
                    if (this.moveCooldown <= 0) {
                        this.moveCooldown = 0;
                    }

                    var originalQueenSquare = this.queenSquare;

                    if (this.random.DTLibrary$IDTRandom$NextInt(100) < 70) {
                        this.queenSquare = this.potentialKnightQueenMoves.getItem(this.random.DTLibrary$IDTRandom$NextInt(this.potentialKnightQueenMoves.Count));
                    } else {
                        this.queenSquare = this.potentialNormalQueenMoves.getItem(this.random.DTLibrary$IDTRandom$NextInt(this.potentialNormalQueenMoves.Count));
                    }

                    this.potentialNormalQueenMoves = ChessCompStompWithHacksLibrary.HackExplanation_QueensCanMoveLikeKnights.GetPossibleNormalQueenMoves(this.queenSquare);
                    this.potentialKnightQueenMoves = ChessCompStompWithHacksLibrary.HackExplanation_QueensCanMoveLikeKnights.GetPossibleKnightQueenMoves(this.queenSquare);

                    this.previousMoveSquares = new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor1(Bridge.fn.bind(this, function (_o1) {
                            _o1.add(originalQueenSquare);
                            _o1.add(this.queenSquare);
                            return _o1;
                        })(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor()));

                    this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.AddRawMove(originalQueenSquare.File, originalQueenSquare.Rank, this.queenSquare.File, this.queenSquare.Rank, ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteQueen);
                }

                var board = ChessCompStompWithHacksEngine.ChessSquarePieceArray.EmptyBoard();
                board = board.SetPiece(this.queenSquare.File, this.queenSquare.Rank, ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteQueen);

                var allQueenMoves = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor();
                allQueenMoves.AddRange(this.potentialNormalQueenMoves);
                allQueenMoves.AddRange(this.potentialKnightQueenMoves);

                this.chessPiecesRenderer = this.chessPiecesRenderer.ProcessFrame(board, null, this.previousMoveSquares, null, DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).AsImmutableList(allQueenMoves), null, null, null, elapsedMicrosPerFrame);

                this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.ProcessFrame(elapsedMicrosPerFrame);
            },
            Render: function (displayOutput, isMobileDisplayType) {
                var isMobilePortrait = isMobileDisplayType && !DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? 194 : 344, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, ChessCompStompWithHacksLibrary.HackUtil.GetHackNameForHackExplanationPanel(ChessCompStompWithHacksEngine.Hack.QueensCanMoveLikeKnights), ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                var explanation;

                if (isMobilePortrait) {
                    explanation = "Your queen may also move as if it were a\nknight.";
                } else {
                    explanation = "Your queen may also move as\nif it were a knight.";
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, explanation, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, DTLibrary.DTColor.Black());

                this.chessPiecesRenderer.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE), this.chessPiecesRendererPieceAnimation, ChessCompStompWithHacksLibrary.GameImageUtil.HackExplanationChessPieceScalingFactor, isMobileDisplayType);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackExplanation_RooksCanCaptureLikeCannons", {
        inherits: [ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.IHackExplanation],
        statics: {
            methods: {
                GetPossibleMoveSquares: function (rookSquare, board) {
                    var $t;
                    var list = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor();

                    var directions = new (System.Collections.Generic.List$1(System.Tuple$2(System.Int32,System.Int32))).ctor();
                    directions.add({ Item1: 1, Item2: 0 });
                    directions.add({ Item1: -1, Item2: 0 });
                    directions.add({ Item1: 0, Item2: 1 });
                    directions.add({ Item1: 0, Item2: -1 });

                    $t = Bridge.getEnumerator(directions);
                    try {
                        while ($t.moveNext()) {
                            var direction = $t.Current;
                            var i = rookSquare.File;
                            var j = rookSquare.Rank;

                            var ranIntoAnotherPiece = false;

                            while (true) {
                                i = (i + direction.Item1) | 0;
                                j = (j + direction.Item2) | 0;

                                if (i < 0 || i >= 8 || j < 0 || j >= 8) {
                                    break;
                                }

                                if (board.GetPiece$1(i, j) === ChessCompStompWithHacksEngine.ChessSquarePiece.Empty) {
                                    if (!ranIntoAnotherPiece) {
                                        list.add(new ChessCompStompWithHacksEngine.ChessSquare(i, j));
                                    }
                                    continue;
                                }

                                if (ChessCompStompWithHacksEngine.ChessSquarePieceUtil.IsBlack(board.GetPiece$1(i, j))) {
                                    list.add(new ChessCompStompWithHacksEngine.ChessSquare(i, j));
                                    if (ranIntoAnotherPiece) {
                                        break;
                                    }
                                    ranIntoAnotherPiece = true;
                                } else {
                                    if (ranIntoAnotherPiece) {
                                        break;
                                    }
                                    ranIntoAnotherPiece = true;
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    return list;
                },
                GetRandomEnemyPiece: function (random) {
                    switch (random.DTLibrary$IDTRandom$NextInt(4)) {
                        case 0: 
                            return ChessCompStompWithHacksEngine.ChessSquarePiece.BlackRook;
                        case 1: 
                            return ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKnight;
                        case 2: 
                            return ChessCompStompWithHacksEngine.ChessSquarePiece.BlackBishop;
                        case 3: 
                            return ChessCompStompWithHacksEngine.ChessSquarePiece.BlackQueen;
                        default: 
                            throw new System.Exception();
                    }
                },
                GetRandomPlayerPiece: function (random) {
                    switch (random.DTLibrary$IDTRandom$NextInt(3)) {
                        case 0: 
                            return ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKnight;
                        case 1: 
                            return ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteBishop;
                        case 2: 
                            return ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteQueen;
                        default: 
                            throw new System.Exception();
                    }
                }
            }
        },
        fields: {
            chessPiecesRenderer: null,
            chessPiecesRendererPieceAnimation: null,
            moveCooldown: 0,
            random: null,
            colorTheme: 0,
            board: null,
            rookSquare: null,
            cannonSquare: null,
            previousMoveSquares: null,
            possibleMoveSquares: null,
            chessPiecesRendererFadeOutFadeIn: null
        },
        alias: [
            "ProcessFrame", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$ProcessFrame",
            "Render", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$Render"
        ],
        ctors: {
            ctor: function (colorTheme, random) {
                this.$initialize();
                this.chessPiecesRendererFadeOutFadeIn = null;

                this.colorTheme = colorTheme;

                this.random = random;

                this.moveCooldown = ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.ELAPSED_MICROS_BEFORE_PIECE_MOVES;

                this.PopulateInitialBoard(random);

                this.chessPiecesRenderer = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetChessPiecesRenderer(this.board, null, this.previousMoveSquares, true, colorTheme);

                this.chessPiecesRendererPieceAnimation = ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.EmptyChessPiecesRendererPieceAnimation();
            }
        },
        methods: {
            PopulateInitialBoard: function (random) {
                var $t, $t1, $t2, $t3, $t4, $t5;
                var boardArray = System.Array.init(8, null, System.Array.type(ChessCompStompWithHacksEngine.ChessSquarePiece));
                for (var i = 0; i < 8; i = (i + 1) | 0) {
                    boardArray[System.Array.index(i, boardArray)] = System.Array.init(8, 0, ChessCompStompWithHacksEngine.ChessSquarePiece);
                    for (var j = 0; j < 8; j = (j + 1) | 0) {
                        ($t = boardArray[System.Array.index(i, boardArray)])[System.Array.index(j, $t)] = ChessCompStompWithHacksEngine.ChessSquarePiece.Empty;
                    }
                }

                var rookFile = random.DTLibrary$IDTRandom$NextInt(8);
                var rookRank = random.DTLibrary$IDTRandom$NextInt(8);

                this.rookSquare = new ChessCompStompWithHacksEngine.ChessSquare(rookFile, rookRank);

                var list = new (System.Collections.Generic.List$1(System.Tuple$2(System.Int32,System.Int32))).ctor();
                list.add({ Item1: 1, Item2: 0 });
                list.add({ Item1: -1, Item2: 0 });
                list.add({ Item1: 0, Item2: 1 });
                list.add({ Item1: 0, Item2: -1 });
                DTLibrary.ListUtil.Shuffle(System.Tuple$2(System.Int32,System.Int32), list, random);

                var hasSetupCannon = false;

                $t1 = Bridge.getEnumerator(list);
                try {
                    while ($t1.moveNext()) {
                        var tuple = $t1.Current;
                        var i1 = rookFile;
                        var j1 = rookRank;

                        var length = 0;

                        while (true) {
                            i1 = (i1 + tuple.Item1) | 0;
                            j1 = (j1 + tuple.Item2) | 0;

                            if (0 <= i1 && i1 < 8 && 0 <= j1 && j1 < 8) {
                                length = (length + 1) | 0;
                            } else {
                                break;
                            }
                        }

                        if (length >= 4 && !hasSetupCannon) {
                            hasSetupCannon = true;

                            var x = (random.DTLibrary$IDTRandom$NextInt(((length - 3) | 0)) + 4) | 0;

                            this.cannonSquare = new ChessCompStompWithHacksEngine.ChessSquare(((rookFile + Bridge.Int.mul(x, tuple.Item1)) | 0), ((rookRank + Bridge.Int.mul(x, tuple.Item2)) | 0));
                            ($t2 = boardArray[System.Array.index(this.cannonSquare.File, boardArray)])[System.Array.index(this.cannonSquare.Rank, $t2)] = ChessCompStompWithHacksLibrary.HackExplanation_RooksCanCaptureLikeCannons.GetRandomEnemyPiece(random);

                            x = (random.DTLibrary$IDTRandom$NextInt(3) + 1) | 0;

                            ($t3 = boardArray[System.Array.index(((rookFile + Bridge.Int.mul(x, tuple.Item1)) | 0), boardArray)])[System.Array.index(((rookRank + Bridge.Int.mul(x, tuple.Item2)) | 0), $t3)] = random.DTLibrary$IDTRandom$NextBool() ? ChessCompStompWithHacksLibrary.HackExplanation_RooksCanCaptureLikeCannons.GetRandomPlayerPiece(random) : ChessCompStompWithHacksLibrary.HackExplanation_RooksCanCaptureLikeCannons.GetRandomEnemyPiece(random);
                        } else {
                            if (random.DTLibrary$IDTRandom$NextBool()) {
                                continue;
                            }

                            if (length === 0) {
                                continue;
                            }

                            var x1 = (random.DTLibrary$IDTRandom$NextInt(length) + 1) | 0;

                            ($t4 = boardArray[System.Array.index(((rookFile + Bridge.Int.mul(x1, tuple.Item1)) | 0), boardArray)])[System.Array.index(((rookRank + Bridge.Int.mul(x1, tuple.Item2)) | 0), $t4)] = random.DTLibrary$IDTRandom$NextBool() ? ChessCompStompWithHacksLibrary.HackExplanation_RooksCanCaptureLikeCannons.GetRandomPlayerPiece(random) : ChessCompStompWithHacksLibrary.HackExplanation_RooksCanCaptureLikeCannons.GetRandomEnemyPiece(random);
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                ($t5 = boardArray[System.Array.index(this.rookSquare.File, boardArray)])[System.Array.index(this.rookSquare.Rank, $t5)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook;

                this.board = new ChessCompStompWithHacksEngine.ChessSquarePieceArray.$ctor1(boardArray);

                this.previousMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();
                this.possibleMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();
            },
            ProcessFrame: function (mouseInput, previousMouseInput, displayProcessing, elapsedMicrosPerFrame) {
                if (this.chessPiecesRendererFadeOutFadeIn != null) {
                    this.chessPiecesRendererFadeOutFadeIn.ProcessFrame(elapsedMicrosPerFrame);

                    if (this.chessPiecesRendererFadeOutFadeIn.HasFinishedFadingOut() && this.previousMoveSquares.Count > 0) {
                        this.PopulateInitialBoard(this.random);
                    }

                    if (this.chessPiecesRendererFadeOutFadeIn.HasFinishedFadingIn()) {
                        this.chessPiecesRendererFadeOutFadeIn = null;
                    }
                } else {
                    this.moveCooldown = (this.moveCooldown - elapsedMicrosPerFrame) | 0;
                    if (this.moveCooldown <= 0) {
                        this.moveCooldown = (this.moveCooldown + ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.ELAPSED_MICROS_BEFORE_PIECE_MOVES) | 0;
                        if (this.moveCooldown <= 0) {
                            this.moveCooldown = 0;
                        }

                        if (this.previousMoveSquares.Count > 0) {
                            this.chessPiecesRendererFadeOutFadeIn = new ChessCompStompWithHacksLibrary.ChessPiecesRendererFadeOutFadeIn(this.colorTheme);
                        } else {
                            if (this.possibleMoveSquares.Count === 0) {
                                this.possibleMoveSquares = new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor2(ChessCompStompWithHacksLibrary.HackExplanation_RooksCanCaptureLikeCannons.GetPossibleMoveSquares(this.rookSquare, this.board));
                            } else {
                                this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.AddRawMove(this.rookSquare.File, this.rookSquare.Rank, this.cannonSquare.File, this.cannonSquare.Rank, ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook);

                                this.board = this.board.SetPiece(this.rookSquare.File, this.rookSquare.Rank, ChessCompStompWithHacksEngine.ChessSquarePiece.Empty);
                                this.board = this.board.SetPiece(this.cannonSquare.File, this.cannonSquare.Rank, ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook);

                                this.previousMoveSquares = new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor1(Bridge.fn.bind(this, function (_o1) {
                                        _o1.add(this.rookSquare);
                                        _o1.add(this.cannonSquare);
                                        return _o1;
                                    })(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor()));

                                this.possibleMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();
                            }
                        }
                    }
                }

                this.chessPiecesRenderer = this.chessPiecesRenderer.ProcessFrame(this.board, null, this.previousMoveSquares, this.possibleMoveSquares.Count > 0 ? this.rookSquare : null, this.possibleMoveSquares, null, null, null, elapsedMicrosPerFrame);

                this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.ProcessFrame(elapsedMicrosPerFrame);
            },
            Render: function (displayOutput, isMobileDisplayType) {
                var isMobilePortrait = isMobileDisplayType && !DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? 232 : 382, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, ChessCompStompWithHacksLibrary.HackUtil.GetHackNameForHackExplanationPanel(ChessCompStompWithHacksEngine.Hack.RooksCanCaptureLikeCannons), ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                var explanation;

                if (isMobilePortrait) {
                    explanation = "Your rooks may capture enemy pieces even if\nthere is a piece between your rook and the\npiece being captured.";
                } else {
                    explanation = "Your rooks may capture\nenemy pieces even if there is\na piece between your rook\nand the piece being captured.";
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, explanation, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, DTLibrary.DTColor.Black());

                this.chessPiecesRenderer.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE), this.chessPiecesRendererPieceAnimation, ChessCompStompWithHacksLibrary.GameImageUtil.HackExplanationChessPieceScalingFactor, isMobileDisplayType);

                if (this.chessPiecesRendererFadeOutFadeIn != null) {
                    this.chessPiecesRendererFadeOutFadeIn.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE), ChessCompStompWithHacksLibrary.GameImageUtil.HackExplanationChessPieceScalingFactor);
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackExplanation_RooksCanMoveLikeBishops", {
        inherits: [ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.IHackExplanation],
        statics: {
            methods: {
                GetPossibleBishopRookMoves: function (rookSquare) {
                    var $t;
                    var list = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor();

                    var i = rookSquare.File;
                    var j = rookSquare.Rank;

                    var deltas = new (System.Collections.Generic.List$1(System.Tuple$2(System.Int32,System.Int32))).ctor();
                    deltas.add({ Item1: 1, Item2: 1 });
                    deltas.add({ Item1: 1, Item2: -1 });
                    deltas.add({ Item1: -1, Item2: 1 });
                    deltas.add({ Item1: -1, Item2: -1 });

                    $t = Bridge.getEnumerator(deltas);
                    try {
                        while ($t.moveNext()) {
                            var delta = $t.Current;
                            var endI = i;
                            var endJ = j;
                            while (true) {
                                endI = (endI + delta.Item1) | 0;
                                endJ = (endJ + delta.Item2) | 0;
                                if (endI < 0 || endI >= 8 || endJ < 0 || endJ >= 8) {
                                    break;
                                }

                                list.add(new ChessCompStompWithHacksEngine.ChessSquare(endI, endJ));
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    return list;
                },
                GetPossibleNormalRookMoves: function (rookSquare) {
                    var $t;
                    var list = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor();

                    var i = rookSquare.File;
                    var j = rookSquare.Rank;

                    var deltas = new (System.Collections.Generic.List$1(System.Tuple$2(System.Int32,System.Int32))).ctor();
                    deltas.add({ Item1: 0, Item2: 1 });
                    deltas.add({ Item1: 0, Item2: -1 });
                    deltas.add({ Item1: 1, Item2: 0 });
                    deltas.add({ Item1: -1, Item2: 0 });

                    $t = Bridge.getEnumerator(deltas);
                    try {
                        while ($t.moveNext()) {
                            var delta = $t.Current;
                            var endI = i;
                            var endJ = j;
                            while (true) {
                                endI = (endI + delta.Item1) | 0;
                                endJ = (endJ + delta.Item2) | 0;
                                if (endI < 0 || endI >= 8 || endJ < 0 || endJ >= 8) {
                                    break;
                                }

                                list.add(new ChessCompStompWithHacksEngine.ChessSquare(endI, endJ));
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    return list;
                }
            }
        },
        fields: {
            chessPiecesRenderer: null,
            chessPiecesRendererPieceAnimation: null,
            rookSquare: null,
            potentialNormalRookMoves: null,
            potentialBishopRookMoves: null,
            previousMoveSquares: null,
            moveCooldown: 0,
            random: null,
            colorTheme: 0
        },
        alias: [
            "ProcessFrame", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$ProcessFrame",
            "Render", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$Render"
        ],
        ctors: {
            ctor: function (colorTheme, random) {
                this.$initialize();
                this.colorTheme = colorTheme;

                this.random = random;

                this.rookSquare = new ChessCompStompWithHacksEngine.ChessSquare(random.DTLibrary$IDTRandom$NextInt(8), random.DTLibrary$IDTRandom$NextInt(8));

                this.potentialNormalRookMoves = ChessCompStompWithHacksLibrary.HackExplanation_RooksCanMoveLikeBishops.GetPossibleNormalRookMoves(this.rookSquare);
                this.potentialBishopRookMoves = ChessCompStompWithHacksLibrary.HackExplanation_RooksCanMoveLikeBishops.GetPossibleBishopRookMoves(this.rookSquare);

                this.moveCooldown = ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.ELAPSED_MICROS_BEFORE_PIECE_MOVES;

                var board = ChessCompStompWithHacksEngine.ChessSquarePieceArray.EmptyBoard();
                board = board.SetPiece(this.rookSquare.File, this.rookSquare.Rank, ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook);

                this.previousMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();

                this.chessPiecesRenderer = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetChessPiecesRenderer(board, null, this.previousMoveSquares, true, colorTheme);

                this.chessPiecesRendererPieceAnimation = ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.EmptyChessPiecesRendererPieceAnimation();
            }
        },
        methods: {
            ProcessFrame: function (mouseInput, previousMouseInput, displayProcessing, elapsedMicrosPerFrame) {
                this.moveCooldown = (this.moveCooldown - elapsedMicrosPerFrame) | 0;
                if (this.moveCooldown <= 0) {
                    this.moveCooldown = (this.moveCooldown + ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.ELAPSED_MICROS_BEFORE_PIECE_MOVES) | 0;
                    if (this.moveCooldown <= 0) {
                        this.moveCooldown = 0;
                    }

                    var originalRookSquare = this.rookSquare;

                    if (this.random.DTLibrary$IDTRandom$NextInt(100) < 70) {
                        this.rookSquare = this.potentialBishopRookMoves.getItem(this.random.DTLibrary$IDTRandom$NextInt(this.potentialBishopRookMoves.Count));
                    } else {
                        this.rookSquare = this.potentialNormalRookMoves.getItem(this.random.DTLibrary$IDTRandom$NextInt(this.potentialNormalRookMoves.Count));
                    }

                    this.potentialNormalRookMoves = ChessCompStompWithHacksLibrary.HackExplanation_RooksCanMoveLikeBishops.GetPossibleNormalRookMoves(this.rookSquare);
                    this.potentialBishopRookMoves = ChessCompStompWithHacksLibrary.HackExplanation_RooksCanMoveLikeBishops.GetPossibleBishopRookMoves(this.rookSquare);

                    this.previousMoveSquares = new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor1(Bridge.fn.bind(this, function (_o1) {
                            _o1.add(originalRookSquare);
                            _o1.add(this.rookSquare);
                            return _o1;
                        })(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor()));

                    this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.AddRawMove(originalRookSquare.File, originalRookSquare.Rank, this.rookSquare.File, this.rookSquare.Rank, ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook);
                }

                var board = ChessCompStompWithHacksEngine.ChessSquarePieceArray.EmptyBoard();
                board = board.SetPiece(this.rookSquare.File, this.rookSquare.Rank, ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook);

                var allRookMoves = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor();
                allRookMoves.AddRange(this.potentialNormalRookMoves);
                allRookMoves.AddRange(this.potentialBishopRookMoves);

                this.chessPiecesRenderer = this.chessPiecesRenderer.ProcessFrame(board, null, this.previousMoveSquares, null, DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).AsImmutableList(allRookMoves), null, null, null, elapsedMicrosPerFrame);

                this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.ProcessFrame(elapsedMicrosPerFrame);
            },
            Render: function (displayOutput, isMobileDisplayType) {
                var isMobilePortrait = isMobileDisplayType && !DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? 199 : 349, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, ChessCompStompWithHacksLibrary.HackUtil.GetHackNameForHackExplanationPanel(ChessCompStompWithHacksEngine.Hack.RooksCanMoveLikeBishops), ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                var explanation;

                if (isMobilePortrait) {
                    explanation = "In addition to their normal moves, your rooks\nmay also move as if they were bishops.";
                } else {
                    explanation = "In addition to their normal\nmoves, your rooks may also\nmove as if they were bishops.";
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, explanation, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, DTLibrary.DTColor.Black());

                this.chessPiecesRenderer.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE), this.chessPiecesRendererPieceAnimation, ChessCompStompWithHacksLibrary.GameImageUtil.HackExplanationChessPieceScalingFactor, isMobileDisplayType);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackExplanation_StalemateIsVictory", {
        inherits: [ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.IHackExplanation],
        fields: {
            chessPiecesRenderer: null,
            chessPiecesRendererPieceAnimation: null,
            moveCooldown: 0,
            random: null,
            colorTheme: 0,
            gameState: null,
            playerMove1: null,
            opponentMove: null,
            playerMove2: null,
            status: 0,
            previousMoveSquares: null,
            possibleMoveSquares: null,
            kingInDangerSquareAfterPlayerMove1: null,
            chessPiecesRendererFadeOutFadeIn: null,
            lastRandomValue: null
        },
        alias: [
            "ProcessFrame", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$ProcessFrame",
            "Render", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$Render"
        ],
        ctors: {
            ctor: function (colorTheme, random) {
                this.$initialize();
                this.lastRandomValue = null;

                this.chessPiecesRendererFadeOutFadeIn = null;

                this.colorTheme = colorTheme;

                this.random = random;

                this.moveCooldown = 750000;

                this.PopulateInitialBoard(random);

                this.chessPiecesRenderer = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetChessPiecesRenderer(this.gameState.Board, null, this.previousMoveSquares, true, colorTheme);

                this.chessPiecesRendererPieceAnimation = ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.EmptyChessPiecesRendererPieceAnimation();
            }
        },
        methods: {
            PopulateInitialBoard: function (random) {
                var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15;
                if (this.lastRandomValue == null) {
                    this.lastRandomValue = random.DTLibrary$IDTRandom$NextInt(3);
                } else {
                    var possibleValues = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    if (System.Nullable.getValue(this.lastRandomValue) !== 0) {
                        possibleValues.add(0);
                    }
                    if (System.Nullable.getValue(this.lastRandomValue) !== 1) {
                        possibleValues.add(1);
                    }
                    if (System.Nullable.getValue(this.lastRandomValue) !== 2) {
                        possibleValues.add(2);
                    }

                    this.lastRandomValue = possibleValues.getItem(random.DTLibrary$IDTRandom$NextInt(possibleValues.Count));
                }

                var board = System.Array.init(8, null, System.Array.type(ChessCompStompWithHacksEngine.ChessSquarePiece));
                for (var i = 0; i < 8; i = (i + 1) | 0) {
                    board[System.Array.index(i, board)] = System.Array.init(8, 0, ChessCompStompWithHacksEngine.ChessSquarePiece);
                    for (var j = 0; j < 8; j = (j + 1) | 0) {
                        ($t = board[System.Array.index(i, board)])[System.Array.index(j, $t)] = ChessCompStompWithHacksEngine.ChessSquarePiece.Empty;
                    }
                }

                switch (System.Nullable.getValue(this.lastRandomValue)) {
                    case 0: 
                        ($t1 = board[System.Array.index(3, board)])[System.Array.index(1, $t1)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKing;
                        ($t2 = board[System.Array.index(4, board)])[System.Array.index(4, $t2)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteQueen;
                        ($t3 = board[System.Array.index(6, board)])[System.Array.index(7, $t3)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKing;
                        this.playerMove1 = ChessCompStompWithHacksEngine.Move.NormalMove(4, 4, 4, 6);
                        this.opponentMove = ChessCompStompWithHacksEngine.Move.NormalMove(6, 7, 7, 7);
                        this.playerMove2 = ChessCompStompWithHacksEngine.Move.NormalMove(4, 6, 5, 6);
                        this.kingInDangerSquareAfterPlayerMove1 = null;
                        break;
                    case 1: 
                        ($t4 = board[System.Array.index(0, board)])[System.Array.index(5, $t4)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKing;
                        ($t5 = board[System.Array.index(0, board)])[System.Array.index(7, $t5)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKing;
                        ($t6 = board[System.Array.index(1, board)])[System.Array.index(2, $t6)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackPawn;
                        ($t7 = board[System.Array.index(5, board)])[System.Array.index(1, $t7)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook;
                        ($t8 = board[System.Array.index(5, board)])[System.Array.index(3, $t8)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn;
                        this.playerMove1 = ChessCompStompWithHacksEngine.Move.NormalMove(5, 3, 5, 4);
                        this.opponentMove = ChessCompStompWithHacksEngine.Move.NormalMove(1, 2, 1, 1);
                        this.playerMove2 = ChessCompStompWithHacksEngine.Move.NormalMove(5, 1, 1, 1);
                        this.kingInDangerSquareAfterPlayerMove1 = null;
                        break;
                    case 2: 
                        ($t9 = board[System.Array.index(0, board)])[System.Array.index(4, $t9)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook;
                        ($t10 = board[System.Array.index(1, board)])[System.Array.index(2, $t10)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook;
                        ($t11 = board[System.Array.index(2, board)])[System.Array.index(4, $t11)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteQueen;
                        ($t12 = board[System.Array.index(4, board)])[System.Array.index(5, $t12)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKing;
                        ($t13 = board[System.Array.index(6, board)])[System.Array.index(2, $t13)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackPawn;
                        ($t14 = board[System.Array.index(7, board)])[System.Array.index(1, $t14)] = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKing;
                        this.playerMove1 = ChessCompStompWithHacksEngine.Move.NormalMove(0, 4, 0, 1);
                        this.opponentMove = ChessCompStompWithHacksEngine.Move.NormalMove(6, 2, 6, 1);
                        this.playerMove2 = ChessCompStompWithHacksEngine.Move.NormalMove(2, 4, 2, 0);
                        this.kingInDangerSquareAfterPlayerMove1 = new ChessCompStompWithHacksEngine.ChessSquare(7, 1);
                        break;
                    default: 
                        throw new System.Exception();
                }

                var unmovedPawnsArray = System.Array.init(8, null, System.Array.type(System.Boolean));
                for (var i1 = 0; i1 < 8; i1 = (i1 + 1) | 0) {
                    unmovedPawnsArray[System.Array.index(i1, unmovedPawnsArray)] = System.Array.init(8, false, System.Boolean);
                    for (var j1 = 0; j1 < 8; j1 = (j1 + 1) | 0) {
                        ($t15 = unmovedPawnsArray[System.Array.index(i1, unmovedPawnsArray)])[System.Array.index(j1, $t15)] = false;
                    }
                }

                this.gameState = new ChessCompStompWithHacksEngine.GameState(new ChessCompStompWithHacksEngine.ChessSquarePieceArray.$ctor1(board), new ChessCompStompWithHacksEngine.UnmovedPawnsArray.$ctor1(unmovedPawnsArray), 101, false, true, true, null, null, new ChessCompStompWithHacksEngine.GameState.CastlingRights(false, false, false, false), new ChessCompStompWithHacksEngine.GameState.PlayerAbilities(false, false, false, false, false, false, false, false, false, true, false, false));

                this.previousMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();
                this.possibleMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();

                this.status = ChessCompStompWithHacksLibrary.HackExplanation_StalemateIsVictory.Status.PlayerAboutToClickFirstPiece;
            },
            ProcessFrame: function (mouseInput, previousMouseInput, displayProcessing, elapsedMicrosPerFrame) {
                if (this.chessPiecesRendererFadeOutFadeIn != null) {
                    this.chessPiecesRendererFadeOutFadeIn.ProcessFrame(elapsedMicrosPerFrame);

                    if (this.chessPiecesRendererFadeOutFadeIn.HasFinishedFadingOut() && this.status !== ChessCompStompWithHacksLibrary.HackExplanation_StalemateIsVictory.Status.PlayerAboutToClickFirstPiece) {
                        this.PopulateInitialBoard(this.random);
                    }

                    if (this.chessPiecesRendererFadeOutFadeIn.HasFinishedFadingIn()) {
                        this.chessPiecesRendererFadeOutFadeIn = null;
                    }
                } else {
                    this.moveCooldown = (this.moveCooldown - elapsedMicrosPerFrame) | 0;
                    if (this.moveCooldown <= 0) {
                        this.moveCooldown = (this.moveCooldown + (750000)) | 0;

                        if (this.status === ChessCompStompWithHacksLibrary.HackExplanation_StalemateIsVictory.Status.PlayerAboutToMakeSecondMove || this.status === ChessCompStompWithHacksLibrary.HackExplanation_StalemateIsVictory.Status.AboutToShowVictoryPanel) {
                            this.moveCooldown = (this.moveCooldown + (750000)) | 0;
                        }

                        if (this.moveCooldown <= 0) {
                            this.moveCooldown = 0;
                        }

                        switch (this.status) {
                            case ChessCompStompWithHacksLibrary.HackExplanation_StalemateIsVictory.Status.PlayerAboutToClickFirstPiece: 
                                this.status = ChessCompStompWithHacksLibrary.HackExplanation_StalemateIsVictory.Status.PlayerAboutToMakeFirstMove;
                                this.possibleMoveSquares = new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor2(System.Linq.Enumerable.from(ChessCompStompWithHacksEngine.ComputeMoves.GetMoves(this.gameState).Moves).where(Bridge.fn.bind(this, function (x) {
                                        return System.Nullable.hasValue(x.StartingFile) && System.Nullable.getValue(x.StartingFile) === System.Nullable.getValue(this.playerMove1.StartingFile) && System.Nullable.hasValue(x.StartingRank) && System.Nullable.getValue(x.StartingRank) === System.Nullable.getValue(this.playerMove1.StartingRank);
                                    })).select(function (x) {
                                    return new ChessCompStompWithHacksEngine.ChessSquare(x.EndingFile, x.EndingRank);
                                }).distinct().toList(ChessCompStompWithHacksEngine.ChessSquare));
                                break;
                            case ChessCompStompWithHacksLibrary.HackExplanation_StalemateIsVictory.Status.PlayerAboutToMakeFirstMove: 
                                this.status = ChessCompStompWithHacksLibrary.HackExplanation_StalemateIsVictory.Status.OpponentAboutToClickPiece;
                                this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.AddMove$1(this.gameState, this.playerMove1, false);
                                this.gameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(this.gameState, this.playerMove1);
                                this.possibleMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();
                                this.previousMoveSquares = new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor1(Bridge.fn.bind(this, function (_o1) {
                                        _o1.add(new ChessCompStompWithHacksEngine.ChessSquare(System.Nullable.getValue(this.playerMove1.StartingFile), System.Nullable.getValue(this.playerMove1.StartingRank)));
                                        _o1.add(new ChessCompStompWithHacksEngine.ChessSquare(this.playerMove1.EndingFile, this.playerMove1.EndingRank));
                                        return _o1;
                                    })(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor()));
                                break;
                            case ChessCompStompWithHacksLibrary.HackExplanation_StalemateIsVictory.Status.OpponentAboutToClickPiece: 
                                this.status = ChessCompStompWithHacksLibrary.HackExplanation_StalemateIsVictory.Status.OpponentAboutToMakeMove;
                                break;
                            case ChessCompStompWithHacksLibrary.HackExplanation_StalemateIsVictory.Status.OpponentAboutToMakeMove: 
                                this.status = ChessCompStompWithHacksLibrary.HackExplanation_StalemateIsVictory.Status.PlayerAboutToClickSecondPiece;
                                this.previousMoveSquares = new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor1(Bridge.fn.bind(this, function (_o2) {
                                        _o2.add(new ChessCompStompWithHacksEngine.ChessSquare(System.Nullable.getValue(this.opponentMove.StartingFile), System.Nullable.getValue(this.opponentMove.StartingRank)));
                                        _o2.add(new ChessCompStompWithHacksEngine.ChessSquare(this.opponentMove.EndingFile, this.opponentMove.EndingRank));
                                        return _o2;
                                    })(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor()));
                                this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.AddMove$1(this.gameState, this.opponentMove, false);
                                this.gameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(this.gameState, this.opponentMove);
                                break;
                            case ChessCompStompWithHacksLibrary.HackExplanation_StalemateIsVictory.Status.PlayerAboutToClickSecondPiece: 
                                this.status = ChessCompStompWithHacksLibrary.HackExplanation_StalemateIsVictory.Status.PlayerAboutToMakeSecondMove;
                                this.possibleMoveSquares = new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor2(System.Linq.Enumerable.from(ChessCompStompWithHacksEngine.ComputeMoves.GetMoves(this.gameState).Moves).where(Bridge.fn.bind(this, function (x) {
                                        return System.Nullable.hasValue(x.StartingFile) && System.Nullable.getValue(x.StartingFile) === System.Nullable.getValue(this.playerMove2.StartingFile) && System.Nullable.hasValue(x.StartingRank) && System.Nullable.getValue(x.StartingRank) === System.Nullable.getValue(this.playerMove2.StartingRank);
                                    })).select(function (x) {
                                    return new ChessCompStompWithHacksEngine.ChessSquare(x.EndingFile, x.EndingRank);
                                }).distinct().toList(ChessCompStompWithHacksEngine.ChessSquare));
                                break;
                            case ChessCompStompWithHacksLibrary.HackExplanation_StalemateIsVictory.Status.PlayerAboutToMakeSecondMove: 
                                this.status = ChessCompStompWithHacksLibrary.HackExplanation_StalemateIsVictory.Status.AboutToShowVictoryPanel;
                                this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.AddMove$1(this.gameState, this.playerMove2, false);
                                this.gameState = ChessCompStompWithHacksEngine.MoveImplementation.ApplyMove$1(this.gameState, this.playerMove2);
                                this.possibleMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();
                                this.previousMoveSquares = new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor1(Bridge.fn.bind(this, function (_o3) {
                                        _o3.add(new ChessCompStompWithHacksEngine.ChessSquare(System.Nullable.getValue(this.playerMove2.StartingFile), System.Nullable.getValue(this.playerMove2.StartingRank)));
                                        _o3.add(new ChessCompStompWithHacksEngine.ChessSquare(this.playerMove2.EndingFile, this.playerMove2.EndingRank));
                                        return _o3;
                                    })(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor()));
                                break;
                            case ChessCompStompWithHacksLibrary.HackExplanation_StalemateIsVictory.Status.AboutToShowVictoryPanel: 
                                this.status = ChessCompStompWithHacksLibrary.HackExplanation_StalemateIsVictory.Status.Finished;
                                break;
                            case ChessCompStompWithHacksLibrary.HackExplanation_StalemateIsVictory.Status.Finished: 
                                this.chessPiecesRendererFadeOutFadeIn = new ChessCompStompWithHacksLibrary.ChessPiecesRendererFadeOutFadeIn(this.colorTheme);
                                break;
                            default: 
                                throw new System.Exception();
                        }
                    }
                }

                this.chessPiecesRenderer = this.chessPiecesRenderer.ProcessFrame(this.gameState.Board, this.status === ChessCompStompWithHacksLibrary.HackExplanation_StalemateIsVictory.Status.OpponentAboutToClickPiece || this.status === ChessCompStompWithHacksLibrary.HackExplanation_StalemateIsVictory.Status.OpponentAboutToMakeMove ? this.kingInDangerSquareAfterPlayerMove1 : null, this.previousMoveSquares, this.status === ChessCompStompWithHacksLibrary.HackExplanation_StalemateIsVictory.Status.PlayerAboutToMakeFirstMove ? new ChessCompStompWithHacksEngine.ChessSquare(System.Nullable.getValue(this.playerMove1.StartingFile), System.Nullable.getValue(this.playerMove1.StartingRank)) : this.status === ChessCompStompWithHacksLibrary.HackExplanation_StalemateIsVictory.Status.PlayerAboutToMakeSecondMove ? new ChessCompStompWithHacksEngine.ChessSquare(System.Nullable.getValue(this.playerMove2.StartingFile), System.Nullable.getValue(this.playerMove2.StartingRank)) : null, this.possibleMoveSquares, null, null, null, elapsedMicrosPerFrame);

                this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.ProcessFrame(elapsedMicrosPerFrame);
            },
            Render: function (displayOutput, isMobileDisplayType) {
                var isMobilePortrait = isMobileDisplayType && !DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? 199 : 349, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, ChessCompStompWithHacksLibrary.HackUtil.GetHackNameForHackExplanationPanel(ChessCompStompWithHacksEngine.Hack.StalemateIsVictory), ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                var explanation;

                if (isMobilePortrait) {
                    explanation = "If it is your turn and you have no legal moves,\nyou win the game.\n\nIf it is your opponent's turn and your\nopponent has no legal moves, you win the\ngame.";
                } else {
                    explanation = "If it is your turn and you have\nno legal moves, you win the\ngame.\n\nIf it is your opponent's turn\nand your opponent has no\nlegal moves, you win the\ngame.";
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, explanation, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, DTLibrary.DTColor.Black());

                this.chessPiecesRenderer.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE), this.chessPiecesRendererPieceAnimation, ChessCompStompWithHacksLibrary.GameImageUtil.HackExplanationChessPieceScalingFactor, isMobileDisplayType);

                if (this.status === ChessCompStompWithHacksLibrary.HackExplanation_StalemateIsVictory.Status.Finished) {
                    var chessPiecesRendererXOffset = isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE;
                    var chessPiecesRendererYOffset = isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE;

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(((chessPiecesRendererXOffset + 99) | 0), ((chessPiecesRendererYOffset + 240) | 0), 299, 119, DTLibrary.DTColor.White(), true);

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(((chessPiecesRendererXOffset + 99) | 0), ((chessPiecesRendererYOffset + 240) | 0), 300, 120, DTLibrary.DTColor.Black(), false);

                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText((((((chessPiecesRendererXOffset + 99) | 0)) + 65) | 0), (((((chessPiecesRendererYOffset + 240) | 0)) + 85) | 0), "Victory!", ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt, DTLibrary.DTColor.Black());
                }

                if (this.chessPiecesRendererFadeOutFadeIn != null) {
                    this.chessPiecesRendererFadeOutFadeIn.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE), ChessCompStompWithHacksLibrary.GameImageUtil.HackExplanationChessPieceScalingFactor);
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackExplanation_SuperCastling", {
        inherits: [ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.IHackExplanation],
        statics: {
            methods: {
                GetPossibleMoveSquares: function (kingSquare, rookSquare) {
                    var $t;
                    var set = new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor();

                    set.add(new ChessCompStompWithHacksEngine.ChessSquare(((kingSquare.File - 1) | 0), ((kingSquare.Rank - 1) | 0)));
                    set.add(new ChessCompStompWithHacksEngine.ChessSquare(((kingSquare.File - 1) | 0), kingSquare.Rank));
                    set.add(new ChessCompStompWithHacksEngine.ChessSquare(((kingSquare.File - 1) | 0), ((kingSquare.Rank + 1) | 0)));
                    set.add(new ChessCompStompWithHacksEngine.ChessSquare(kingSquare.File, ((kingSquare.Rank - 1) | 0)));
                    set.add(new ChessCompStompWithHacksEngine.ChessSquare(kingSquare.File, ((kingSquare.Rank + 1) | 0)));
                    set.add(new ChessCompStompWithHacksEngine.ChessSquare(((kingSquare.File + 1) | 0), ((kingSquare.Rank - 1) | 0)));
                    set.add(new ChessCompStompWithHacksEngine.ChessSquare(((kingSquare.File + 1) | 0), kingSquare.Rank));
                    set.add(new ChessCompStompWithHacksEngine.ChessSquare(((kingSquare.File + 1) | 0), ((kingSquare.Rank + 1) | 0)));
                    set.add(rookSquare);

                    if (kingSquare.File === rookSquare.File) {
                        if (kingSquare.Rank < rookSquare.Rank) {
                            set.add(new ChessCompStompWithHacksEngine.ChessSquare(kingSquare.File, ((kingSquare.Rank + 2) | 0)));
                        } else {
                            set.add(new ChessCompStompWithHacksEngine.ChessSquare(kingSquare.File, ((kingSquare.Rank - 2) | 0)));
                        }
                    } else {
                        if (kingSquare.File < rookSquare.File) {
                            set.add(new ChessCompStompWithHacksEngine.ChessSquare(((kingSquare.File + 2) | 0), kingSquare.Rank));
                        } else {
                            set.add(new ChessCompStompWithHacksEngine.ChessSquare(((kingSquare.File - 2) | 0), kingSquare.Rank));
                        }
                    }

                    var list = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor();

                    $t = Bridge.getEnumerator(set);
                    try {
                        while ($t.moveNext()) {
                            var square = $t.Current;
                            if (0 <= square.File && square.File < 8 && 0 <= square.Rank && square.Rank < 8) {
                                list.add(square);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    return list;
                }
            }
        },
        fields: {
            chessPiecesRenderer: null,
            chessPiecesRendererPieceAnimation: null,
            moveCooldown: 0,
            random: null,
            colorTheme: 0,
            board: null,
            kingSquare: null,
            rookSquare: null,
            previousMoveSquares: null,
            possibleMoveSquares: null,
            chessPiecesRendererFadeOutFadeIn: null
        },
        alias: [
            "ProcessFrame", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$ProcessFrame",
            "Render", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$Render"
        ],
        ctors: {
            ctor: function (colorTheme, random) {
                this.$initialize();
                this.chessPiecesRendererFadeOutFadeIn = null;

                this.colorTheme = colorTheme;

                this.random = random;

                this.moveCooldown = ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.ELAPSED_MICROS_BEFORE_PIECE_MOVES;

                this.PopulateInitialBoard(random);

                this.chessPiecesRenderer = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetChessPiecesRenderer(this.board, null, this.previousMoveSquares, true, colorTheme);

                this.chessPiecesRendererPieceAnimation = ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.EmptyChessPiecesRendererPieceAnimation();
            }
        },
        methods: {
            PopulateInitialBoard: function (random) {
                var $t, $t1, $t2, $t3;
                var kingFile = random.DTLibrary$IDTRandom$NextInt(8);
                var kingRank = random.DTLibrary$IDTRandom$NextInt(8);

                this.kingSquare = new ChessCompStompWithHacksEngine.ChessSquare(kingFile, kingRank);

                var potentialRookSquares = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor();

                var list = new (System.Collections.Generic.List$1(System.Tuple$2(System.Int32,System.Int32))).ctor();
                list.add({ Item1: 1, Item2: 0 });
                list.add({ Item1: -1, Item2: 0 });
                list.add({ Item1: 0, Item2: 1 });
                list.add({ Item1: 0, Item2: -1 });

                $t = Bridge.getEnumerator(list);
                try {
                    while ($t.moveNext()) {
                        var tuple = $t.Current;
                        var i = kingFile;
                        var j = kingRank;

                        var kingEndI = (((i + tuple.Item1) | 0) + tuple.Item1) | 0;
                        var kingEndJ = (((j + tuple.Item2) | 0) + tuple.Item2) | 0;

                        if (kingEndI < 0 || kingEndI >= 8 || kingEndJ < 0 || kingEndJ >= 8) {
                            continue;
                        }

                        while (true) {
                            i = (i + tuple.Item1) | 0;
                            j = (j + tuple.Item2) | 0;

                            if (0 <= i && i < 8 && 0 <= j && j < 8) {
                                potentialRookSquares.add(new ChessCompStompWithHacksEngine.ChessSquare(i, j));
                            } else {
                                break;
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.rookSquare = potentialRookSquares.getItem(random.DTLibrary$IDTRandom$NextInt(potentialRookSquares.Count));

                var boardArray = System.Array.init(8, null, System.Array.type(ChessCompStompWithHacksEngine.ChessSquarePiece));
                for (var i1 = 0; i1 < 8; i1 = (i1 + 1) | 0) {
                    boardArray[System.Array.index(i1, boardArray)] = System.Array.init(8, 0, ChessCompStompWithHacksEngine.ChessSquarePiece);
                    for (var j1 = 0; j1 < 8; j1 = (j1 + 1) | 0) {
                        ($t1 = boardArray[System.Array.index(i1, boardArray)])[System.Array.index(j1, $t1)] = ChessCompStompWithHacksEngine.ChessSquarePiece.Empty;
                    }
                }

                ($t2 = boardArray[System.Array.index(this.kingSquare.File, boardArray)])[System.Array.index(this.kingSquare.Rank, $t2)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKing;
                ($t3 = boardArray[System.Array.index(this.rookSquare.File, boardArray)])[System.Array.index(this.rookSquare.Rank, $t3)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook;

                this.board = new ChessCompStompWithHacksEngine.ChessSquarePieceArray.$ctor1(boardArray);

                this.previousMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();
                this.possibleMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();
            },
            ProcessFrame: function (mouseInput, previousMouseInput, displayProcessing, elapsedMicrosPerFrame) {
                if (this.chessPiecesRendererFadeOutFadeIn != null) {
                    this.chessPiecesRendererFadeOutFadeIn.ProcessFrame(elapsedMicrosPerFrame);

                    if (this.chessPiecesRendererFadeOutFadeIn.HasFinishedFadingOut() && this.previousMoveSquares.Count > 0) {
                        this.PopulateInitialBoard(this.random);
                    }

                    if (this.chessPiecesRendererFadeOutFadeIn.HasFinishedFadingIn()) {
                        this.chessPiecesRendererFadeOutFadeIn = null;
                    }
                } else {
                    this.moveCooldown = (this.moveCooldown - elapsedMicrosPerFrame) | 0;
                    if (this.moveCooldown <= 0) {
                        this.moveCooldown = (this.moveCooldown + ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.ELAPSED_MICROS_BEFORE_PIECE_MOVES) | 0;
                        if (this.moveCooldown <= 0) {
                            this.moveCooldown = 0;
                        }

                        if (this.previousMoveSquares.Count > 0) {
                            this.chessPiecesRendererFadeOutFadeIn = new ChessCompStompWithHacksLibrary.ChessPiecesRendererFadeOutFadeIn(this.colorTheme);
                        } else {
                            if (this.possibleMoveSquares.Count === 0) {
                                this.possibleMoveSquares = new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor2(ChessCompStompWithHacksLibrary.HackExplanation_SuperCastling.GetPossibleMoveSquares(this.kingSquare, this.rookSquare));
                            } else {
                                var endingKingSquare;

                                if (this.kingSquare.File === this.rookSquare.File) {
                                    if (this.kingSquare.Rank < this.rookSquare.Rank) {
                                        endingKingSquare = new ChessCompStompWithHacksEngine.ChessSquare(this.kingSquare.File, ((this.kingSquare.Rank + 2) | 0));
                                    } else {
                                        endingKingSquare = new ChessCompStompWithHacksEngine.ChessSquare(this.kingSquare.File, ((this.kingSquare.Rank - 2) | 0));
                                    }
                                } else {
                                    if (this.kingSquare.File < this.rookSquare.File) {
                                        endingKingSquare = new ChessCompStompWithHacksEngine.ChessSquare(((this.kingSquare.File + 2) | 0), this.kingSquare.Rank);
                                    } else {
                                        endingKingSquare = new ChessCompStompWithHacksEngine.ChessSquare(((this.kingSquare.File - 2) | 0), this.kingSquare.Rank);
                                    }
                                }

                                var endingRookSquare = new ChessCompStompWithHacksEngine.ChessSquare(((Bridge.Int.div((((this.kingSquare.File + endingKingSquare.File) | 0)), 2)) | 0), ((Bridge.Int.div((((this.kingSquare.Rank + endingKingSquare.Rank) | 0)), 2)) | 0));

                                this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.AddRawMove(this.kingSquare.File, this.kingSquare.Rank, endingKingSquare.File, endingKingSquare.Rank, ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKing);

                                this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.AddRawMove(this.rookSquare.File, this.rookSquare.Rank, endingRookSquare.File, endingRookSquare.Rank, ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook);

                                this.board = this.board.SetPiece(this.kingSquare.File, this.kingSquare.Rank, ChessCompStompWithHacksEngine.ChessSquarePiece.Empty);
                                this.board = this.board.SetPiece(this.rookSquare.File, this.rookSquare.Rank, ChessCompStompWithHacksEngine.ChessSquarePiece.Empty);
                                this.board = this.board.SetPiece(endingKingSquare.File, endingKingSquare.Rank, ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteKing);
                                this.board = this.board.SetPiece(endingRookSquare.File, endingRookSquare.Rank, ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteRook);

                                var previousMoves = new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor();
                                previousMoves.add(this.kingSquare);
                                previousMoves.add(this.rookSquare);
                                previousMoves.add(endingKingSquare);
                                previousMoves.add(endingRookSquare);

                                this.previousMoveSquares = new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor1(previousMoves);

                                this.possibleMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();
                            }
                        }
                    }
                }

                this.chessPiecesRenderer = this.chessPiecesRenderer.ProcessFrame(this.board, null, this.previousMoveSquares, this.possibleMoveSquares.Count > 0 ? this.kingSquare : null, this.possibleMoveSquares, null, null, null, elapsedMicrosPerFrame);

                this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.ProcessFrame(elapsedMicrosPerFrame);
            },
            Render: function (displayOutput, isMobileDisplayType) {
                var isMobilePortrait = isMobileDisplayType && !DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? 201 : 351, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, ChessCompStompWithHacksLibrary.HackUtil.GetHackNameForHackExplanationPanel(ChessCompStompWithHacksEngine.Hack.SuperCastling), ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                var explanation;

                if (isMobilePortrait) {
                    explanation = "You may castle as long as there are no\npieces between your king and rook.\n\nSuper castling is allowed regardless of\nwhether the king or rook has previously\nmoved.\n\nYou cannot super castle out of, through, or\ninto check.\n\nSuper castling is allowed both horizontally\nand vertically.";
                } else {
                    explanation = "You may castle as long as\nthere are no pieces between\nyour king and rook.\n\nSuper castling is allowed\nregardless of whether the\nking or rook has previously\nmoved.\n\nYou cannot super castle out\nof, through, or into check.\n\nSuper castling is allowed\nboth horizontally and\nvertically.";
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, explanation, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, DTLibrary.DTColor.Black());

                this.chessPiecesRenderer.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE), this.chessPiecesRendererPieceAnimation, ChessCompStompWithHacksLibrary.GameImageUtil.HackExplanationChessPieceScalingFactor, isMobileDisplayType);

                if (this.chessPiecesRendererFadeOutFadeIn != null) {
                    this.chessPiecesRendererFadeOutFadeIn.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE), ChessCompStompWithHacksLibrary.GameImageUtil.HackExplanationChessPieceScalingFactor);
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackExplanation_SuperEnPassant", {
        inherits: [ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.IHackExplanation],
        statics: {
            methods: {
                GetPossibleMoveSquares: function (pawnSquare, opponentSquare) {
                    var list = new (System.Collections.Generic.List$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor();

                    list.add(new ChessCompStompWithHacksEngine.ChessSquare(opponentSquare.File, ((pawnSquare.Rank + 1) | 0)));
                    list.add(new ChessCompStompWithHacksEngine.ChessSquare(pawnSquare.File, ((pawnSquare.Rank + 1) | 0)));

                    if (pawnSquare.Rank === 1) {
                        list.add(new ChessCompStompWithHacksEngine.ChessSquare(pawnSquare.File, ((pawnSquare.Rank + 2) | 0)));
                    }

                    return list;
                }
            }
        },
        fields: {
            chessPiecesRenderer: null,
            chessPiecesRendererPieceAnimation: null,
            moveCooldown: 0,
            random: null,
            colorTheme: 0,
            board: null,
            pawnSquare: null,
            opponentSquare: null,
            previousMoveSquares: null,
            possibleMoveSquares: null,
            chessPiecesRendererFadeOutFadeIn: null
        },
        alias: [
            "ProcessFrame", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$ProcessFrame",
            "Render", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$Render"
        ],
        ctors: {
            ctor: function (colorTheme, random) {
                this.$initialize();
                this.chessPiecesRendererFadeOutFadeIn = null;

                this.colorTheme = colorTheme;

                this.random = random;

                this.moveCooldown = ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.ELAPSED_MICROS_BEFORE_PIECE_MOVES;

                this.PopulateInitialBoard(random);

                this.chessPiecesRenderer = ChessCompStompWithHacksLibrary.ChessPiecesRenderer.GetChessPiecesRenderer(this.board, null, this.previousMoveSquares, true, colorTheme);

                this.chessPiecesRendererPieceAnimation = ChessCompStompWithHacksLibrary.ChessPiecesRendererPieceAnimation.EmptyChessPiecesRendererPieceAnimation();
            }
        },
        methods: {
            PopulateInitialBoard: function (random) {
                var $t, $t1, $t2;
                var pawnFile = random.DTLibrary$IDTRandom$NextInt(8);
                var pawnRank = (random.DTLibrary$IDTRandom$NextInt(6) + 1) | 0;

                this.pawnSquare = new ChessCompStompWithHacksEngine.ChessSquare(pawnFile, pawnRank);

                var opponentFile;

                if (pawnFile === 0) {
                    opponentFile = 1;
                } else {
                    if (pawnFile === 7) {
                        opponentFile = 6;
                    } else {
                        opponentFile = random.DTLibrary$IDTRandom$NextBool() ? (((pawnFile - 1) | 0)) : (((pawnFile + 1) | 0));
                    }
                }

                this.opponentSquare = new ChessCompStompWithHacksEngine.ChessSquare(opponentFile, pawnRank);

                var boardArray = System.Array.init(8, null, System.Array.type(ChessCompStompWithHacksEngine.ChessSquarePiece));
                for (var i = 0; i < 8; i = (i + 1) | 0) {
                    boardArray[System.Array.index(i, boardArray)] = System.Array.init(8, 0, ChessCompStompWithHacksEngine.ChessSquarePiece);
                    for (var j = 0; j < 8; j = (j + 1) | 0) {
                        ($t = boardArray[System.Array.index(i, boardArray)])[System.Array.index(j, $t)] = ChessCompStompWithHacksEngine.ChessSquarePiece.Empty;
                    }
                }

                ($t1 = boardArray[System.Array.index(this.pawnSquare.File, boardArray)])[System.Array.index(this.pawnSquare.Rank, $t1)] = ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn;

                var opponentPiece = new ChessCompStompWithHacksEngine.ChessSquarePiece();

                switch (random.DTLibrary$IDTRandom$NextInt(5)) {
                    case 0: 
                        opponentPiece = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackPawn;
                        break;
                    case 1: 
                        opponentPiece = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackRook;
                        break;
                    case 2: 
                        opponentPiece = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackKnight;
                        break;
                    case 3: 
                        opponentPiece = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackBishop;
                        break;
                    case 4: 
                        opponentPiece = ChessCompStompWithHacksEngine.ChessSquarePiece.BlackQueen;
                        break;
                    default: 
                        throw new System.Exception();
                }

                ($t2 = boardArray[System.Array.index(this.opponentSquare.File, boardArray)])[System.Array.index(this.opponentSquare.Rank, $t2)] = opponentPiece;

                this.board = new ChessCompStompWithHacksEngine.ChessSquarePieceArray.$ctor1(boardArray);

                this.previousMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();
                this.possibleMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();
            },
            ProcessFrame: function (mouseInput, previousMouseInput, displayProcessing, elapsedMicrosPerFrame) {
                if (this.chessPiecesRendererFadeOutFadeIn != null) {
                    this.chessPiecesRendererFadeOutFadeIn.ProcessFrame(elapsedMicrosPerFrame);

                    if (this.chessPiecesRendererFadeOutFadeIn.HasFinishedFadingOut() && this.previousMoveSquares.Count > 0) {
                        this.PopulateInitialBoard(this.random);
                    }

                    if (this.chessPiecesRendererFadeOutFadeIn.HasFinishedFadingIn()) {
                        this.chessPiecesRendererFadeOutFadeIn = null;
                    }
                } else {
                    this.moveCooldown = (this.moveCooldown - elapsedMicrosPerFrame) | 0;
                    if (this.moveCooldown <= 0) {
                        this.moveCooldown = (this.moveCooldown + ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.ELAPSED_MICROS_BEFORE_PIECE_MOVES) | 0;
                        if (this.moveCooldown <= 0) {
                            this.moveCooldown = 0;
                        }

                        if (this.previousMoveSquares.Count > 0) {
                            this.chessPiecesRendererFadeOutFadeIn = new ChessCompStompWithHacksLibrary.ChessPiecesRendererFadeOutFadeIn(this.colorTheme);
                        } else {
                            if (this.possibleMoveSquares.Count === 0) {
                                this.possibleMoveSquares = new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor2(ChessCompStompWithHacksLibrary.HackExplanation_SuperEnPassant.GetPossibleMoveSquares(this.pawnSquare, this.opponentSquare));
                            } else {
                                var endingSquare = new ChessCompStompWithHacksEngine.ChessSquare(this.opponentSquare.File, ((this.pawnSquare.Rank + 1) | 0));

                                this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.AddRawMove(this.pawnSquare.File, this.pawnSquare.Rank, endingSquare.File, endingSquare.Rank, ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn);

                                this.board = this.board.SetPiece(this.pawnSquare.File, this.pawnSquare.Rank, ChessCompStompWithHacksEngine.ChessSquarePiece.Empty);
                                this.board = this.board.SetPiece(this.opponentSquare.File, this.opponentSquare.Rank, ChessCompStompWithHacksEngine.ChessSquarePiece.Empty);
                                this.board = this.board.SetPiece(endingSquare.File, endingSquare.Rank, endingSquare.Rank === 7 ? ChessCompStompWithHacksEngine.ChessSquarePiece.WhiteQueen : ChessCompStompWithHacksEngine.ChessSquarePiece.WhitePawn);

                                this.previousMoveSquares = new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare)).$ctor1(Bridge.fn.bind(this, function (_o1) {
                                        _o1.add(this.pawnSquare);
                                        _o1.add(endingSquare);
                                        return _o1;
                                    })(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.ChessSquare)).ctor()));
                                this.possibleMoveSquares = DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.ChessSquare).EmptyList();
                            }
                        }
                    }
                }

                this.chessPiecesRenderer = this.chessPiecesRenderer.ProcessFrame(this.board, null, this.previousMoveSquares, this.possibleMoveSquares.Count > 0 ? this.pawnSquare : null, this.possibleMoveSquares, null, null, null, elapsedMicrosPerFrame);

                this.chessPiecesRendererPieceAnimation = this.chessPiecesRendererPieceAnimation.ProcessFrame(elapsedMicrosPerFrame);
            },
            Render: function (displayOutput, isMobileDisplayType) {
                var isMobilePortrait = isMobileDisplayType && !DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? 183 : 333, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, ChessCompStompWithHacksLibrary.HackUtil.GetHackNameForHackExplanationPanel(ChessCompStompWithHacksEngine.Hack.SuperEnPassant), ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                var explanation;

                if (isMobilePortrait) {
                    explanation = "Your pawns may capture enemy pieces that\nare horizontally adjacent to the pawn.\n\nSuper en passant is allowed regardless of\nwhen or how the enemy piece moved.\n\nThe pawn may capture super en passant\nregardless of which rank the pawn is on.";
                } else {
                    explanation = "Your pawns may capture\nenemy pieces that are\nhorizontally adjacent to the\npawn.\n\nSuper en passant is allowed\nregardless of when or how\nthe enemy piece moved.\n\nThe pawn may capture super\nen passant regardless of\nwhich rank the pawn is on.";
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, explanation, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, DTLibrary.DTColor.Black());

                this.chessPiecesRenderer.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE), this.chessPiecesRendererPieceAnimation, ChessCompStompWithHacksLibrary.GameImageUtil.HackExplanationChessPieceScalingFactor, isMobileDisplayType);

                if (this.chessPiecesRendererFadeOutFadeIn != null) {
                    this.chessPiecesRendererFadeOutFadeIn.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.CHESS_PIECES_RENDERER_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE), ChessCompStompWithHacksLibrary.GameImageUtil.HackExplanationChessPieceScalingFactor);
                }
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackExplanation_TacticalNuke", {
        inherits: [ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.IHackExplanation],
        statics: {
            methods: {
                GetTurnCount: function () {
                    return 11;
                }
            }
        },
        fields: {
            nukeRenderer: null
        },
        alias: [
            "ProcessFrame", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$ProcessFrame",
            "Render", "ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$Render"
        ],
        ctors: {
            ctor: function (colorTheme, timer, elapsedMicrosPerFrame) {
                this.$initialize();
                this.nukeRenderer = ChessCompStompWithHacksLibrary.NukeRenderer.GetNukeRenderer(true, false, false, null, ChessCompStompWithHacksLibrary.HackExplanation_TacticalNuke.GetTurnCount(), timer, colorTheme, false);

                this.nukeRenderer = this.nukeRenderer.ProcessFrame(false, false, null, ChessCompStompWithHacksLibrary.HackExplanation_TacticalNuke.GetTurnCount(), elapsedMicrosPerFrame, new DTLibrary.EmptyMouse());
            }
        },
        methods: {
            ProcessFrame: function (mouseInput, previousMouseInput, displayProcessing, elapsedMicrosPerFrame) {
                this.nukeRenderer = this.nukeRenderer.ProcessFrame(false, false, null, ChessCompStompWithHacksLibrary.HackExplanation_TacticalNuke.GetTurnCount(), elapsedMicrosPerFrame, new DTLibrary.EmptyMouse());
            },
            Render: function (displayOutput, isMobileDisplayType) {
                var isMobilePortrait = isMobileDisplayType && !DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? 209 : 359, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.TITLE_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, ChessCompStompWithHacksLibrary.HackUtil.GetHackNameForHackExplanationPanel(ChessCompStompWithHacksEngine.Hack.TacticalNuke), ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                var explanation;

                if (isMobilePortrait) {
                    explanation = "You start each game with a nuke.\n\nThe nuke requires " + (DTLibrary.StringUtil.ToStringCultureInvariant(ChessCompStompWithHacksEngine.TacticalNukeUtil.NumberOfMovesPlayedBeforeNukeIsAvailable) || "") + " turns before it is" + "\n" + "operational." + "\n" + "\n" + "The nuke cannot target the opponent's king.";
                } else {
                    explanation = "You start each game with a\nnuke.\n\nThe nuke requires " + (DTLibrary.StringUtil.ToStringCultureInvariant(ChessCompStompWithHacksEngine.TacticalNukeUtil.NumberOfMovesPlayedBeforeNukeIsAvailable) || "") + " turns" + "\n" + "before it is operational." + "\n" + "\n" + "The nuke cannot target the" + "\n" + "opponent's king.";
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_X_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, isMobilePortrait ? ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_MOBILE_PORTRAIT : ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.EXPLANATION_TEXT_Y_OFFSET_DESKTOP_AND_MOBILE_LANDSCAPE, explanation, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, DTLibrary.DTColor.Black());

                this.nukeRenderer.Render(1100, 128, new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, isMobilePortrait ? 234 : 532, isMobilePortrait ? 340 : 40), isMobileDisplayType);
            }
        }
    });

    /** @namespace ChessCompStompWithHacksLibrary */

    /**
     * Compares two objectives in a consistent (though arbitrary) way
     *
     * @public
     * @class ChessCompStompWithHacksLibrary.ObjectiveUtil.ObjectiveComparer
     * @implements  System.Collections.Generic.IComparer$1
     */
    Bridge.define("ChessCompStompWithHacksLibrary.ObjectiveUtil.ObjectiveComparer", {
        inherits: [System.Collections.Generic.IComparer$1(ChessCompStompWithHacksEngine.Objective)],
        $kind: "nested class",
        statics: {
            methods: {
                GetOrderId: function (objective) {
                    switch (objective) {
                        case ChessCompStompWithHacksEngine.Objective.DefeatComputer: 
                            return 1;
                        case ChessCompStompWithHacksEngine.Objective.DefeatComputerByPlayingAtMost25Moves: 
                            return 2;
                        case ChessCompStompWithHacksEngine.Objective.DefeatComputerWith5QueensOnTheBoard: 
                            return 3;
                        case ChessCompStompWithHacksEngine.Objective.CheckmateUsingAKnight: 
                            return 4;
                        case ChessCompStompWithHacksEngine.Objective.PromoteAPieceToABishop: 
                            return 5;
                        case ChessCompStompWithHacksEngine.Objective.LaunchANuke: 
                            return 6;
                        case ChessCompStompWithHacksEngine.Objective.WinFinalBattle: 
                            return 7;
                        case ChessCompStompWithHacksEngine.Objective.PlayAStupidOpening: 
                            return 8;
                        case ChessCompStompWithHacksEngine.Objective.NukeYourOwnPieces: 
                            return 9;
                        case ChessCompStompWithHacksEngine.Objective.WinByCastlingVeryLongAndPromotingRookToQueen: 
                            return 10;
                        default: 
                            throw new System.Exception();
                    }
                }
            }
        },
        alias: ["compare", ["System$Collections$Generic$IComparer$1$ChessCompStompWithHacksEngine$Objective$compare", "System$Collections$Generic$IComparer$1$compare"]],
        methods: {
            compare: function (x, y) {
                var xOrderId = ChessCompStompWithHacksLibrary.ObjectiveUtil.ObjectiveComparer.GetOrderId(x);
                var yOrderId = ChessCompStompWithHacksLibrary.ObjectiveUtil.ObjectiveComparer.GetOrderId(y);

                if (xOrderId < yOrderId) {
                    return -1;
                }
                if (xOrderId > yOrderId) {
                    return 1;
                }
                return 0;
            }
        }
    });

    Bridge.define("DTLibrary.ConsoleLogger", {
        inherits: [DTLibrary.IDTLogger],
        alias: [
            "Write", "DTLibrary$IDTLogger$Write",
            "WriteLine$1", "DTLibrary$IDTLogger$WriteLine$1",
            "WriteLine", "DTLibrary$IDTLogger$WriteLine"
        ],
        methods: {
            Write: function (str) {
                System.Console.Write(str);
            },
            WriteLine$1: function (str) {
                System.Console.WriteLine(str);
            },
            WriteLine: function () {
                System.Console.WriteLine();
            }
        }
    });

    /**
     * CopiedKeyboard is just an easy way to make a deep copy
     of an IKeyboard object.  Its constructor takes an IKeyboard
     object in order to create a copy of the keyboard.
     In general, making a copy of the IKeyboard object can
     be useful, since this copy is immutable and is guaranteed
     not to change.
     *
     * @public
     * @class DTLibrary.CopiedKeyboard
     * @implements  DTLibrary.IKeyboard
     */
    Bridge.define("DTLibrary.CopiedKeyboard", {
        inherits: [DTLibrary.IKeyboard],
        fields: {
            mapping: null
        },
        alias: ["IsPressed", "DTLibrary$IKeyboard$IsPressed"],
        ctors: {
            ctor: function (keyboard) {
                var $t;
                this.$initialize();
                this.mapping = new (System.Collections.Generic.Dictionary$2(DTLibrary.Key,System.Boolean))();
                $t = Bridge.getEnumerator(System.Enum.getValues(DTLibrary.Key));
                try {
                    while ($t.moveNext()) {
                        var key = Bridge.cast($t.Current, DTLibrary.Key);
                        this.mapping.set(key, keyboard.DTLibrary$IKeyboard$IsPressed(key));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            }
        },
        methods: {
            IsPressed: function (key) {
                return this.mapping.get(key);
            }
        }
    });

    /**
     * CopiedMouse is just an easy way to make a deep copy
     of an IMouse object.  Its constructor takes an IMouse
     object in order to create a copy of the mouse.
     In general, making a copy of the IMouse object can
     be useful, since this copy is immutable and is guaranteed
     not to change.
     *
     * @public
     * @class DTLibrary.CopiedMouse
     * @implements  DTLibrary.IMouse
     */
    Bridge.define("DTLibrary.CopiedMouse", {
        inherits: [DTLibrary.IMouse],
        fields: {
            x: 0,
            y: 0,
            leftMouse: false,
            rightMouse: false
        },
        alias: [
            "GetX", "DTLibrary$IMouse$GetX",
            "GetY", "DTLibrary$IMouse$GetY",
            "IsLeftMouseButtonPressed", "DTLibrary$IMouse$IsLeftMouseButtonPressed",
            "IsRightMouseButtonPressed", "DTLibrary$IMouse$IsRightMouseButtonPressed"
        ],
        ctors: {
            ctor: function (mouse) {
                this.$initialize();
                this.x = mouse.DTLibrary$IMouse$GetX();
                this.y = mouse.DTLibrary$IMouse$GetY();
                this.leftMouse = mouse.DTLibrary$IMouse$IsLeftMouseButtonPressed();
                this.rightMouse = mouse.DTLibrary$IMouse$IsRightMouseButtonPressed();
            }
        },
        methods: {
            GetX: function () {
                return this.x;
            },
            GetY: function () {
                return this.y;
            },
            IsLeftMouseButtonPressed: function () {
                return this.leftMouse;
            },
            IsRightMouseButtonPressed: function () {
                return this.rightMouse;
            }
        }
    });

    Bridge.define("DTLibrary.DisplayLogger", {
        inherits: [DTLibrary.IDTLogger],
        statics: {
            fields: {
                NUMBER_OF_LINES_TO_LOG: 0
            },
            ctors: {
                init: function () {
                    this.NUMBER_OF_LINES_TO_LOG = 5;
                }
            }
        },
        fields: {
            lines: null,
            x: 0,
            y: 0
        },
        alias: [
            "Write", "DTLibrary$IDTLogger$Write",
            "WriteLine$1", "DTLibrary$IDTLogger$WriteLine$1",
            "WriteLine", "DTLibrary$IDTLogger$WriteLine"
        ],
        ctors: {
            ctor: function (x, y) {
                this.$initialize();
                this.x = x;
                this.y = y;
                this.lines = System.Array.init(6, null, System.String);
                for (var i = 0; i < this.lines.length; i = (i + 1) | 0) {
                    this.lines[System.Array.index(i, this.lines)] = "";
                }
            }
        },
        methods: {
            Render: function (ImageEnum, FontEnum, displayOutput, font, color) {
                var text = "";

                if (this.lines[System.Array.index(((this.lines.length - 1) | 0), this.lines)].length > 0) {
                    for (var i = 1; i < this.lines.length; i = (i + 1) | 0) {
                        text = (text || "") + (this.lines[System.Array.index(i, this.lines)] || "") + "\n";
                    }
                } else {
                    for (var i1 = 0; i1 < ((this.lines.length - 1) | 0); i1 = (i1 + 1) | 0) {
                        text = (text || "") + (this.lines[System.Array.index(i1, this.lines)] || "") + "\n";
                    }
                }

                displayOutput["DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$TryDrawText"](this.x, this.y, text, font, color);
            },
            Write: function (str) {
                while (true) {
                    var index = System.String.indexOf(str, String.fromCharCode(10));

                    if (index < 0) {
                        this.lines[System.Array.index(((this.lines.length - 1) | 0), this.lines)] = (this.lines[System.Array.index(((this.lines.length - 1) | 0), this.lines)] || "") + (str || "");
                        break;
                    }

                    var line = str.substr(0, index);
                    this.lines[System.Array.index(((this.lines.length - 1) | 0), this.lines)] = (this.lines[System.Array.index(((this.lines.length - 1) | 0), this.lines)] || "") + (line || "");

                    for (var i = 1; i < this.lines.length; i = (i + 1) | 0) {
                        this.lines[System.Array.index(((i - 1) | 0), this.lines)] = this.lines[System.Array.index(i, this.lines)];
                    }
                    this.lines[System.Array.index(((this.lines.length - 1) | 0), this.lines)] = "";

                    str = str.substr(((index + 1) | 0));
                }
            },
            WriteLine$1: function (str) {
                this.Write((str || "") + "\n");
            },
            WriteLine: function () {
                this.Write("\n");
            }
        }
    });

    /**
     * An interface that marks an implementation of IDTRandom as completely deterministic.
     Deterministic is defined to mean that the implementation will always
     return the same values given the same seed and sequence of function calls.
     This means that an instance of IDTDeterministicRandom must behave identically
     across a variety of dimensions.
     For instance:
     * Two instances on different computers (with the same seed and function calls)
       must return the same values.
     * Two instances being executed at different times (with the same seed and function calls)
       must return the same values.
     * Two instances being executed on different versions of C# (with the same seed and function calls)
       must return the same values.
     * Two instances being executed on different operating systems (with the same seed and function calls)
       must return the same values.
     *
     * @abstract
     * @public
     * @class DTLibrary.IDTDeterministicRandom
     * @implements  DTLibrary.IDTRandom
     */
    Bridge.define("DTLibrary.IDTDeterministicRandom", {
        inherits: [DTLibrary.IDTRandom],
        $kind: "interface"
    });

    /**
     * An implementation of IDTRandom that simply
     uses the System.Random class.
     *
     * @public
     * @class DTLibrary.DTRandom
     * @implements  DTLibrary.IDTRandom
     */
    Bridge.define("DTLibrary.DTRandom", {
        inherits: [DTLibrary.IDTRandom],
        fields: {
            random: null
        },
        alias: [
            "AddSeed", "DTLibrary$IDTRandom$AddSeed",
            "NextInt", "DTLibrary$IDTRandom$NextInt",
            "NextBool", "DTLibrary$IDTRandom$NextBool"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                this.random = new System.Random.ctor();
            }
        },
        methods: {
            AddSeed: function (i) {
                this.random = new System.Random.$ctor1(i);
            },
            NextInt: function (i) {
                return this.random.Next$1(i);
            },
            NextBool: function () {
                return this.NextInt(2) === 1;
            }
        }
    });

    /**
     * An implementation of IKeyboard that simply represents
     no input (i.e. no keys are pressed).
     *
     * @public
     * @class DTLibrary.EmptyKeyboard
     * @implements  DTLibrary.IKeyboard
     */
    Bridge.define("DTLibrary.EmptyKeyboard", {
        inherits: [DTLibrary.IKeyboard],
        alias: ["IsPressed", "DTLibrary$IKeyboard$IsPressed"],
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            IsPressed: function (key) {
                return false;
            }
        }
    });

    Bridge.define("DTLibrary.EmptyLogger", {
        inherits: [DTLibrary.IDTLogger],
        alias: [
            "Write", "DTLibrary$IDTLogger$Write",
            "WriteLine$1", "DTLibrary$IDTLogger$WriteLine$1",
            "WriteLine", "DTLibrary$IDTLogger$WriteLine"
        ],
        methods: {
            Write: function (str) { },
            WriteLine$1: function (str) { },
            WriteLine: function () { }
        }
    });

    /**
     * An implementation of IMouse that simply represents
     no input.
     *
     * @public
     * @class DTLibrary.EmptyMouse
     * @implements  DTLibrary.IMouse
     */
    Bridge.define("DTLibrary.EmptyMouse", {
        inherits: [DTLibrary.IMouse],
        alias: [
            "GetX", "DTLibrary$IMouse$GetX",
            "GetY", "DTLibrary$IMouse$GetY",
            "IsLeftMouseButtonPressed", "DTLibrary$IMouse$IsLeftMouseButtonPressed",
            "IsRightMouseButtonPressed", "DTLibrary$IMouse$IsRightMouseButtonPressed"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            GetX: function () {
                return 0;
            },
            GetY: function () {
                return 0;
            },
            IsLeftMouseButtonPressed: function () {
                return false;
            },
            IsRightMouseButtonPressed: function () {
                return false;
            }
        }
    });

    Bridge.define("DTLibrary.EmptySoundOutput$1", function (SoundEnum) { return {
        inherits: [DTLibrary.ISoundOutput$1(SoundEnum)],
        fields: {
            soundVolume: 0
        },
        alias: [
            "LoadSounds", "DTLibrary$ISoundOutput$1$" + Bridge.getTypeAlias(SoundEnum) + "$LoadSounds",
            "GetNumElementsLoaded", "DTLibrary$ISoundOutput$1$" + Bridge.getTypeAlias(SoundEnum) + "$GetNumElementsLoaded",
            "GetNumTotalElementsToLoad", "DTLibrary$ISoundOutput$1$" + Bridge.getTypeAlias(SoundEnum) + "$GetNumTotalElementsToLoad",
            "SetSoundVolume", "DTLibrary$ISoundOutput$1$" + Bridge.getTypeAlias(SoundEnum) + "$SetSoundVolume",
            "SetSoundVolumeImmediately", "DTLibrary$ISoundOutput$1$" + Bridge.getTypeAlias(SoundEnum) + "$SetSoundVolumeImmediately",
            "GetSoundVolume", "DTLibrary$ISoundOutput$1$" + Bridge.getTypeAlias(SoundEnum) + "$GetSoundVolume",
            "PlaySound", "DTLibrary$ISoundOutput$1$" + Bridge.getTypeAlias(SoundEnum) + "$PlaySound",
            "ProcessFrame", "DTLibrary$ISoundOutput$1$" + Bridge.getTypeAlias(SoundEnum) + "$ProcessFrame",
            "DisposeSounds", "DTLibrary$ISoundOutput$1$" + Bridge.getTypeAlias(SoundEnum) + "$DisposeSounds"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                this.soundVolume = 100;
            }
        },
        methods: {
            LoadSounds: function () {
                return true;
            },
            GetNumElementsLoaded: function () {
                return 0;
            },
            GetNumTotalElementsToLoad: function () {
                return 0;
            },
            SetSoundVolume: function (volume) {
                this.soundVolume = volume;
            },
            SetSoundVolumeImmediately: function (volume) {
                this.soundVolume = volume;
            },
            GetSoundVolume: function () {
                return this.soundVolume;
            },
            PlaySound: function (sound) { },
            ProcessFrame: function () { },
            DisposeSounds: function () { }
        }
    }; });

    Bridge.define("DTLibrary.SimpleTimer", {
        inherits: [DTLibrary.ITimer],
        alias: ["GetNumberOfMicroSeconds", "DTLibrary$ITimer$GetNumberOfMicroSeconds"],
        methods: {
            GetNumberOfMicroSeconds: function () {
                return System.DateTime.getTicks(System.DateTime.getNow()).div(System.Int64(10));
            }
        }
    });

    Bridge.define("DTLibrary.SimulatedMouse", {
        inherits: [DTLibrary.IMouse],
        fields: {
            x: 0,
            y: 0,
            isLeftMouseButtonPressed: false,
            isRightMouseButtonPressed: false
        },
        alias: [
            "GetX", "DTLibrary$IMouse$GetX",
            "GetY", "DTLibrary$IMouse$GetY",
            "IsLeftMouseButtonPressed", "DTLibrary$IMouse$IsLeftMouseButtonPressed",
            "IsRightMouseButtonPressed", "DTLibrary$IMouse$IsRightMouseButtonPressed"
        ],
        ctors: {
            ctor: function (x, y, isLeftMouseButtonPressed, isRightMouseButtonPressed) {
                this.$initialize();
                this.x = x;
                this.y = y;
                this.isLeftMouseButtonPressed = isLeftMouseButtonPressed;
                this.isRightMouseButtonPressed = isRightMouseButtonPressed;
            }
        },
        methods: {
            GetX: function () {
                return this.x;
            },
            GetY: function () {
                return this.y;
            },
            IsLeftMouseButtonPressed: function () {
                return this.isLeftMouseButtonPressed;
            },
            IsRightMouseButtonPressed: function () {
                return this.isRightMouseButtonPressed;
            }
        }
    });

    Bridge.define("DTLibrary.TranslatedDisplayOutput$2", function (ImageEnum, FontEnum) { return {
        inherits: [DTLibrary.IDisplayOutput$2(ImageEnum,FontEnum)],
        fields: {
            display: null,
            xOffsetInPixels: 0,
            yOffsetInPixels: 0
        },
        alias: [
            "DrawRectangle", "DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$DrawRectangle",
            "DrawText", "DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$DrawText",
            "TryDrawText", "DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$TryDrawText",
            "DrawInitialLoadingScreen", "DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$DrawInitialLoadingScreen",
            "DrawImage", "DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$DrawImage",
            "DrawImageRotatedClockwise$2", "DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$DrawImageRotatedClockwise",
            "DrawImageRotatedClockwise$1", "DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$DrawImageRotatedClockwise$1",
            "DrawImageRotatedClockwise", "DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$DrawImageRotatedClockwise$2",
            "GetWidth", "DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$GetWidth",
            "GetHeight", "DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$GetHeight",
            "GetMobileScreenWidth", "DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$GetMobileScreenWidth",
            "GetMobileScreenHeight", "DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$GetMobileScreenHeight"
        ],
        ctors: {
            ctor: function (display, xOffsetInPixels, yOffsetInPixels) {
                this.$initialize();
                this.display = display;
                this.xOffsetInPixels = xOffsetInPixels;
                this.yOffsetInPixels = yOffsetInPixels;
            }
        },
        methods: {
            DrawRectangle: function (x, y, width, height, color, fill) {
                this.display["DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$DrawRectangle"](((x + this.xOffsetInPixels) | 0), ((y + this.yOffsetInPixels) | 0), width, height, color, fill);
            },
            DrawText: function (x, y, text, font, color) {
                this.display["DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$DrawText"](((x + this.xOffsetInPixels) | 0), ((y + this.yOffsetInPixels) | 0), text, font, color);
            },
            TryDrawText: function (x, y, text, font, color) {
                this.display["DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$TryDrawText"](((x + this.xOffsetInPixels) | 0), ((y + this.yOffsetInPixels) | 0), text, font, color);
            },
            DrawInitialLoadingScreen: function () {
                this.display["DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$DrawInitialLoadingScreen"]();
            },
            DrawImage: function (image, x, y) {
                this.DrawImageRotatedClockwise$1(image, x, y, 0, 128);
            },
            DrawImageRotatedClockwise$2: function (image, x, y, degreesScaled) {
                this.DrawImageRotatedClockwise$1(image, x, y, degreesScaled, 128);
            },
            DrawImageRotatedClockwise$1: function (image, x, y, degreesScaled, scalingFactorScaled) {
                this.display["DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$DrawImageRotatedClockwise$1"](image, ((x + this.xOffsetInPixels) | 0), ((y + this.yOffsetInPixels) | 0), degreesScaled, scalingFactorScaled);
            },
            DrawImageRotatedClockwise: function (image, imageX, imageY, imageWidth, imageHeight, x, y, degreesScaled, scalingFactorScaled) {
                this.display["DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$DrawImageRotatedClockwise$2"](image, imageX, imageY, imageWidth, imageHeight, ((x + this.xOffsetInPixels) | 0), ((y + this.yOffsetInPixels) | 0), degreesScaled, scalingFactorScaled);
            },
            GetWidth: function (image) {
                return this.display["DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$GetWidth"](image);
            },
            GetHeight: function (image) {
                return this.display["DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$GetHeight"](image);
            },
            GetMobileScreenWidth: function () {
                return this.display["DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$GetMobileScreenWidth"]();
            },
            GetMobileScreenHeight: function () {
                return this.display["DTLibrary$IDisplayOutput$2$" + Bridge.getTypeAlias(ImageEnum) + "$" + Bridge.getTypeAlias(FontEnum) + "$GetMobileScreenHeight"]();
            }
        }
    }; });

    /**
     * An implementation of IMouse that takes an existing IMouse object (in the constructor)
     and creates an IMouse implementation that's simply the same mouse input, but translated
     by some offset.
     *
     * @public
     * @class DTLibrary.TranslatedMouse
     * @implements  DTLibrary.IMouse
     */
    Bridge.define("DTLibrary.TranslatedMouse", {
        inherits: [DTLibrary.IMouse],
        fields: {
            x: 0,
            y: 0,
            pressedLeft: false,
            pressedRight: false
        },
        alias: [
            "GetX", "DTLibrary$IMouse$GetX",
            "GetY", "DTLibrary$IMouse$GetY",
            "IsLeftMouseButtonPressed", "DTLibrary$IMouse$IsLeftMouseButtonPressed",
            "IsRightMouseButtonPressed", "DTLibrary$IMouse$IsRightMouseButtonPressed"
        ],
        ctors: {
            ctor: function (mouse, xOffset, yOffset) {
                this.$initialize();
                this.x = (mouse.DTLibrary$IMouse$GetX() + xOffset) | 0;
                this.y = (mouse.DTLibrary$IMouse$GetY() + yOffset) | 0;
                this.pressedLeft = mouse.DTLibrary$IMouse$IsLeftMouseButtonPressed();
                this.pressedRight = mouse.DTLibrary$IMouse$IsRightMouseButtonPressed();
            }
        },
        methods: {
            GetX: function () {
                return this.x;
            },
            GetY: function () {
                return this.y;
            },
            IsLeftMouseButtonPressed: function () {
                return this.pressedLeft;
            },
            IsRightMouseButtonPressed: function () {
                return this.pressedRight;
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.GameFont", {
        $kind: "enum",
        statics: {
            fields: {
                GameFont12Pt: 0,
                GameFont14Pt: 1,
                GameFont16Pt: 2,
                GameFont18Pt: 3,
                GameFont20Pt: 4,
                GameFont32Pt: 5,
                GameFont48Pt: 6
            }
        }
    });

    Bridge.define("ChessCompStompWithHacks.BridgeMusic", {
        inherits: [DTLibrary.IMusic$1(ChessCompStompWithHacksLibrary.GameMusic)],
        fields: {
            currentGameMusic: null,
            currentVolume: 0,
            isMobileSafari: false
        },
        alias: [
            "LoadMusic", "DTLibrary$IMusicProcessing$LoadMusic",
            "GetNumElementsLoaded", "DTLibrary$IMusicProcessing$GetNumElementsLoaded",
            "GetNumTotalElementsToLoad", "DTLibrary$IMusicProcessing$GetNumTotalElementsToLoad",
            "PlayMusic", "DTLibrary$IMusicOutput$1$ChessCompStompWithHacksLibrary$GameMusic$PlayMusic",
            "StopMusic", "DTLibrary$IMusicOutput$1$ChessCompStompWithHacksLibrary$GameMusic$StopMusic",
            "DisposeMusic", "DTLibrary$IMusicCleanup$DisposeMusic"
        ],
        ctors: {
            ctor: function (stopWaitingEvenIfMusicHasNotLoaded) {
                this.$initialize();
                this.currentGameMusic = null;
                this.currentVolume = 0;
                this.isMobileSafari = ChessCompStompWithHacks.BridgeUtil.IsMobileSafari();

                if (this.isMobileSafari) {
                    eval("\r\n\t\t\t\t\twindow.BridgeMusicJavascript = ((function () {\r\n\t\t\t\t\t\t'use strict';\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tlet musicDictionary = {};\r\n\t\t\t\t\t\tlet bufferSource = null;\r\n\t\t\t\t\t\tlet currentlyPlayingMusic = null;\r\n\t\t\t\t\t\tlet gainNode = null;\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tlet numberOfAudioObjectsLoaded = 0;\r\n\t\t\t\t\t\tlet numberOfAudioObjects = null;\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tlet audioContext = new AudioContext();\r\n\r\n\t\t\t\t\t\tlet loadMusic = function (oggMusicNames, flacMusicNames) {\r\n\t\t\t\t\t\t\tlet oggMusicNamesArray = oggMusicNames.split(',');\r\n\t\t\t\t\t\t\tlet flacMusicNamesArray = flacMusicNames.split(',');\r\n\r\n\t\t\t\t\t\t\tnumberOfAudioObjects = oggMusicNamesArray.length;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tfor (let i = 0; i < oggMusicNamesArray.length; i++) {\r\n\t\t\t\t\t\t\t\tlet musicName = oggMusicNamesArray[i];\r\n\t\t\t\t\t\t\t\tlet flacMusicName = flacMusicNamesArray[i];\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tif (musicDictionary[musicName])\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t\t\tnumberOfAudioObjectsLoaded++;\r\n\t\t\t\t\t\t\t\tmusicDictionary[musicName] = { audioBuffer: null };\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tlet musicPath = 'Data/Music/' + flacMusicName + '?doNotCache=' + Date.now().toString();\r\n\r\n\t\t\t\t\t\t\t\tfetch(musicPath)\r\n\t\t\t\t\t\t\t\t\t.then(response => response.blob())\r\n\t\t\t\t\t\t\t\t\t.then(blob => blob.arrayBuffer())\r\n\t\t\t\t\t\t\t\t\t.then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))\r\n\t\t\t\t\t\t\t\t\t.then(audioBuffer => { musicDictionary[musicName].audioBuffer = audioBuffer; });\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\tlet getNumElementsLoaded = function () {\r\n\t\t\t\t\t\t\treturn numberOfAudioObjectsLoaded;\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tlet getNumTotalElementsToLoad = function () {\r\n\t\t\t\t\t\t\treturn numberOfAudioObjects;\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\tvar musicCounter = 0;\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tvar playMusic = function (musicName, volume) {\r\n\t\t\t\t\t\t\tmusicCounter++;\r\n\t\t\t\t\t\t\tvar currentMusicCounter = musicCounter;\r\n\t\t\t\t\t\t\tvar music = musicDictionary[musicName];\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif (volume > 1.0)\r\n\t\t\t\t\t\t\t\tvolume = 1.0;\r\n\t\t\t\t\t\t\tif (volume < 0.0)\r\n\t\t\t\t\t\t\t\tvolume = 0.0;\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif (music.audioBuffer === null) {\r\n\t\t\t\t\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\t\t\t\t\tif (currentMusicCounter === musicCounter)\r\n\t\t\t\t\t\t\t\t\t\tplayMusic(musicName, volume);\r\n\t\t\t\t\t\t\t\t}, 250);\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (audioContext.state === 'suspended') {\r\n\t\t\t\t\t\t\t\tcurrentlyPlayingMusic = null;\r\n\t\t\t\t\t\t\t\tif (bufferSource !== null)\r\n\t\t\t\t\t\t\t\t\tbufferSource.stop();\r\n\t\t\t\t\t\t\t\tbufferSource = null;\r\n\t\t\t\t\t\t\t\tgainNode = null;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\taudioContext.resume().then(() => {\r\n\t\t\t\t\t\t\t\tif (currentMusicCounter !== musicCounter)\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\t\t\tif (currentlyPlayingMusic === musicName) {\r\n\t\t\t\t\t\t\t\t\tgainNode.gain.setValueAtTime(volume, 0);\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tcurrentlyPlayingMusic = musicName;\r\n\t\t\t\t\t\t\t\tif (bufferSource !== null)\r\n\t\t\t\t\t\t\t\t\tbufferSource.stop();\r\n\t\t\t\t\t\t\t\tbufferSource = audioContext.createBufferSource();\r\n\t\t\t\t\t\t\t\tbufferSource.buffer = music.audioBuffer;\r\n\t\t\t\t\t\t\t\tbufferSource.loop = true;\r\n\t\t\t\t\t\t\t\tgainNode = new GainNode(audioContext, { gain: volume });\r\n\t\t\t\t\t\t\t\tbufferSource.connect(gainNode);\r\n\t\t\t\t\t\t\t\tgainNode.connect(audioContext.destination);\r\n\t\t\t\t\t\t\t\tbufferSource.start();\r\n\r\n\t\t\t\t\t\t\t\tif (audioContext.state === 'suspended') {\r\n\t\t\t\t\t\t\t\t\tcurrentlyPlayingMusic = null;\r\n\t\t\t\t\t\t\t\t\tif (bufferSource !== null)\r\n\t\t\t\t\t\t\t\t\t\tbufferSource.stop();\r\n\t\t\t\t\t\t\t\t\tbufferSource = null;\r\n\t\t\t\t\t\t\t\t\tgainNode = null;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tvar stopMusic = function () {\r\n\t\t\t\t\t\t\tmusicCounter++;\r\n\t\t\t\t\t\t\tcurrentlyPlayingMusic = null;\r\n\t\t\t\t\t\t\tif (bufferSource !== null)\r\n\t\t\t\t\t\t\t\tbufferSource.stop();\r\n\t\t\t\t\t\t\tbufferSource = null;\r\n\t\t\t\t\t\t\tgainNode = null;\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tloadMusic: loadMusic,\r\n\t\t\t\t\t\t\tgetNumElementsLoaded: getNumElementsLoaded,\r\n\t\t\t\t\t\t\tgetNumTotalElementsToLoad: getNumTotalElementsToLoad,\r\n\t\t\t\t\t\t\tplayMusic: playMusic,\r\n\t\t\t\t\t\t\tstopMusic: stopMusic\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t})());\r\n\t\t\t\t");
                } else {
                    eval("\r\n\t\t\t\t\twindow.BridgeMusicJavascript = ((function () {\r\n\t\t\t\t\t\t'use strict';\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tlet musicDictionary = {};\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tlet stopWaitingEvenIfMusicHasNotLoaded = " + ((stopWaitingEvenIfMusicHasNotLoaded ? "true" : "false") || "") + ";\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tlet numberOfAudioObjectsLoaded = 0;\r\n\t\t\t\t\t\tlet numberOfAudioObjects = null;\t\t\t\t\t\r\n\r\n\t\t\t\t\t\tlet stopWaiting = false;\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tif (stopWaitingEvenIfMusicHasNotLoaded)\r\n\t\t\t\t\t\t\tsetTimeout(function () { stopWaiting = true; }, 2000);\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tlet loadMusic = function (oggMusicNames, flacMusicNames) {\r\n\t\t\t\t\t\t\tlet oggMusicNamesArray = oggMusicNames.split(',');\r\n\t\t\t\t\t\t\tlet flacMusicNamesArray = flacMusicNames.split(',');\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tnumberOfAudioObjects = oggMusicNamesArray.length;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tfor (let i = 0; i < oggMusicNamesArray.length; i++) {\r\n\t\t\t\t\t\t\t\tlet musicName = oggMusicNamesArray[i];\r\n\t\t\t\t\t\t\t\tlet flacMusicName = flacMusicNamesArray[i];\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tif (musicDictionary[musicName])\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tlet musicPath = 'Data/Music/' + musicName + '?doNotCache=' + Date.now().toString();\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tlet hasAudioLoadingSucceeded = false;\r\n\t\t\t\t\t\t\t\tlet audio = new Audio();\r\n\t\t\t\t\t\t\t\taudio.addEventListener('canplaythrough', function () {\r\n\t\t\t\t\t\t\t\t\tif (!hasAudioLoadingSucceeded) {\r\n\t\t\t\t\t\t\t\t\t\tnumberOfAudioObjectsLoaded++;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\thasAudioLoadingSucceeded = true;\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\taudio.src = musicPath;\r\n\t\t\t\t\t\t\t\taudio.load();\r\n\t\t\t\t\t\t\t\taudio.loop = true;\r\n\r\n\t\t\t\t\t\t\t\tlet checkForError;\r\n\t\t\t\t\t\t\t\tcheckForError = function () {\r\n\t\t\t\t\t\t\t\t\tif (hasAudioLoadingSucceeded)\r\n\t\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t\tif (audio.error !== null) {\r\n\t\t\t\t\t\t\t\t\t\taudio.src = 'Data/Music/' + flacMusicName + '?doNotCache=' + Date.now().toString();\r\n\t\t\t\t\t\t\t\t\t\taudio.load();\r\n\t\t\t\t\t\t\t\t\t\taudio.loop = true;\r\n\t\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tsetTimeout(checkForError, 50 /* arbitrary */);\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\tsetTimeout(checkForError, 0);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tmusicDictionary[musicName] = audio;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif (stopWaiting)\r\n\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\treturn numberOfAudioObjects === numberOfAudioObjectsLoaded;\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\tlet getNumElementsLoaded = function () {\r\n\t\t\t\t\t\t\treturn numberOfAudioObjectsLoaded;\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\tlet getNumTotalElementsToLoad = function () {\r\n\t\t\t\t\t\t\treturn numberOfAudioObjects;\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tvar musicCounter = 0;\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tvar playMusic = function (musicName, volume) {\r\n\t\t\t\t\t\t\tmusicCounter++;\r\n\t\t\t\t\t\t\tvar currentMusicCounter = musicCounter;\r\n\t\t\t\t\t\t\tvar music = musicDictionary[musicName];\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif (volume > 1.0)\r\n\t\t\t\t\t\t\t\tvolume = 1.0;\r\n\t\t\t\t\t\t\tif (volume < 0.0)\r\n\t\t\t\t\t\t\t\tvolume = 0.0;\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tfor (var m in musicDictionary) {\r\n\t\t\t\t\t\t\t\tvar audio = musicDictionary[m];\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tif (audio === music) {\r\n\t\t\t\t\t\t\t\t\taudio.volume = volume;\r\n\t\t\t\t\t\t\t\t\tvar audioPromise = audio.play();\r\n\t\t\t\t\t\t\t\t\tif (audioPromise) {\r\n\t\t\t\t\t\t\t\t\t\taudioPromise.then(\r\n\t\t\t\t\t\t\t\t\t\t\tfunction () {},\r\n\t\t\t\t\t\t\t\t\t\t\tfunction () {\r\n\t\t\t\t\t\t\t\t\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (currentMusicCounter === musicCounter)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tplayMusic(musicName, volume);\r\n\t\t\t\t\t\t\t\t\t\t\t\t}, 50);\r\n\t\t\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\taudio.pause();\r\n\t\t\t\t\t\t\t\t\taudio.currentTime = 0;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tvar stopMusic = function () {\r\n\t\t\t\t\t\t\tmusicCounter++;\r\n\t\t\t\t\t\t\tfor (var musicName in musicDictionary) {\r\n\t\t\t\t\t\t\t\tvar audio = musicDictionary[musicName];\r\n\t\t\t\t\t\t\t\taudio.pause();\r\n\t\t\t\t\t\t\t\taudio.currentTime = 0;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tloadMusic: loadMusic,\r\n\t\t\t\t\t\t\tgetNumElementsLoaded: getNumElementsLoaded,\r\n\t\t\t\t\t\t\tgetNumTotalElementsToLoad: getNumTotalElementsToLoad,\r\n\t\t\t\t\t\t\tplayMusic: playMusic,\r\n\t\t\t\t\t\t\tstopMusic: stopMusic\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t})());\r\n\t\t\t\t");
                }
            }
        },
        methods: {
            LoadMusic: function () {
                var $t;
                var oggMusicNames = "";
                var flacMusicNames = "";
                var isFirst = true;
                $t = Bridge.getEnumerator(System.Enum.getValues(ChessCompStompWithHacksLibrary.GameMusic));
                try {
                    while ($t.moveNext()) {
                        var gameMusic = Bridge.cast($t.Current, ChessCompStompWithHacksLibrary.GameMusic);
                        if (isFirst) {
                            isFirst = false;
                        } else {
                            oggMusicNames = (oggMusicNames || "") + ",";
                            flacMusicNames = (flacMusicNames || "") + ",";
                        }
                        oggMusicNames = (oggMusicNames || "") + (ChessCompStompWithHacksLibrary.GameMusicUtil.GetMusicFilename(gameMusic).OggFilename || "");
                        flacMusicNames = (flacMusicNames || "") + (ChessCompStompWithHacksLibrary.GameMusicUtil.GetMusicFilename(gameMusic).FlacFilename || "");
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                if (Bridge.referenceEquals(oggMusicNames, "")) {
                    return true;
                }

                var result = eval("window.BridgeMusicJavascript.loadMusic('" + (oggMusicNames || "") + "', '" + (flacMusicNames || "") + "')");

                return result;
            },
            GetNumElementsLoaded: function () {
                return window.BridgeMusicJavascript.getNumElementsLoaded();
            },
            GetNumTotalElementsToLoad: function () {
                return window.BridgeMusicJavascript.getNumTotalElementsToLoad();
            },
            PlayMusic: function (music, volume) {
                if (System.Nullable.hasValue(this.currentGameMusic) && System.Nullable.getValue(this.currentGameMusic) === music && this.currentVolume === volume && !this.isMobileSafari) {
                    return;
                }

                this.currentGameMusic = music;
                this.currentVolume = volume;

                var finalVolume = (ChessCompStompWithHacksLibrary.GameMusicUtil.GetMusicVolume(music) / 100.0) * (volume / 100.0);
                if (finalVolume > 1.0) {
                    finalVolume = 1.0;
                }
                if (finalVolume < 0.0) {
                    finalVolume = 0.0;
                }

                window.BridgeMusicJavascript.playMusic(ChessCompStompWithHacksLibrary.GameMusicUtil.GetMusicFilename(music).OggFilename, finalVolume);
            },
            StopMusic: function () {
                if (this.currentGameMusic == null && !this.isMobileSafari) {
                    return;
                }

                this.currentGameMusic = null;

                window.BridgeMusicJavascript.stopMusic();
            },
            DisposeMusic: function () { }
        }
    });

    Bridge.define("ChessCompStompWithHacks.BridgeSoundOutput", {
        inherits: [DTLibrary.ISoundOutput$1(ChessCompStompWithHacksLibrary.GameSound)],
        fields: {
            desiredSoundVolume: 0,
            currentSoundVolume: 0,
            elapsedMicrosPerFrame: 0
        },
        alias: [
            "LoadSounds", "DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$LoadSounds",
            "GetNumElementsLoaded", "DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetNumElementsLoaded",
            "GetNumTotalElementsToLoad", "DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetNumTotalElementsToLoad",
            "SetSoundVolume", "DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$SetSoundVolume",
            "SetSoundVolumeImmediately", "DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$SetSoundVolumeImmediately",
            "GetSoundVolume", "DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume",
            "ProcessFrame", "DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$ProcessFrame",
            "PlaySound", "DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound",
            "DisposeSounds", "DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$DisposeSounds"
        ],
        ctors: {
            ctor: function (elapsedMicrosPerFrame) {
                this.$initialize();
                this.desiredSoundVolume = ChessCompStompWithHacksLibrary.GlobalState.DEFAULT_VOLUME;
                this.currentSoundVolume = this.desiredSoundVolume;
                this.elapsedMicrosPerFrame = elapsedMicrosPerFrame;

                if (ChessCompStompWithHacks.BridgeUtil.IsMobileSafari()) {
                    
					window.BridgeSoundOutputJavascript = ((function () {
						'use strict';

						let soundDictionary = {};
										
						let audioContext = new AudioContext();
					
						let numberOfAudioObjectsLoaded = 0;
						let numberOfAudioObjects = null;

						let loadSounds = function (oggSoundNames, flacSoundNames) {
							let oggSoundNamesArray = oggSoundNames.split(',');
							let flacSoundNamesArray = flacSoundNames.split(',');
						
							numberOfAudioObjects = oggSoundNamesArray.length;

							for (let i = 0; i < oggSoundNamesArray.length; i++) {
								let soundName = oggSoundNamesArray[i];
								let flacSoundName = flacSoundNamesArray[i];
							
								if (soundDictionary[soundName])
									continue;
							
								soundDictionary[soundName] = { audioBuffer: null };

								numberOfAudioObjectsLoaded++;
							
								let soundPath = 'Data/Sound/' + flacSoundName + '?doNotCache=' + Date.now().toString();

								fetch(soundPath)
									.then(response => response.blob())
									.then(blob => blob.arrayBuffer())
									.then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
									.then(audioBuffer => { soundDictionary[soundName].audioBuffer = audioBuffer; });
							}
						
							return true;
						};

						let getNumElementsLoaded = function () {
							return numberOfAudioObjectsLoaded;
						};

						let getNumTotalElementsToLoad = function () {
							return numberOfAudioObjects;
						};
					
						let playSound = function (soundName, volume) {
							if (volume > 1.0)
								volume = 1.0;
							if (volume < 0.0)
								volume = 0.0;
						
							if (volume <= 0.0)
								return;

							let audioBuffer = soundDictionary[soundName].audioBuffer;

							if (audioBuffer === null)
								return;

							let source = audioContext.createBufferSource();
							source.buffer = audioBuffer;
							let gainNode = new GainNode(audioContext, { gain: volume });
							source.connect(gainNode);
							gainNode.connect(audioContext.destination);
							source.start();
						};
					
						return {
							loadSounds: loadSounds,
							getNumElementsLoaded: getNumElementsLoaded,
							getNumTotalElementsToLoad: getNumTotalElementsToLoad,
							playSound: playSound
						};
					})());
				
                } else {
                    
					window.BridgeSoundOutputJavascript = ((function () {
						'use strict';

						let soundDictionary = {};
					
						let numberOfAudioObjectsLoaded = 0;
						let numberOfAudioObjects = null;
					
						let loadSounds = function (oggSoundNames, flacSoundNames) {
							let oggSoundNamesArray = oggSoundNames.split(',');
							let flacSoundNamesArray = flacSoundNames.split(',');
						
							numberOfAudioObjects = oggSoundNamesArray.length * 4;
						
							for (let i = 0; i < oggSoundNamesArray.length; i++) {
								let soundName = oggSoundNamesArray[i];
								let flacSoundName = flacSoundNamesArray[i];
							
								if (soundDictionary[soundName])
									continue;
							
								soundDictionary[soundName] = [];
							
								let soundPath = 'Data/Sound/' + soundName + '?doNotCache=' + Date.now().toString();
								for (let j = 0; j < 4; j++) {
									let hasAudioLoadingSucceeded = false;
									let audio = new Audio();
									audio.addEventListener('canplaythrough', function () {
										if (!hasAudioLoadingSucceeded) {
											numberOfAudioObjectsLoaded++;
										}

										hasAudioLoadingSucceeded = true;
									});

									audio.src = soundPath;
									audio.load();

									let checkForError;
									checkForError = function () {
										if (hasAudioLoadingSucceeded)
											return;
										if (audio.error !== null) {
											audio.src = 'Data/Sound/' + flacSoundName + '?doNotCache=' + Date.now().toString();
											audio.load();
											return;
										}

										setTimeout(checkForError, 50 /* arbitrary */);
									};
									setTimeout(checkForError, 0);

									soundDictionary[soundName].push(audio);
								}
							}
						
							return numberOfAudioObjects === numberOfAudioObjectsLoaded;
						};

						let getNumElementsLoaded = function () {
							return numberOfAudioObjectsLoaded;
						};

						let getNumTotalElementsToLoad = function () {
							return numberOfAudioObjects;
						};
					
						var playSound = function (soundName, volume) {
							var sound = soundDictionary[soundName];
						
							if (volume > 1.0)
								volume = 1.0;
							if (volume < 0.0)
								volume = 0.0;
						
							var audio = sound[0];
						
							for (var i = 0; i < sound.length; i++) {
								if (i === sound.length - 1)
									sound[i] = audio;
								else
									sound[i] = sound[i+1];
							}
						
							audio.volume = volume;
							audio.play();
						};
					
						return {
							loadSounds: loadSounds,
							getNumElementsLoaded: getNumElementsLoaded,
							getNumTotalElementsToLoad: getNumTotalElementsToLoad,
							playSound: playSound
						};
					})());
				
                }
            }
        },
        methods: {
            LoadSounds: function () {
                var $t;
                var oggSoundNames = "";
                var flacSoundNames = "";
                var isFirst = true;
                $t = Bridge.getEnumerator(System.Enum.getValues(ChessCompStompWithHacksLibrary.GameSound));
                try {
                    while ($t.moveNext()) {
                        var gameSound = Bridge.cast($t.Current, ChessCompStompWithHacksLibrary.GameSound);
                        if (isFirst) {
                            isFirst = false;
                        } else {
                            oggSoundNames = (oggSoundNames || "") + ",";
                            flacSoundNames = (flacSoundNames || "") + ",";
                        }

                        var oggSoundFilename = ChessCompStompWithHacksLibrary.GameSoundUtil.GetSoundFilename(gameSound).OggFilename;
                        oggSoundNames = (oggSoundNames || "") + (oggSoundFilename || "");

                        var flacSoundFilename = ChessCompStompWithHacksLibrary.GameSoundUtil.GetSoundFilename(gameSound).FlacFilename;
                        flacSoundNames = (flacSoundNames || "") + (flacSoundFilename || "");
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                if (Bridge.referenceEquals(oggSoundNames, "")) {
                    return true;
                }

                var result = eval("window.BridgeSoundOutputJavascript.loadSounds('" + (oggSoundNames || "") + "', '" + (flacSoundNames || "") + "')");

                return result;
            },
            GetNumElementsLoaded: function () {
                return window.BridgeSoundOutputJavascript.getNumElementsLoaded();
            },
            GetNumTotalElementsToLoad: function () {
                return window.BridgeSoundOutputJavascript.getNumTotalElementsToLoad();
            },
            /**
             * Volume ranges from 0 to 100 (both inclusive)
             *
             * @instance
             * @public
             * @this ChessCompStompWithHacks.BridgeSoundOutput
             * @memberof ChessCompStompWithHacks.BridgeSoundOutput
             * @param   {number}    volume
             * @return  {void}
             */
            SetSoundVolume: function (volume) {
                if (volume < 0) {
                    throw new System.Exception();
                }

                if (volume > 100) {
                    throw new System.Exception();
                }

                this.desiredSoundVolume = volume;
            },
            SetSoundVolumeImmediately: function (volume) {
                if (volume < 0) {
                    throw new System.Exception();
                }

                if (volume > 100) {
                    throw new System.Exception();
                }

                this.desiredSoundVolume = volume;
                this.currentSoundVolume = volume;
            },
            GetSoundVolume: function () {
                return this.desiredSoundVolume;
            },
            ProcessFrame: function () {
                this.currentSoundVolume = DTLibrary.VolumeUtil.GetVolumeSmoothed(this.elapsedMicrosPerFrame, this.currentSoundVolume, this.desiredSoundVolume);
            },
            PlaySound: function (sound) {
                var finalVolume = (ChessCompStompWithHacksLibrary.GameSoundUtil.GetSoundVolume(sound) / 100.0) * (this.currentSoundVolume / 100.0);
                if (finalVolume > 1.0) {
                    finalVolume = 1.0;
                }
                if (finalVolume < 0.0) {
                    finalVolume = 0.0;
                }

                if (finalVolume > 0.0) {
                    var soundFilename = ChessCompStompWithHacksLibrary.GameSoundUtil.GetSoundFilename(sound).OggFilename;
                    window.BridgeSoundOutputJavascript.playSound(soundFilename, finalVolume);
                }
            },
            DisposeSounds: function () { }
        }
    });

    Bridge.define("DTLibrary.DTDeterministicRandom", {
        inherits: [DTLibrary.IDTDeterministicRandom],
        fields: {
            x: 0
        },
        alias: [
            "SerializeToString", "DTLibrary$IDTDeterministicRandom$SerializeToString",
            "DeserializeFromString", "DTLibrary$IDTDeterministicRandom$DeserializeFromString",
            "AddSeed", "DTLibrary$IDTRandom$AddSeed",
            "Reset", "DTLibrary$IDTDeterministicRandom$Reset",
            "NextInt", "DTLibrary$IDTRandom$NextInt",
            "NextBool", "DTLibrary$IDTRandom$NextBool"
        ],
        ctors: {
            ctor: function () {
                this.$initialize();
                this.x = 0;
            },
            $ctor1: function (seed) {
                this.$initialize();
                this.x = seed;
            }
        },
        methods: {
            SerializeToString: function () {
                return DTLibrary.StringUtil.ToStringCultureInvariant(this.x);
            },
            DeserializeFromString: function (str) {
                this.x = DTLibrary.StringUtil.ParseAsIntCultureInvariant(str);
            },
            AddSeed: function (i) {
                this.x = ((this.x + i) | 0);
            },
            Reset: function () {
                this.x = 0;
            },
            NextInt: function (i) {
                if (i === 1) {
                    return 0;
                }

                var a = ((Bridge.Int.mul(48271, this.x) + 11) | 0);
                var b = ((Bridge.Int.mul(48271, a) + 11) | 0);

                this.x = b;

                var c = ((a >> 16) << 16) | ((b >> 16) & 65535);

                if (c < 0) {
                    c = ((-c) | 0);
                }

                if (c < 0) {
                    c = 0;
                }

                return c % i;
            },
            NextBool: function () {
                return this.NextInt(2) === 1;
            }
        }
    });

    Bridge.define("DTLibrary.EmptyMusic$1", function (MusicEnum) { return {
        inherits: [DTLibrary.IMusic$1(MusicEnum)],
        alias: [
            "DisposeMusic", "DTLibrary$IMusicCleanup$DisposeMusic",
            "LoadMusic", "DTLibrary$IMusicProcessing$LoadMusic",
            "GetNumElementsLoaded", "DTLibrary$IMusicProcessing$GetNumElementsLoaded",
            "GetNumTotalElementsToLoad", "DTLibrary$IMusicProcessing$GetNumTotalElementsToLoad",
            "PlayMusic", "DTLibrary$IMusicOutput$1$" + Bridge.getTypeAlias(MusicEnum) + "$PlayMusic",
            "StopMusic", "DTLibrary$IMusicOutput$1$" + Bridge.getTypeAlias(MusicEnum) + "$StopMusic"
        ],
        methods: {
            DisposeMusic: function () { },
            LoadMusic: function () {
                return true;
            },
            GetNumElementsLoaded: function () {
                return 0;
            },
            GetNumTotalElementsToLoad: function () {
                return 0;
            },
            PlayMusic: function (music, volume) { },
            StopMusic: function () { }
        }
    }; });

    Bridge.define("ChessCompStompWithHacks.BridgeDisplay", {
        inherits: [DTLibrary.DTDisplay$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont)],
        fields: {
            canvasWidthAndHeightInfo: null,
            bridgeDisplayRectangle: null,
            bridgeDisplayImages: null,
            bridgeDisplayFont: null
        },
        alias: [
            "DrawInitialLoadingScreen", "DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawInitialLoadingScreen",
            "DrawRectangle", "DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle",
            "LoadImages", "DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$LoadImages",
            "GetNumElementsLoaded", "DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetNumElementsLoaded",
            "GetNumTotalElementsToLoad", "DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetNumTotalElementsToLoad",
            "DrawImageRotatedClockwise$1", "DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawImageRotatedClockwise$1",
            "DrawImageRotatedClockwise", "DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawImageRotatedClockwise$2",
            "GetWidth", "DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetWidth",
            "GetWidth", "DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetWidth",
            "GetHeight", "DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetHeight",
            "GetHeight", "DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetHeight",
            "DrawText", "DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText",
            "TryDrawText", "DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$TryDrawText",
            "DisposeImages", "DTLibrary$IDisplayCleanup$DisposeImages",
            "GetMobileScreenWidth", "DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth",
            "GetMobileScreenWidth", "DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth",
            "GetMobileScreenHeight", "DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight",
            "GetMobileScreenHeight", "DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenHeight",
            "Debug_GetBrowserInfo", "DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$Debug_GetBrowserInfo"
        ],
        ctors: {
            ctor: function (canvasWidthAndHeightInfo, canvasScalingFactor) {
                this.$initialize();
                DTLibrary.DTDisplay$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont).ctor.call(this);
                this.canvasWidthAndHeightInfo = canvasWidthAndHeightInfo;

                this.bridgeDisplayRectangle = new ChessCompStompWithHacks.BridgeDisplayRectangle(canvasWidthAndHeightInfo);
                this.bridgeDisplayImages = new ChessCompStompWithHacks.BridgeDisplayImages(canvasWidthAndHeightInfo, canvasScalingFactor);
                this.bridgeDisplayFont = new ChessCompStompWithHacks.BridgeDisplayFont(canvasWidthAndHeightInfo);
            }
        },
        methods: {
            DrawInitialLoadingScreen: function () { },
            DrawRectangle: function (x, y, width, height, color, fill) {
                this.bridgeDisplayRectangle.DrawRectangle(x, y, width, height, color, fill);
            },
            LoadImages: function () {
                var finishedLoadingFonts = this.bridgeDisplayFont.LoadFonts();
                var finishedLoadingImages = this.bridgeDisplayImages.LoadImages();

                return finishedLoadingImages && finishedLoadingFonts;
            },
            GetNumElementsLoaded: function () {
                return ((this.bridgeDisplayImages.GetNumElementsLoaded() + this.bridgeDisplayFont.GetNumElementsLoaded()) | 0);
            },
            GetNumTotalElementsToLoad: function () {
                var numImageElements = this.bridgeDisplayImages.GetNumTotalElementsToLoad();
                var numFontElements = this.bridgeDisplayFont.GetNumTotalElementsToLoad();

                if (!System.Nullable.hasValue(numImageElements)) {
                    return null;
                }
                if (!System.Nullable.hasValue(numFontElements)) {
                    return null;
                }

                return Bridge.Int.clip32(System.Nullable.getValue(numImageElements) + System.Nullable.getValue(numFontElements));
            },
            DrawImageRotatedClockwise$1: function (image, x, y, degreesScaled, scalingFactorScaled) {
                this.bridgeDisplayImages.DrawImageRotatedClockwise(image, x, y, degreesScaled, scalingFactorScaled);
            },
            DrawImageRotatedClockwise: function (image, imageX, imageY, imageWidth, imageHeight, x, y, degreesScaled, scalingFactorScaled) {
                this.bridgeDisplayImages.DrawImageRotatedClockwise$1(image, imageX, imageY, imageWidth, imageHeight, x, y, degreesScaled, scalingFactorScaled);
            },
            GetWidth: function (image) {
                return this.bridgeDisplayImages.GetWidth(image);
            },
            GetHeight: function (image) {
                return this.bridgeDisplayImages.GetHeight(image);
            },
            DrawText: function (x, y, text, font, color) {
                this.bridgeDisplayFont.DrawText(x, y, text, font, color);
            },
            TryDrawText: function (x, y, text, font, color) {
                this.bridgeDisplayFont.TryDrawText(x, y, text, font, color);
            },
            DisposeImages: function () { },
            GetMobileScreenWidth: function () {
                return this.canvasWidthAndHeightInfo.ChessCompStompWithHacks$BridgeDisplay$ICanvasWidthAndHeightInfo$GetCurrentCanvasWidth();
            },
            GetMobileScreenHeight: function () {
                return this.canvasWidthAndHeightInfo.ChessCompStompWithHacks$BridgeDisplay$ICanvasWidthAndHeightInfo$GetCurrentCanvasHeight();
            },
            Debug_GetBrowserInfo: function (stringToEval) {
                var result = eval(stringToEval);

                return (result || "") + "";
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.AIMessageDesktopFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        statics: {
            fields: {
                PANEL_WIDTH: 0,
                PANEL_HEIGHT: 0,
                PANEL_X: 0,
                PANEL_Y: 0
            },
            ctors: {
                init: function () {
                    this.PANEL_WIDTH = 480;
                    this.PANEL_HEIGHT = 200;
                    this.PANEL_X = 260;
                    this.PANEL_Y = 250;
                }
            },
            methods: {
                GetAIHackMessageFrame: function (globalState, sessionState) {
                    return new ChessCompStompWithHacksLibrary.AIMessageDesktopFrame(globalState, sessionState, new ChessCompStompWithHacksLibrary.ChessDesktopFrame.ctor(globalState, sessionState), "If you're going to hack, then I'm hacking too!", 29, 114, ChessCompStompWithHacksLibrary.AIMessageType.AIHackMessage);
                },
                GetFinalBattleMessageFrame: function (globalState, sessionState) {
                    return new ChessCompStompWithHacksLibrary.AIMessageDesktopFrame(globalState, sessionState, new ChessCompStompWithHacksLibrary.ChessDesktopFrame.ctor(globalState, sessionState), "I have 23 queens. Good luck; have fun!  :)", 50, 114, ChessCompStompWithHacksLibrary.AIMessageType.FinalBattleMessage);
                }
            }
        },
        fields: {
            globalState: null,
            sessionState: null,
            underlyingFrame: null,
            message: null,
            messageXOffset: 0,
            messageYOffset: 0,
            confirmButton: null,
            aiMessageType: 0
        },
        alias: [
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState, underlyingFrame, message, messageXOffset, messageYOffset, aiMessageType) {
                this.$initialize();
                this.globalState = globalState;
                this.sessionState = sessionState;
                this.underlyingFrame = underlyingFrame;
                this.message = message;
                this.messageXOffset = messageXOffset;
                this.messageYOffset = messageYOffset;

                var buttonWidth = 150;

                this.aiMessageType = aiMessageType;

                this.confirmButton = new ChessCompStompWithHacksLibrary.Button(((ChessCompStompWithHacksLibrary.AIMessageDesktopFrame.PANEL_X + ((Bridge.Int.div((((ChessCompStompWithHacksLibrary.AIMessageDesktopFrame.PANEL_WIDTH - buttonWidth) | 0)), 2)) | 0)) | 0), 270, buttonWidth, 40, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "OK", 57, 8, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, false);
            }
        },
        methods: {
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessExtraTime: function (milliseconds) { },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType !== DTLibrary.DisplayType.Desktop) {
                    switch (this.aiMessageType) {
                        case ChessCompStompWithHacksLibrary.AIMessageType.AIHackMessage: 
                            return ChessCompStompWithHacksLibrary.AIMessageMobileFrame.GetAIHackMessageFrame(this.globalState, this.sessionState, displayProcessing);
                        case ChessCompStompWithHacksLibrary.AIMessageType.FinalBattleMessage: 
                            return ChessCompStompWithHacksLibrary.AIMessageMobileFrame.GetFinalBattleMessageFrame(this.globalState, this.sessionState, displayProcessing);
                        default: 
                            throw new System.Exception();
                    }
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                var music = ChessCompStompWithHacksLibrary.GameMusicUtil.GetGameMusic(this.sessionState.GetColorTheme());
                this.globalState.MusicPlayer.SetMusic(music, 100);

                var isConfirmClicked = this.confirmButton.ProcessFrame(mouseInput, previousMouseInput);

                if (isConfirmClicked) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return this.underlyingFrame;
                }

                return this;
            },
            ProcessMusic: function () {
                this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic();
            },
            Render: function (displayOutput) {
                this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render(displayOutput);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT, new DTLibrary.DTColor.$ctor1(0, 0, 0, 64), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(ChessCompStompWithHacksLibrary.AIMessageDesktopFrame.PANEL_X, ChessCompStompWithHacksLibrary.AIMessageDesktopFrame.PANEL_Y, ChessCompStompWithHacksLibrary.AIMessageDesktopFrame.PANEL_WIDTH, ChessCompStompWithHacksLibrary.AIMessageDesktopFrame.PANEL_HEIGHT, DTLibrary.DTColor.White(), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(ChessCompStompWithHacksLibrary.AIMessageDesktopFrame.PANEL_X, ChessCompStompWithHacksLibrary.AIMessageDesktopFrame.PANEL_Y, ChessCompStompWithHacksLibrary.AIMessageDesktopFrame.PANEL_WIDTH, ChessCompStompWithHacksLibrary.AIMessageDesktopFrame.PANEL_HEIGHT, DTLibrary.DTColor.Black(), false);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(364, 422, "Message from the AI", ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((ChessCompStompWithHacksLibrary.AIMessageDesktopFrame.PANEL_X + this.messageXOffset) | 0), ((ChessCompStompWithHacksLibrary.AIMessageDesktopFrame.PANEL_Y + this.messageYOffset) | 0), this.message, ChessCompStompWithHacksLibrary.GameFont.GameFont14Pt, DTLibrary.DTColor.Black());

                this.confirmButton.Render(displayOutput);
            },
            RenderMusic: function (musicOutput) {
                this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.AIMessageMobileFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        statics: {
            methods: {
                GetAIHackMessageFrame: function (globalState, sessionState, display) {
                    return new ChessCompStompWithHacksLibrary.AIMessageMobileFrame(globalState, sessionState, new ChessCompStompWithHacksLibrary.ChessMobileFrame.ctor(globalState, sessionState, display), "If you're going to hack, then I'm hacking too!", 27, 90, ChessCompStompWithHacksLibrary.AIMessageType.AIHackMessage, display);
                },
                GetFinalBattleMessageFrame: function (globalState, sessionState, display) {
                    return new ChessCompStompWithHacksLibrary.AIMessageMobileFrame(globalState, sessionState, new ChessCompStompWithHacksLibrary.ChessMobileFrame.ctor(globalState, sessionState, display), "I have 23 queens. Good luck; have fun!  :)", 27, 90, ChessCompStompWithHacksLibrary.AIMessageType.FinalBattleMessage, display);
                }
            }
        },
        fields: {
            globalState: null,
            sessionState: null,
            underlyingFrame: null,
            message: null,
            messageXOffset: 0,
            messageYOffset: 0,
            confirmButton: null,
            widthOfUnderlyingFrame: 0,
            heightOfUnderlyingFrame: 0,
            renderUnderlyingFrame: false,
            aiMessageType: 0,
            panelX: 0,
            panelY: 0,
            panelWidth: 0,
            panelHeight: 0
        },
        alias: [
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState, underlyingFrame, message, messageXOffset, messageYOffset, aiMessageType, display) {
                this.$initialize();
                this.widthOfUnderlyingFrame = display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth();
                this.heightOfUnderlyingFrame = display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenHeight();
                this.renderUnderlyingFrame = true;

                this.aiMessageType = aiMessageType;

                this.globalState = globalState;
                this.sessionState = sessionState;
                this.underlyingFrame = underlyingFrame;
                this.message = message;
                this.messageXOffset = messageXOffset;
                this.messageYOffset = messageYOffset;

                this.confirmButton = new ChessCompStompWithHacksLibrary.Button(0, 0, 225, 100, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "OK", 85, 29, ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt, true);

                this.UpdateCoordinates(display);
            }
        },
        methods: {
            UpdateCoordinates: function (display) {
                var isLandscape = DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation(ChessCompStompWithHacksLibrary.GameImage, display);

                this.panelWidth = isLandscape ? 800 : 650;
                this.panelHeight = 350;

                this.panelX = (Bridge.Int.div((((display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth() - this.panelWidth) | 0)), 2)) | 0;
                this.panelY = (Bridge.Int.div((((display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenHeight() - this.panelHeight) | 0)), 2)) | 0;

                this.confirmButton.SetX(((this.panelX + ((Bridge.Int.div((((this.panelWidth - 225) | 0)), 2)) | 0)) | 0));
                this.confirmButton.SetY(((this.panelY + 50) | 0));
            },
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessExtraTime: function (milliseconds) { },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType === DTLibrary.DisplayType.Desktop) {
                    switch (this.aiMessageType) {
                        case ChessCompStompWithHacksLibrary.AIMessageType.AIHackMessage: 
                            return ChessCompStompWithHacksLibrary.AIMessageDesktopFrame.GetAIHackMessageFrame(this.globalState, this.sessionState);
                        case ChessCompStompWithHacksLibrary.AIMessageType.FinalBattleMessage: 
                            return ChessCompStompWithHacksLibrary.AIMessageDesktopFrame.GetFinalBattleMessageFrame(this.globalState, this.sessionState);
                        default: 
                            throw new System.Exception();
                    }
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                this.UpdateCoordinates(displayProcessing);

                if (displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth() !== this.widthOfUnderlyingFrame) {
                    this.renderUnderlyingFrame = false;
                }
                if (displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenHeight() !== this.heightOfUnderlyingFrame) {
                    this.renderUnderlyingFrame = false;
                }

                var music = ChessCompStompWithHacksLibrary.GameMusicUtil.GetGameMusic(this.sessionState.GetColorTheme());
                this.globalState.MusicPlayer.SetMusic(music, 100);

                var isConfirmClicked = this.confirmButton.ProcessFrame(mouseInput, previousMouseInput);

                if (isConfirmClicked) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return this.underlyingFrame;
                }

                return this;
            },
            ProcessMusic: function () {
                this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic();
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth(), displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight(), new DTLibrary.DTColor.ctor(223, 220, 217), true);

                if (this.renderUnderlyingFrame) {
                    this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render(displayOutput);
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth(), displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight(), new DTLibrary.DTColor.$ctor1(0, 0, 0, 64), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(this.panelX, this.panelY, this.panelWidth, this.panelHeight, DTLibrary.DTColor.White(), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(this.panelX, this.panelY, this.panelWidth, this.panelHeight, DTLibrary.DTColor.Black(), false);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((((this.panelX + ((Bridge.Int.div(this.panelWidth, 2)) | 0)) | 0) - 219) | 0), ((((this.panelY + this.panelHeight) | 0) - 27) | 0), "Message from the AI", ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt, DTLibrary.DTColor.Black());

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((this.panelX + this.messageXOffset) | 0), ((((this.panelY + this.panelHeight) | 0) - this.messageYOffset) | 0), this.message, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                this.confirmButton.Render(displayOutput);
            },
            RenderMusic: function (musicOutput) {
                this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ChessDesktopFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        statics: {
            fields: {
                GAME_LOGIC_X_OFFSET: 0,
                GAME_LOGIC_Y_OFFSET: 0
            },
            ctors: {
                init: function () {
                    this.GAME_LOGIC_X_OFFSET = 0;
                    this.GAME_LOGIC_Y_OFFSET = 50;
                }
            }
        },
        fields: {
            globalState: null,
            sessionState: null,
            delayBeforeShowingPanel: null,
            victoryStalemateOrDefeatPanel: null,
            finalBattleVictoryPanel: null,
            settingsIcon: null,
            resignButton: null,
            viewObjectivesButton: null,
            viewHacksButton: null
        },
        alias: [
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState) {
                ChessCompStompWithHacksLibrary.ChessDesktopFrame.$ctor1.call(this, globalState, sessionState, null, null, null);
            },
            $ctor1: function (globalState, sessionState, delayBeforeShowingPanel, victoryStalemateOrDefeatPanel, finalBattleVictoryPanel) {
                this.$initialize();
                this.globalState = globalState;
                this.sessionState = sessionState;
                this.delayBeforeShowingPanel = delayBeforeShowingPanel;
                this.victoryStalemateOrDefeatPanel = victoryStalemateOrDefeatPanel;
                this.finalBattleVictoryPanel = finalBattleVictoryPanel;

                this.settingsIcon = new ChessCompStompWithHacksLibrary.SettingsIcon(false);

                this.resignButton = new ChessCompStompWithHacksLibrary.Button(869, 100, 100, 40, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Resign", 14, 9, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, false);

                this.viewObjectivesButton = new ChessCompStompWithHacksLibrary.Button(770, 30, 199, 40, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "View objectives", 16, 9, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, false);

                this.viewHacksButton = new ChessCompStompWithHacksLibrary.Button(621, 30, 150, 40, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "View hacks", 16, 9, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, false);
            }
        },
        methods: {
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return this.sessionState.GetCompletedAchievements();
            },
            ProcessExtraTime: function (milliseconds) {
                var gameLogic = this.sessionState.GetGameLogic();
                if (gameLogic != null) {
                    gameLogic.ProcessExtraTime(milliseconds);
                }
            },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType !== DTLibrary.DisplayType.Desktop) {
                    return new ChessCompStompWithHacksLibrary.ChessMobileFrame.$ctor1(this.globalState, this.sessionState, displayProcessing, this.delayBeforeShowingPanel, this.victoryStalemateOrDefeatPanel, this.finalBattleVictoryPanel);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                if (this.finalBattleVictoryPanel == null) {
                    var music = ChessCompStompWithHacksLibrary.GameMusicUtil.GetGameMusic(this.sessionState.GetColorTheme());
                    this.globalState.MusicPlayer.SetMusic(music, 100);
                }

                var victoryStalemateOrDefeatPanelResult = null;

                if (this.victoryStalemateOrDefeatPanel != null) {
                    victoryStalemateOrDefeatPanelResult = this.victoryStalemateOrDefeatPanel.ProcessFrame(mouseInput, previousMouseInput, this.globalState.ElapsedMicrosPerFrame, displayProcessing, false);

                    if (victoryStalemateOrDefeatPanelResult.HasClickedContinueButton) {
                        this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        return new ChessCompStompWithHacksLibrary.HackSelectionScreenDesktopFrame(this.globalState, this.sessionState);
                    }
                }

                var finalBattleVictoryPanelResult = null;

                if (this.finalBattleVictoryPanel != null) {
                    this.globalState.MusicPlayer.SetMusic(ChessCompStompWithHacksLibrary.GameMusic.Ending, 100);

                    finalBattleVictoryPanelResult = this.finalBattleVictoryPanel.ProcessFrame(mouseInput, previousMouseInput, displayProcessing, false);
                    if (finalBattleVictoryPanelResult.HasClickedContinueButton) {
                        this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        return new ChessCompStompWithHacksLibrary.TitleScreenDesktopFrame(this.globalState, this.sessionState);
                    }
                }

                var isHoverOverPanel = victoryStalemateOrDefeatPanelResult != null && victoryStalemateOrDefeatPanelResult.IsHoverOverPanel || finalBattleVictoryPanelResult != null && finalBattleVictoryPanelResult.IsHoverOverPanel;

                var dummyMouseInput = new DTLibrary.SimulatedMouse(-999, -999, mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed(), mouseInput.DTLibrary$IMouse$IsRightMouseButtonPressed());

                var gameLogic = this.sessionState.GetGameLogic();
                if (gameLogic == null) {
                    gameLogic = this.sessionState.GetMostRecentGameLogic();
                }
                var result = gameLogic.ProcessNextFrame(isHoverOverPanel ? dummyMouseInput : new DTLibrary.TranslatedMouse(mouseInput, 0, -50), displayProcessing, soundOutput, this.globalState.ElapsedMicrosPerFrame, false);

                var hasCompletedANewObjective = this.sessionState.AddCompletedObjectives(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.Objective)).$ctor1(result.CompletedObjectives));

                if (hasCompletedANewObjective) {
                    this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                }

                var didPlayerWin = result.GameStatus === ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.WhiteVictory && result.IsPlayerWhite || result.GameStatus === ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.BlackVictory && !result.IsPlayerWhite;

                if (this.delayBeforeShowingPanel == null) {
                    if (result.GameStatus !== ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.InProgress) {
                        this.sessionState.CompleteGame(didPlayerWin);
                        this.delayBeforeShowingPanel = 0;
                        this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    }
                }

                if (this.delayBeforeShowingPanel != null && this.victoryStalemateOrDefeatPanel == null && this.finalBattleVictoryPanel == null) {
                    this.delayBeforeShowingPanel = Bridge.Int.clip32(System.Nullable.getValue(this.delayBeforeShowingPanel) + this.globalState.ElapsedMicrosPerFrame);

                    if (System.Nullable.getValue(this.delayBeforeShowingPanel) >= 1000000) {
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(didPlayerWin ? ChessCompStompWithHacksLibrary.GameSound.Win : ChessCompStompWithHacksLibrary.GameSound.StalemateOrDefeat);

                        if (didPlayerWin && result.IsFinalBattle && !this.sessionState.HasShownFinalBattleVictoryPanel()) {
                            this.sessionState.SetShownFinalBattleVictoryPanel();
                            this.finalBattleVictoryPanel = new ChessCompStompWithHacksLibrary.FinalBattleVictoryPanel(this.sessionState.GetColorTheme(), displayProcessing, false);
                        } else {
                            this.victoryStalemateOrDefeatPanel = new ChessCompStompWithHacksLibrary.VictoryStalemateOrDefeatPanel(result.GameStatus, result.IsPlayerWhite, this.sessionState.GetCompletedObjectives(), this.sessionState.GetObjectivesThatWereAlreadyCompletedPriorToCurrentGame(), this.sessionState.GetColorTheme(), displayProcessing, false);
                        }
                    }
                }

                var isWaitingForFinalBattleVictoryPanel = didPlayerWin && result.IsFinalBattle && !this.sessionState.HasShownFinalBattleVictoryPanel() && this.finalBattleVictoryPanel == null;

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !isWaitingForFinalBattleVictoryPanel) {
                    this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.SettingsMenuDesktopFrame(this.globalState, this.sessionState, this, true, true);
                }

                if (this.delayBeforeShowingPanel == null) {
                    var hasClickedResignButton = this.resignButton.ProcessFrame(mouseInput, previousMouseInput);

                    if (hasClickedResignButton) {
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        return new ChessCompStompWithHacksLibrary.ResignConfirmationDesktopFrame(this.globalState, this.sessionState, this, true);
                    }

                    var hasClickedViewObjectivesButton = this.viewObjectivesButton.ProcessFrame(mouseInput, previousMouseInput);
                    if (hasClickedViewObjectivesButton) {
                        this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        return new ChessCompStompWithHacksLibrary.ViewObjectivesDesktopFrame(this.globalState, this.sessionState);
                    }

                    var hasClickedViewHacksButton = this.viewHacksButton.ProcessFrame(mouseInput, previousMouseInput);
                    if (hasClickedViewHacksButton) {
                        this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        return new ChessCompStompWithHacksLibrary.ViewHacksDesktopFrame(this.globalState, this.sessionState);
                    }
                }

                var hasClicked = this.settingsIcon.ProcessFrame(mouseInput, previousMouseInput, isHoverOverPanel, displayProcessing).HasClicked;

                if (hasClicked && !isWaitingForFinalBattleVictoryPanel) {
                    this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.SettingsMenuDesktopFrame(this.globalState, this.sessionState, this, true, true);
                }

                if (this.globalState.DebugMode) {
                    if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.One) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.One)) {
                        this.globalState.UseDebugAI = !this.globalState.UseDebugAI;
                    }
                }

                return this;
            },
            ProcessMusic: function () {
                this.globalState.ProcessMusic();
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT, new DTLibrary.DTColor.ctor(223, 220, 217), true);

                var gameLogic = this.sessionState.GetGameLogic();
                if (gameLogic == null) {
                    gameLogic = this.sessionState.GetMostRecentGameLogic();
                }
                gameLogic.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, ChessCompStompWithHacksLibrary.ChessDesktopFrame.GAME_LOGIC_X_OFFSET, ChessCompStompWithHacksLibrary.ChessDesktopFrame.GAME_LOGIC_Y_OFFSET), false);

                if (this.delayBeforeShowingPanel == null) {
                    this.resignButton.Render(displayOutput);
                    this.viewObjectivesButton.Render(displayOutput);
                    this.viewHacksButton.Render(displayOutput);
                }

                this.settingsIcon.Render(displayOutput);

                if (this.victoryStalemateOrDefeatPanel != null) {
                    this.victoryStalemateOrDefeatPanel.Render(displayOutput);
                }

                if (this.finalBattleVictoryPanel != null) {
                    this.finalBattleVictoryPanel.Render(displayOutput, false);
                }
            },
            RenderMusic: function (musicOutput) {
                this.globalState.RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ChessMobileFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        fields: {
            globalState: null,
            sessionState: null,
            delayBeforeShowingPanel: null,
            victoryStalemateOrDefeatPanel: null,
            finalBattleVictoryPanel: null,
            settingsIcon: null,
            resignButton: null,
            viewObjectivesButton: null,
            viewHacksButton: null,
            gameLogicXOffset: 0,
            gameLogicYOffset: 0
        },
        alias: [
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState, display) {
                ChessCompStompWithHacksLibrary.ChessMobileFrame.$ctor1.call(this, globalState, sessionState, display, null, null, null);
            },
            $ctor1: function (globalState, sessionState, display, delayBeforeShowingPanel, victoryStalemateOrDefeatPanel, finalBattleVictoryPanel) {
                this.$initialize();
                this.globalState = globalState;
                this.sessionState = sessionState;
                this.delayBeforeShowingPanel = delayBeforeShowingPanel;
                this.victoryStalemateOrDefeatPanel = victoryStalemateOrDefeatPanel;
                this.finalBattleVictoryPanel = finalBattleVictoryPanel;

                this.settingsIcon = new ChessCompStompWithHacksLibrary.SettingsIcon(true);

                this.resignButton = new ChessCompStompWithHacksLibrary.Button(0, 0, 140, 100, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Resign", 34, 39, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, true);

                this.viewObjectivesButton = new ChessCompStompWithHacksLibrary.Button(0, 0, 10, 10, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "", 16, 0, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, true);

                this.viewHacksButton = new ChessCompStompWithHacksLibrary.Button(0, 0, 10, 10, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "", 16, 0, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, true);

                this.UpdateCoordinates(display);
            }
        },
        methods: {
            UpdateCoordinates: function (display) {
                if (DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation(ChessCompStompWithHacksLibrary.GameImage, display)) {
                    this.gameLogicXOffset = (Bridge.Int.div((((display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth() - 1000) | 0)), 2)) | 0;
                    this.gameLogicYOffset = 0;

                    var x = (this.gameLogicXOffset + 850) | 0;

                    this.resignButton.SetX(x);
                    this.resignButton.SetY(250);

                    this.viewObjectivesButton.SetX(x);
                    this.viewObjectivesButton.SetY(10);
                    this.viewObjectivesButton.SetText("     View \nobjectives");
                    this.viewObjectivesButton.SetWidth(140);
                    this.viewObjectivesButton.SetHeight(100);
                    this.viewObjectivesButton.SetTextYOffset(26);

                    this.viewHacksButton.SetX(x);
                    this.viewHacksButton.SetY(110);
                    this.viewHacksButton.SetText("     View \n    hacks");
                    this.viewHacksButton.SetWidth(140);
                    this.viewHacksButton.SetHeight(100);
                    this.viewHacksButton.SetTextYOffset(26);
                } else {
                    this.gameLogicXOffset = 0;
                    this.gameLogicYOffset = (display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenHeight() - 1000) | 0;

                    this.resignButton.SetX(((this.gameLogicXOffset + 550) | 0));
                    this.resignButton.SetY(((this.gameLogicYOffset + 100) | 0));

                    this.viewObjectivesButton.SetX(490);
                    this.viewObjectivesButton.SetY(((this.gameLogicYOffset + 10) | 0));
                    this.viewObjectivesButton.SetText("View objectives");
                    this.viewObjectivesButton.SetWidth(200);
                    this.viewObjectivesButton.SetHeight(80);
                    this.viewObjectivesButton.SetTextYOffset(29);

                    this.viewHacksButton.SetX(340);
                    this.viewHacksButton.SetY(((this.gameLogicYOffset + 10) | 0));
                    this.viewHacksButton.SetText("View hacks");
                    this.viewHacksButton.SetWidth(150);
                    this.viewHacksButton.SetHeight(80);
                    this.viewHacksButton.SetTextYOffset(29);
                }
            },
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return this.sessionState.GetCompletedAchievements();
            },
            ProcessExtraTime: function (milliseconds) {
                var gameLogic = this.sessionState.GetGameLogic();
                if (gameLogic != null) {
                    gameLogic.ProcessExtraTime(milliseconds);
                }
            },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType === DTLibrary.DisplayType.Desktop) {
                    return new ChessCompStompWithHacksLibrary.ChessDesktopFrame.$ctor1(this.globalState, this.sessionState, this.delayBeforeShowingPanel, this.victoryStalemateOrDefeatPanel, this.finalBattleVictoryPanel);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                this.UpdateCoordinates(displayProcessing);

                if (this.finalBattleVictoryPanel == null) {
                    var music = ChessCompStompWithHacksLibrary.GameMusicUtil.GetGameMusic(this.sessionState.GetColorTheme());
                    this.globalState.MusicPlayer.SetMusic(music, 100);
                }

                var victoryStalemateOrDefeatPanelResult = null;

                if (this.victoryStalemateOrDefeatPanel != null) {
                    victoryStalemateOrDefeatPanelResult = this.victoryStalemateOrDefeatPanel.ProcessFrame(mouseInput, previousMouseInput, this.globalState.ElapsedMicrosPerFrame, displayProcessing, true);

                    if (victoryStalemateOrDefeatPanelResult.HasClickedContinueButton) {
                        this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        return new ChessCompStompWithHacksLibrary.HackSelectionScreenMobileFrame(this.globalState, this.sessionState, displayProcessing);
                    }
                }

                var finalBattleVictoryPanelResult = null;

                if (this.finalBattleVictoryPanel != null) {
                    this.globalState.MusicPlayer.SetMusic(ChessCompStompWithHacksLibrary.GameMusic.Ending, 100);

                    finalBattleVictoryPanelResult = this.finalBattleVictoryPanel.ProcessFrame(mouseInput, previousMouseInput, displayProcessing, true);
                    if (finalBattleVictoryPanelResult.HasClickedContinueButton) {
                        this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        return new ChessCompStompWithHacksLibrary.TitleScreenMobileFrame(this.globalState, this.sessionState, displayProcessing);
                    }
                }

                var isHoverOverPanel = victoryStalemateOrDefeatPanelResult != null && victoryStalemateOrDefeatPanelResult.IsHoverOverPanel || finalBattleVictoryPanelResult != null && finalBattleVictoryPanelResult.IsHoverOverPanel;

                var dummyMouseInput = new DTLibrary.SimulatedMouse(-999, -999, mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed(), mouseInput.DTLibrary$IMouse$IsRightMouseButtonPressed());

                var gameLogic = this.sessionState.GetGameLogic();
                if (gameLogic == null) {
                    gameLogic = this.sessionState.GetMostRecentGameLogic();
                }
                var result = gameLogic.ProcessNextFrame(isHoverOverPanel ? dummyMouseInput : new DTLibrary.TranslatedMouse(mouseInput, ((-this.gameLogicXOffset) | 0), ((-this.gameLogicYOffset) | 0)), displayProcessing, soundOutput, this.globalState.ElapsedMicrosPerFrame, true);

                var hasCompletedANewObjective = this.sessionState.AddCompletedObjectives(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.Objective)).$ctor1(result.CompletedObjectives));

                if (hasCompletedANewObjective) {
                    this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                }

                var didPlayerWin = result.GameStatus === ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.WhiteVictory && result.IsPlayerWhite || result.GameStatus === ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.BlackVictory && !result.IsPlayerWhite;

                if (this.delayBeforeShowingPanel == null) {
                    if (result.GameStatus !== ChessCompStompWithHacksEngine.ComputeMoves.GameStatus.InProgress) {
                        this.sessionState.CompleteGame(didPlayerWin);
                        this.delayBeforeShowingPanel = 0;
                        this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    }
                }

                if (this.delayBeforeShowingPanel != null && this.victoryStalemateOrDefeatPanel == null && this.finalBattleVictoryPanel == null) {
                    this.delayBeforeShowingPanel = Bridge.Int.clip32(System.Nullable.getValue(this.delayBeforeShowingPanel) + this.globalState.ElapsedMicrosPerFrame);

                    if (System.Nullable.getValue(this.delayBeforeShowingPanel) >= 1000000) {
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(didPlayerWin ? ChessCompStompWithHacksLibrary.GameSound.Win : ChessCompStompWithHacksLibrary.GameSound.StalemateOrDefeat);

                        if (didPlayerWin && result.IsFinalBattle && !this.sessionState.HasShownFinalBattleVictoryPanel()) {
                            this.sessionState.SetShownFinalBattleVictoryPanel();
                            this.finalBattleVictoryPanel = new ChessCompStompWithHacksLibrary.FinalBattleVictoryPanel(this.sessionState.GetColorTheme(), displayProcessing, true);
                        } else {
                            this.victoryStalemateOrDefeatPanel = new ChessCompStompWithHacksLibrary.VictoryStalemateOrDefeatPanel(result.GameStatus, result.IsPlayerWhite, this.sessionState.GetCompletedObjectives(), this.sessionState.GetObjectivesThatWereAlreadyCompletedPriorToCurrentGame(), this.sessionState.GetColorTheme(), displayProcessing, true);
                        }
                    }
                }

                var isWaitingForFinalBattleVictoryPanel = didPlayerWin && result.IsFinalBattle && !this.sessionState.HasShownFinalBattleVictoryPanel() && this.finalBattleVictoryPanel == null;

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !isWaitingForFinalBattleVictoryPanel) {
                    this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.SettingsMenuMobileFrame(this.globalState, this.sessionState, this, true, displayProcessing, true);
                }

                if (this.delayBeforeShowingPanel == null) {
                    var hasClickedResignButton = this.resignButton.ProcessFrame(mouseInput, previousMouseInput);

                    if (hasClickedResignButton) {
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        return new ChessCompStompWithHacksLibrary.ResignConfirmationMobileFrame(this.globalState, this.sessionState, this, displayProcessing, true);
                    }

                    var hasClickedViewObjectivesButton = this.viewObjectivesButton.ProcessFrame(mouseInput, previousMouseInput);
                    if (hasClickedViewObjectivesButton) {
                        this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        return new ChessCompStompWithHacksLibrary.ViewObjectivesMobileFrame(this.globalState, this.sessionState, displayProcessing);
                    }

                    var hasClickedViewHacksButton = this.viewHacksButton.ProcessFrame(mouseInput, previousMouseInput);
                    if (hasClickedViewHacksButton) {
                        this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        return new ChessCompStompWithHacksLibrary.ViewHacksMobileFrame(this.globalState, this.sessionState, displayProcessing);
                    }
                }

                var hasClicked = this.settingsIcon.ProcessFrame(mouseInput, previousMouseInput, isHoverOverPanel, displayProcessing).HasClicked;

                if (hasClicked && !isWaitingForFinalBattleVictoryPanel) {
                    this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.SettingsMenuMobileFrame(this.globalState, this.sessionState, this, true, displayProcessing, true);
                }

                if (this.globalState.DebugMode) {
                    if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.One) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.One)) {
                        this.globalState.UseDebugAI = !this.globalState.UseDebugAI;
                    }
                }

                return this;
            },
            ProcessMusic: function () {
                this.globalState.ProcessMusic();
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth(), displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight(), new DTLibrary.DTColor.ctor(223, 220, 217), true);

                if (this.delayBeforeShowingPanel == null) {
                    this.resignButton.Render(displayOutput);
                    this.viewObjectivesButton.Render(displayOutput);
                    this.viewHacksButton.Render(displayOutput);
                }

                var gameLogic = this.sessionState.GetGameLogic();
                if (gameLogic == null) {
                    gameLogic = this.sessionState.GetMostRecentGameLogic();
                }
                gameLogic.Render(new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, this.gameLogicXOffset, this.gameLogicYOffset), true);

                this.settingsIcon.Render(displayOutput);

                if (this.victoryStalemateOrDefeatPanel != null) {
                    this.victoryStalemateOrDefeatPanel.Render(displayOutput);
                }

                if (this.finalBattleVictoryPanel != null) {
                    this.finalBattleVictoryPanel.Render(displayOutput, true);
                }
            },
            RenderMusic: function (musicOutput) {
                this.globalState.RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ClearDataConfirmationDesktopFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        statics: {
            fields: {
                PANEL_WIDTH: 0,
                PANEL_HEIGHT: 0,
                PANEL_X: 0,
                PANEL_Y: 0
            },
            ctors: {
                init: function () {
                    this.PANEL_WIDTH = 480;
                    this.PANEL_HEIGHT = 150;
                    this.PANEL_X = 260;
                    this.PANEL_Y = 275;
                }
            }
        },
        fields: {
            globalState: null,
            sessionState: null,
            underlyingFrame: null,
            confirmButton: null,
            cancelButton: null
        },
        alias: [
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState, underlyingFrame) {
                this.$initialize();
                this.globalState = globalState;
                this.sessionState = sessionState;
                this.underlyingFrame = underlyingFrame;

                var buttonWidth = 150;
                var buttonHeight = 40;

                this.confirmButton = new ChessCompStompWithHacksLibrary.Button(340, 295, buttonWidth, buttonHeight, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Yes", 47, 8, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, false);

                this.cancelButton = new ChessCompStompWithHacksLibrary.Button(510, 295, buttonWidth, buttonHeight, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "No", 55, 8, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, false);
            }
        },
        methods: {
            ProcessExtraTime: function (milliseconds) { },
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessDisplayType: function (displayType, displayProcessing) {
                this.underlyingFrame = this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType(displayType, displayProcessing);

                if (displayType !== DTLibrary.DisplayType.Desktop) {
                    return new ChessCompStompWithHacksLibrary.ClearDataConfirmationMobileFrame(this.globalState, this.sessionState, this.underlyingFrame, displayProcessing);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                this.underlyingFrame = this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame(new DTLibrary.EmptyKeyboard(), new DTLibrary.EmptyMouse(), new DTLibrary.EmptyKeyboard(), new DTLibrary.EmptyMouse(), displayProcessing, soundOutput, musicProcessing);

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc)) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.TitleScreenDesktopFrame(this.globalState, this.sessionState);
                }

                var isConfirmClicked = this.confirmButton.ProcessFrame(mouseInput, previousMouseInput);

                var isCancelClicked = this.cancelButton.ProcessFrame(mouseInput, previousMouseInput);

                if (isConfirmClicked) {
                    this.sessionState.ClearData();
                    this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.TitleScreenDesktopFrame(this.globalState, this.sessionState);
                }

                if (isCancelClicked) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.TitleScreenDesktopFrame(this.globalState, this.sessionState);
                }

                return this;
            },
            ProcessMusic: function () {
                this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic();
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT, new DTLibrary.DTColor.ctor(223, 220, 217), true);

                this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render(displayOutput);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT, new DTLibrary.DTColor.$ctor1(0, 0, 0, 64), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(ChessCompStompWithHacksLibrary.ClearDataConfirmationDesktopFrame.PANEL_X, ChessCompStompWithHacksLibrary.ClearDataConfirmationDesktopFrame.PANEL_Y, ChessCompStompWithHacksLibrary.ClearDataConfirmationDesktopFrame.PANEL_WIDTH, ChessCompStompWithHacksLibrary.ClearDataConfirmationDesktopFrame.PANEL_HEIGHT, DTLibrary.DTColor.White(), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(ChessCompStompWithHacksLibrary.ClearDataConfirmationDesktopFrame.PANEL_X, ChessCompStompWithHacksLibrary.ClearDataConfirmationDesktopFrame.PANEL_Y, ChessCompStompWithHacksLibrary.ClearDataConfirmationDesktopFrame.PANEL_WIDTH, ChessCompStompWithHacksLibrary.ClearDataConfirmationDesktopFrame.PANEL_HEIGHT, DTLibrary.DTColor.Black(), false);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(287, 407, "Are you sure you want to reset\nyour progress?", ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                this.confirmButton.Render(displayOutput);
                this.cancelButton.Render(displayOutput);
            },
            RenderMusic: function (musicOutput) {
                this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ClearDataConfirmationMobileFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        fields: {
            globalState: null,
            sessionState: null,
            underlyingFrame: null,
            confirmButton: null,
            cancelButton: null,
            panelX: 0,
            panelY: 0,
            panelWidth: 0,
            panelHeight: 0
        },
        alias: [
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState, underlyingFrame, display) {
                this.$initialize();
                this.globalState = globalState;
                this.sessionState = sessionState;
                this.underlyingFrame = underlyingFrame;

                this.confirmButton = new ChessCompStompWithHacksLibrary.Button(0, 0, 10, 10, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Yes", 0, 0, ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt, true);

                this.cancelButton = new ChessCompStompWithHacksLibrary.Button(0, 0, 10, 10, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "No", 0, 0, ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt, true);

                this.UpdateCoordinates(display);
            }
        },
        methods: {
            UpdateCoordinates: function (display) {
                var isLandscape = DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation(ChessCompStompWithHacksLibrary.GameImage, display);

                this.panelWidth = isLandscape ? 800 : 600;
                this.panelHeight = isLandscape ? 500 : 400;
                this.panelX = (Bridge.Int.div((((display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth() - this.panelWidth) | 0)), 2)) | 0;
                this.panelY = (Bridge.Int.div((((display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenHeight() - this.panelHeight) | 0)), 2)) | 0;

                this.confirmButton.SetX(((this.panelX + 50) | 0));
                this.confirmButton.SetY(((this.panelY + 50) | 0));

                var buttonWidth = (Bridge.Int.div((((((((this.panelWidth - 50) | 0) - 50) | 0) - 50) | 0)), 2)) | 0;
                var buttonHeight = 100;

                this.confirmButton.SetWidth(buttonWidth);
                this.confirmButton.SetHeight(buttonHeight);

                this.confirmButton.SetTextXOffset(((((Bridge.Int.div(buttonWidth, 2)) | 0) - 38) | 0));
                this.confirmButton.SetTextYOffset(30);

                this.cancelButton.SetX(((((((this.panelX + 50) | 0) + buttonWidth) | 0) + 50) | 0));
                this.cancelButton.SetY(((this.panelY + 50) | 0));

                this.cancelButton.SetWidth(buttonWidth);
                this.cancelButton.SetHeight(buttonHeight);

                this.cancelButton.SetTextXOffset(((((Bridge.Int.div(buttonWidth, 2)) | 0) - 26) | 0));
                this.cancelButton.SetTextYOffset(30);
            },
            ProcessExtraTime: function (milliseconds) { },
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessDisplayType: function (displayType, displayProcessing) {
                this.underlyingFrame = this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType(displayType, displayProcessing);

                if (displayType === DTLibrary.DisplayType.Desktop) {
                    return new ChessCompStompWithHacksLibrary.ClearDataConfirmationDesktopFrame(this.globalState, this.sessionState, this.underlyingFrame);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                this.underlyingFrame = this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame(new DTLibrary.EmptyKeyboard(), new DTLibrary.EmptyMouse(), new DTLibrary.EmptyKeyboard(), new DTLibrary.EmptyMouse(), displayProcessing, soundOutput, musicProcessing);

                this.UpdateCoordinates(displayProcessing);

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc)) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.TitleScreenMobileFrame(this.globalState, this.sessionState, displayProcessing);
                }

                var isConfirmClicked = this.confirmButton.ProcessFrame(mouseInput, previousMouseInput);

                var isCancelClicked = this.cancelButton.ProcessFrame(mouseInput, previousMouseInput);

                if (isConfirmClicked) {
                    this.sessionState.ClearData();
                    this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.TitleScreenMobileFrame(this.globalState, this.sessionState, displayProcessing);
                }

                if (isCancelClicked) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.TitleScreenMobileFrame(this.globalState, this.sessionState, displayProcessing);
                }

                return this;
            },
            ProcessMusic: function () {
                this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic();
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth(), displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight(), new DTLibrary.DTColor.ctor(223, 220, 217), true);

                this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render(displayOutput);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth(), displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight(), new DTLibrary.DTColor.$ctor1(0, 0, 0, 64), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(this.panelX, this.panelY, this.panelWidth, this.panelHeight, DTLibrary.DTColor.White(), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(this.panelX, this.panelY, this.panelWidth, this.panelHeight, DTLibrary.DTColor.Black(), false);

                if (DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput)) {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((this.panelX + 27) | 0), ((((this.panelY + this.panelHeight) | 0) - 27) | 0), "Are you sure you want to reset\nyour progress?", ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt, DTLibrary.DTColor.Black());
                } else {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((this.panelX + 27) | 0), ((((this.panelY + this.panelHeight) | 0) - 27) | 0), "Are you sure you want to\nreset your progress?", ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt, DTLibrary.DTColor.Black());
                }

                this.confirmButton.Render(displayOutput);
                this.cancelButton.Render(displayOutput);
            },
            RenderMusic: function (musicOutput) {
                this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.CreditsDesktopFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        fields: {
            globalState: null,
            sessionState: null,
            tabButtons: null,
            selectedTab: 0,
            hoverTab: null,
            clickTab: null,
            backButton: null,
            creditsDesignAndCoding: null,
            creditsImages: null,
            creditsFont: null,
            clickUrl: null
        },
        alias: [
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState) {
                this.$initialize();
                this.globalState = globalState;
                this.sessionState = sessionState;

                this.selectedTab = ChessCompStompWithHacksLibrary.CreditsDesktopFrame.Tab.DesignAndCoding;
                this.hoverTab = null;
                this.clickTab = null;

                this.creditsDesignAndCoding = new ChessCompStompWithHacksLibrary.Credits_DesignAndCodingDesktop(sessionState.GetColorTheme(), 450, globalState.BuildType);
                this.creditsImages = new ChessCompStompWithHacksLibrary.Credits_ImagesDesktop(sessionState.GetColorTheme(), 450);
                this.creditsFont = new ChessCompStompWithHacksLibrary.Credits_FontDesktop(sessionState.GetColorTheme(), 450);

                this.tabButtons = new (System.Collections.Generic.List$1(ChessCompStompWithHacksLibrary.CreditsDesktopFrame.TabButton)).ctor();
                this.tabButtons.add(new ChessCompStompWithHacksLibrary.CreditsDesktopFrame.TabButton(20, 569, 234, 40, ChessCompStompWithHacksLibrary.CreditsDesktopFrame.Tab.DesignAndCoding, "Design and coding"));
                this.tabButtons.add(new ChessCompStompWithHacksLibrary.CreditsDesktopFrame.TabButton(254, 569, 103, 40, ChessCompStompWithHacksLibrary.CreditsDesktopFrame.Tab.Images, "Images"));
                this.tabButtons.add(new ChessCompStompWithHacksLibrary.CreditsDesktopFrame.TabButton(357, 569, 82, 40, ChessCompStompWithHacksLibrary.CreditsDesktopFrame.Tab.Font, "Font"));
                this.tabButtons.add(new ChessCompStompWithHacksLibrary.CreditsDesktopFrame.TabButton(439, 569, 96, 40, ChessCompStompWithHacksLibrary.CreditsDesktopFrame.Tab.Sound, "Sound"));
                this.tabButtons.add(new ChessCompStompWithHacksLibrary.CreditsDesktopFrame.TabButton(535, 569, 90, 40, ChessCompStompWithHacksLibrary.CreditsDesktopFrame.Tab.Music, "Music"));

                this.backButton = new ChessCompStompWithHacksLibrary.Button(780, 20, 200, 80, new DTLibrary.DTColor.ctor(235, 235, 235), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Back", 67, 28, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, false);

                this.clickUrl = null;
            }
        },
        methods: {
            GetClickUrl: function () {
                return this.clickUrl;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType !== DTLibrary.DisplayType.Desktop) {
                    return new ChessCompStompWithHacksLibrary.CreditsMobileFrame(this.globalState, this.sessionState, displayProcessing);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                var $t;
                var mouseX = mouseInput.DTLibrary$IMouse$GetX();
                var mouseY = mouseInput.DTLibrary$IMouse$GetY();

                this.clickUrl = null;

                this.hoverTab = null;
                $t = Bridge.getEnumerator(this.tabButtons);
                try {
                    while ($t.moveNext()) {
                        var tabButton = $t.Current;
                        if (tabButton.X <= mouseX && mouseX <= ((tabButton.X + tabButton.Width) | 0) && tabButton.Y <= mouseY && mouseY <= ((tabButton.Y + tabButton.Height) | 0)) {
                            this.hoverTab = tabButton.Tab;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                    if (this.hoverTab != null) {
                        this.clickTab = this.hoverTab;
                    }
                }

                if (this.clickTab != null && !mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                    if (System.Nullable.hasValue(this.hoverTab) && System.Nullable.getValue(this.hoverTab) === System.Nullable.getValue(this.clickTab)) {
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        this.selectedTab = System.Nullable.getValue(this.clickTab);
                    }

                    this.clickTab = null;
                }

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc)) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.TitleScreenDesktopFrame(this.globalState, this.sessionState);
                }

                var clickedBackButton = this.backButton.ProcessFrame(mouseInput, previousMouseInput);
                if (clickedBackButton) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.TitleScreenDesktopFrame(this.globalState, this.sessionState);
                }

                var translatedMouse = new DTLibrary.TranslatedMouse(mouseInput, -20, -120);
                var translatedPreviousMouse = new DTLibrary.TranslatedMouse(previousMouseInput, -20, -120);

                if (this.selectedTab === ChessCompStompWithHacksLibrary.CreditsDesktopFrame.Tab.DesignAndCoding) {
                    var result = this.creditsDesignAndCoding.ProcessFrame(translatedMouse, translatedPreviousMouse, soundOutput);

                    var clickedViewLicenseButton = result.ClickedButton;

                    this.clickUrl = result.ClickUrl;

                    if (clickedViewLicenseButton) {
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        return new ChessCompStompWithHacksLibrary.ViewLicenseTextDesktopFrame(this.globalState, this.sessionState, ChessCompStompWithHacksLibrary.Credits_DesignAndCoding_LicenseText.GetLicenseTextForBridge(), this);
                    }
                }

                if (this.selectedTab === ChessCompStompWithHacksLibrary.CreditsDesktopFrame.Tab.Images) {
                    var clickedViewLicenseButton1 = this.creditsImages.ProcessFrame(translatedMouse, translatedPreviousMouse, soundOutput);

                    if (clickedViewLicenseButton1) {
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        return new ChessCompStompWithHacksLibrary.ViewLicenseTextDesktopFrame(this.globalState, this.sessionState, ChessCompStompWithHacksLibrary.Credits_Images_LicenseText.GetLicenseTextForChessPieceImages(), this);
                    }
                }

                if (this.selectedTab === ChessCompStompWithHacksLibrary.CreditsDesktopFrame.Tab.Font) {
                    var clickedViewLicenseButton2 = this.creditsFont.ProcessFrame(translatedMouse, translatedPreviousMouse, soundOutput);

                    if (clickedViewLicenseButton2) {
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        return new ChessCompStompWithHacksLibrary.ViewLicenseTextDesktopFrame(this.globalState, this.sessionState, ChessCompStompWithHacksLibrary.Credits_Font_LicenseText.GetLicenseText(), this);
                    }
                }

                return this;
            },
            ProcessExtraTime: function (milliseconds) { },
            ProcessMusic: function () {
                this.globalState.ProcessMusic();
            },
            Render: function (displayOutput) {
                var $t;
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT, new DTLibrary.DTColor.ctor(223, 220, 217), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(422, 675, "Credits", ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt, DTLibrary.DTColor.Black());

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(20, 120, 959, 449, DTLibrary.DTColor.White(), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(20, 120, 960, 450, DTLibrary.DTColor.Black(), false);

                $t = Bridge.getEnumerator(this.tabButtons);
                try {
                    while ($t.moveNext()) {
                        var tabButton = $t.Current;
                        var backgroundColor;

                        if (tabButton.Tab === this.selectedTab) {
                            backgroundColor = DTLibrary.DTColor.White();
                        } else {
                            if (System.Nullable.hasValue(this.clickTab) && System.Nullable.getValue(this.clickTab) === tabButton.Tab) {
                                backgroundColor = ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(this.sessionState.GetColorTheme());
                            } else {
                                if (System.Nullable.hasValue(this.hoverTab) && System.Nullable.getValue(this.hoverTab) === tabButton.Tab) {
                                    backgroundColor = ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(this.sessionState.GetColorTheme());
                                } else {
                                    backgroundColor = new DTLibrary.DTColor.ctor(200, 200, 200);
                                }
                            }
                        }

                        displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(tabButton.X, tabButton.Y, ((tabButton.Width - 1) | 0), ((tabButton.Height - 1) | 0), backgroundColor, true);

                        displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(tabButton.X, tabButton.Y, tabButton.Width, tabButton.Height, DTLibrary.DTColor.Black(), false);

                        if (this.selectedTab === tabButton.Tab) {
                            displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(((tabButton.X + 1) | 0), ((tabButton.Y - 1) | 0), ((tabButton.Width - 2) | 0), 3, DTLibrary.DTColor.White(), true);
                        }

                        displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((tabButton.X + 10) | 0), ((((tabButton.Y + tabButton.Height) | 0) - 10) | 0), tabButton.TabName, ChessCompStompWithHacksLibrary.GameFont.GameFont18Pt, DTLibrary.DTColor.Black());
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                var translatedDisplay = new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, 20, 120);

                if (this.selectedTab === ChessCompStompWithHacksLibrary.CreditsDesktopFrame.Tab.DesignAndCoding) {
                    this.creditsDesignAndCoding.Render(translatedDisplay);
                }
                if (this.selectedTab === ChessCompStompWithHacksLibrary.CreditsDesktopFrame.Tab.Images) {
                    this.creditsImages.Render(translatedDisplay);
                }
                if (this.selectedTab === ChessCompStompWithHacksLibrary.CreditsDesktopFrame.Tab.Font) {
                    this.creditsFont.Render(translatedDisplay);
                }
                if (this.selectedTab === ChessCompStompWithHacksLibrary.CreditsDesktopFrame.Tab.Sound) {
                    ChessCompStompWithHacksLibrary.Credits_SoundDesktop.Render(translatedDisplay, 960, 450);
                }
                if (this.selectedTab === ChessCompStompWithHacksLibrary.CreditsDesktopFrame.Tab.Music) {
                    ChessCompStompWithHacksLibrary.Credits_MusicDesktop.Render(translatedDisplay, 960, 450);
                }

                this.backButton.Render(displayOutput);
            },
            RenderMusic: function (musicOutput) {
                this.globalState.RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.CreditsMobileFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        fields: {
            globalState: null,
            sessionState: null,
            tabButtons: null,
            selectedTab: 0,
            hoverTab: null,
            clickTab: null,
            backButton: null
        },
        alias: [
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState, display) {
                this.$initialize();
                this.globalState = globalState;
                this.sessionState = sessionState;

                this.selectedTab = ChessCompStompWithHacksLibrary.CreditsMobileFrame.Tab.DesignAndCoding;
                this.hoverTab = null;
                this.clickTab = null;

                this.tabButtons = new (System.Collections.Generic.List$1(ChessCompStompWithHacksLibrary.CreditsMobileFrame.TabButton)).ctor();
                this.tabButtons.add(new ChessCompStompWithHacksLibrary.CreditsMobileFrame.TabButton(20, 0, 234, 40, ChessCompStompWithHacksLibrary.CreditsMobileFrame.Tab.DesignAndCoding, "Design and coding"));
                this.tabButtons.add(new ChessCompStompWithHacksLibrary.CreditsMobileFrame.TabButton(254, 0, 103, 40, ChessCompStompWithHacksLibrary.CreditsMobileFrame.Tab.Images, "Images"));
                this.tabButtons.add(new ChessCompStompWithHacksLibrary.CreditsMobileFrame.TabButton(357, 0, 82, 40, ChessCompStompWithHacksLibrary.CreditsMobileFrame.Tab.Font, "Font"));
                this.tabButtons.add(new ChessCompStompWithHacksLibrary.CreditsMobileFrame.TabButton(439, 0, 96, 40, ChessCompStompWithHacksLibrary.CreditsMobileFrame.Tab.Sound, "Sound"));
                this.tabButtons.add(new ChessCompStompWithHacksLibrary.CreditsMobileFrame.TabButton(535, 0, 90, 40, ChessCompStompWithHacksLibrary.CreditsMobileFrame.Tab.Music, "Music"));

                this.backButton = new ChessCompStompWithHacksLibrary.Button(0, 0, 300, 125, new DTLibrary.DTColor.ctor(235, 235, 235), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Back", 99, 43, ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt, true);

                this.UpdateCoordinates(display);
            }
        },
        methods: {
            UpdateCoordinates: function (display) {
                var $t;
                this.backButton.SetX(((display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth() - 320) | 0));
                this.backButton.SetY(20);

                var tabButtonY;
                if (DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation(ChessCompStompWithHacksLibrary.GameImage, display)) {
                    tabButtonY = 569;
                } else {
                    tabButtonY = (display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenHeight() - 131) | 0;
                }

                $t = Bridge.getEnumerator(this.tabButtons);
                try {
                    while ($t.moveNext()) {
                        var tabButton = $t.Current;
                        tabButton.SetY(tabButtonY);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType === DTLibrary.DisplayType.Desktop) {
                    return new ChessCompStompWithHacksLibrary.CreditsDesktopFrame(this.globalState, this.sessionState);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                var $t;
                this.UpdateCoordinates(displayProcessing);

                var mouseX = mouseInput.DTLibrary$IMouse$GetX();
                var mouseY = mouseInput.DTLibrary$IMouse$GetY();

                this.hoverTab = null;
                $t = Bridge.getEnumerator(this.tabButtons);
                try {
                    while ($t.moveNext()) {
                        var tabButton = $t.Current;
                        if (tabButton.X <= mouseX && mouseX <= ((tabButton.X + tabButton.Width) | 0) && tabButton.Y <= mouseY && mouseY <= ((tabButton.Y + tabButton.Height) | 0)) {
                            this.hoverTab = tabButton.Tab;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                    if (this.hoverTab != null) {
                        this.clickTab = this.hoverTab;
                    }
                }

                if (this.clickTab != null && !mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                    if (System.Nullable.hasValue(this.hoverTab) && System.Nullable.getValue(this.hoverTab) === System.Nullable.getValue(this.clickTab)) {
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        this.selectedTab = System.Nullable.getValue(this.clickTab);
                    }

                    this.clickTab = null;
                }

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc)) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.TitleScreenMobileFrame(this.globalState, this.sessionState, displayProcessing);
                }

                var clickedBackButton = this.backButton.ProcessFrame(mouseInput, previousMouseInput);
                if (clickedBackButton) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.TitleScreenMobileFrame(this.globalState, this.sessionState, displayProcessing);
                }

                return this;
            },
            ProcessExtraTime: function (milliseconds) { },
            ProcessMusic: function () {
                this.globalState.ProcessMusic();
            },
            Render: function (displayOutput) {
                var $t;
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth(), displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight(), new DTLibrary.DTColor.ctor(223, 220, 217), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((((Bridge.Int.div(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth(), 2)) | 0) - 78) | 0), ((displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight() - 25) | 0), "Credits", ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt, DTLibrary.DTColor.Black());

                var tabWidth = (displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth() - 40) | 0;
                var tabHeight = (this.tabButtons.getItem(0).Y - 165) | 0;

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(20, 165, tabWidth, tabHeight, DTLibrary.DTColor.White(), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(20, 165, tabWidth, tabHeight, DTLibrary.DTColor.Black(), false);

                $t = Bridge.getEnumerator(this.tabButtons);
                try {
                    while ($t.moveNext()) {
                        var tabButton = $t.Current;
                        var backgroundColor;

                        if (tabButton.Tab === this.selectedTab) {
                            backgroundColor = DTLibrary.DTColor.White();
                        } else {
                            if (System.Nullable.hasValue(this.clickTab) && System.Nullable.getValue(this.clickTab) === tabButton.Tab) {
                                backgroundColor = ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(this.sessionState.GetColorTheme());
                            } else {
                                backgroundColor = new DTLibrary.DTColor.ctor(200, 200, 200);
                            }
                        }

                        displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(tabButton.X, tabButton.Y, ((tabButton.Width - 1) | 0), ((tabButton.Height - 1) | 0), backgroundColor, true);

                        displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(tabButton.X, tabButton.Y, tabButton.Width, tabButton.Height, DTLibrary.DTColor.Black(), false);

                        if (this.selectedTab === tabButton.Tab) {
                            displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(((tabButton.X + 1) | 0), ((tabButton.Y - 1) | 0), ((tabButton.Width - 2) | 0), 3, DTLibrary.DTColor.White(), true);
                        }

                        displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((tabButton.X + 10) | 0), ((((tabButton.Y + tabButton.Height) | 0) - 10) | 0), tabButton.TabName, ChessCompStompWithHacksLibrary.GameFont.GameFont18Pt, DTLibrary.DTColor.Black());
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                var translatedDisplay = new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, 20, 165);

                if (this.selectedTab === ChessCompStompWithHacksLibrary.CreditsMobileFrame.Tab.DesignAndCoding) {
                    ChessCompStompWithHacksLibrary.Credits_DesignAndCodingMobile.Render(translatedDisplay, this.globalState.BuildType, tabWidth, tabHeight);
                }
                if (this.selectedTab === ChessCompStompWithHacksLibrary.CreditsMobileFrame.Tab.Images) {
                    ChessCompStompWithHacksLibrary.Credits_ImagesMobile.Render(translatedDisplay, tabWidth, tabHeight);
                }
                if (this.selectedTab === ChessCompStompWithHacksLibrary.CreditsMobileFrame.Tab.Font) {
                    ChessCompStompWithHacksLibrary.Credits_FontMobile.Render(translatedDisplay, tabWidth, tabHeight);
                }
                if (this.selectedTab === ChessCompStompWithHacksLibrary.CreditsMobileFrame.Tab.Sound) {
                    ChessCompStompWithHacksLibrary.Credits_SoundMobile.Render(translatedDisplay, tabWidth, tabHeight);
                }
                if (this.selectedTab === ChessCompStompWithHacksLibrary.CreditsMobileFrame.Tab.Music) {
                    ChessCompStompWithHacksLibrary.Credits_MusicMobile.Render(translatedDisplay, tabWidth, tabHeight);
                }

                this.backButton.Render(displayOutput);
            },
            RenderMusic: function (musicOutput) {
                this.globalState.RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.DebugInfoFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        statics: {
            methods: {
                ProcessLine: function (str) {
                    if (str.length <= 50) {
                        return str;
                    }

                    return (str.substr(0, 50) || "") + "\n    " + (ChessCompStompWithHacksLibrary.DebugInfoFrame.ProcessLine(str.substr(50)) || "");
                }
            }
        },
        fields: {
            globalState: null,
            sessionState: null,
            displayType: 0,
            debugText: null
        },
        alias: [
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState, display, isMobileDisplayType) {
                this.$initialize();
                this.globalState = globalState;
                this.sessionState = sessionState;

                if (isMobileDisplayType) {
                    this.displayType = DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation(ChessCompStompWithHacksLibrary.GameImage, display) ? DTLibrary.DisplayType.MobileLandscape : DTLibrary.DisplayType.MobilePortrait;
                } else {
                    this.displayType = DTLibrary.DisplayType.Desktop;
                }

                this.debugText = "";
            }
        },
        methods: {
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessExtraTime: function (milliseconds) { },
            ProcessDisplayType: function (displayType, displayProcessing) {
                this.displayType = displayType;

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                var $t;
                var versionInfo = ChessCompStompWithHacksLibrary.VersionHistory.GetVersionInfo();

                this.debugText = "FPS: " + (DTLibrary.StringUtil.ToStringCultureInvariant(this.globalState.Fps) || "") + "\n";
                this.debugText = (this.debugText || "") + (("Version: " + (versionInfo.Version || "") + "\n") || "");
                this.debugText = (this.debugText || "") + (("Version guid: " + (versionInfo.AlphanumericVersionGuid || "") + "\n") || "");
                this.debugText = (this.debugText || "") + (("User agent: \n    " + (ChessCompStompWithHacksLibrary.DebugInfoFrame.ProcessLine(displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$Debug_GetBrowserInfo("(window.navigator.userAgent + '')")) || "") + "\n") || "");
                this.debugText = (this.debugText || "") + (("Screen width: " + (displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$Debug_GetBrowserInfo("(window.screen.width + '')") || "") + "\n") || "");
                this.debugText = (this.debugText || "") + (("Screen height: " + (displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$Debug_GetBrowserInfo("(window.screen.height + '')") || "") + "\n") || "");
                this.debugText = (this.debugText || "") + (("matchMedia('(pointer:fine)').matches: " + (displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$Debug_GetBrowserInfo("(window.matchMedia('(pointer:fine)').matches ? 'true' : 'false')") || "") + "\n") || "");

                var completedAchievements = "";
                var isFirst = true;
                $t = Bridge.getEnumerator(this.sessionState.GetCompletedAchievements());
                try {
                    while ($t.moveNext()) {
                        var completedAchievement = $t.Current;
                        if (isFirst) {
                            isFirst = false;
                        } else {
                            completedAchievements = (completedAchievements || "") + ", ";
                        }
                        completedAchievements = (completedAchievements || "") + (completedAchievement || "");
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.debugText = (this.debugText || "") + (("Completed achievements: \n    " + (ChessCompStompWithHacksLibrary.DebugInfoFrame.ProcessLine(completedAchievements) || "")) || "");

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc)) {
                    if (this.displayType === DTLibrary.DisplayType.Desktop) {
                        return new ChessCompStompWithHacksLibrary.TitleScreenDesktopFrame(this.globalState, this.sessionState);
                    } else {
                        return new ChessCompStompWithHacksLibrary.TitleScreenMobileFrame(this.globalState, this.sessionState, displayProcessing);
                    }
                }

                return this;
            },
            ProcessMusic: function () {
                this.globalState.ProcessMusic();
            },
            Render: function (displayOutput) {
                var windowHeight = this.displayType === DTLibrary.DisplayType.Desktop ? ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT : displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight();

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, this.displayType === DTLibrary.DisplayType.Desktop ? ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH : displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth(), windowHeight, new DTLibrary.DTColor.ctor(223, 220, 217), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(50, ((windowHeight - 50) | 0), this.debugText, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, DTLibrary.DTColor.Black());
            },
            RenderMusic: function (musicOutput) {
                this.globalState.RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackExplanationDesktopFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        statics: {
            fields: {
                CROSS_ICON_SCALING_FACTOR_SCALED: 0,
                HACK_EXPLANATION_PANEL_X: 0,
                HACK_EXPLANATION_PANEL_Y: 0,
                HACK_EXPLANATION_PANEL_WIDTH: 0,
                HACK_EXPLANATION_PANEL_HEIGHT: 0
            },
            ctors: {
                init: function () {
                    this.CROSS_ICON_SCALING_FACTOR_SCALED = 32;
                    this.HACK_EXPLANATION_PANEL_X = 50;
                    this.HACK_EXPLANATION_PANEL_Y = 50;
                    this.HACK_EXPLANATION_PANEL_WIDTH = 900;
                    this.HACK_EXPLANATION_PANEL_HEIGHT = 600;
                }
            }
        },
        fields: {
            globalState: null,
            sessionState: null,
            hack: 0,
            hackExplanation: null,
            underlyingFrame: null,
            crossIconHover: false,
            crossIconSelected: false
        },
        alias: [
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState, hack, underlyingFrame) {
                this.$initialize();
                var hasExtraPawnFirstHack = sessionState.GetResearchedHacks().contains(ChessCompStompWithHacksEngine.Hack.ExtraPawnFirst);

                this.globalState = globalState;
                this.sessionState = sessionState;
                this.hack = hack;
                this.hackExplanation = ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.GetHackExplanation(hack, sessionState.GetColorTheme(), globalState.Rng, hasExtraPawnFirstHack, globalState.Timer, globalState.ElapsedMicrosPerFrame);
                this.underlyingFrame = underlyingFrame;

                this.crossIconHover = false;
                this.crossIconSelected = false;
            }
        },
        methods: {
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType !== DTLibrary.DisplayType.Desktop) {
                    this.underlyingFrame = this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType(displayType, displayProcessing);
                    return new ChessCompStompWithHacksLibrary.HackExplanationMobileFrame(this.globalState, this.sessionState, this.hack, this.underlyingFrame);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) || !mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() || !mouseInput.DTLibrary$IMouse$IsRightMouseButtonPressed() && previousMouseInput.DTLibrary$IMouse$IsRightMouseButtonPressed()) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return this.underlyingFrame;
                }

                this.hackExplanation.ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$ProcessFrame(new DTLibrary.TranslatedMouse(mouseInput, -50, -50), new DTLibrary.TranslatedMouse(previousMouseInput, -50, -50), displayProcessing, this.globalState.ElapsedMicrosPerFrame);

                var crossImageWidth = (Bridge.Int.div(Bridge.Int.mul(displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetWidth(ChessCompStompWithHacksLibrary.GameImage.Cross), ChessCompStompWithHacksLibrary.HackExplanationDesktopFrame.CROSS_ICON_SCALING_FACTOR_SCALED), 128)) | 0;
                var crossImageHeight = (Bridge.Int.div(Bridge.Int.mul(displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetHeight(ChessCompStompWithHacksLibrary.GameImage.Cross), ChessCompStompWithHacksLibrary.HackExplanationDesktopFrame.CROSS_ICON_SCALING_FACTOR_SCALED), 128)) | 0;

                var mouseX = mouseInput.DTLibrary$IMouse$GetX();
                var mouseY = mouseInput.DTLibrary$IMouse$GetY();

                this.crossIconHover = ((950 - crossImageWidth) | 0) <= mouseX && mouseX <= 950 && ((650 - crossImageHeight) | 0) <= mouseY && mouseY <= 650;

                if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && this.crossIconHover) {
                    this.crossIconSelected = true;
                }

                if (this.crossIconSelected && !mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                    this.crossIconSelected = false;
                }

                return this;
            },
            ProcessExtraTime: function (milliseconds) {
                this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime(milliseconds);
            },
            ProcessMusic: function () {
                this.globalState.ProcessMusic();
            },
            Render: function (displayOutput) {
                this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render(displayOutput);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT, new DTLibrary.DTColor.$ctor1(0, 0, 0, 64), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(ChessCompStompWithHacksLibrary.HackExplanationDesktopFrame.HACK_EXPLANATION_PANEL_X, ChessCompStompWithHacksLibrary.HackExplanationDesktopFrame.HACK_EXPLANATION_PANEL_Y, 899, 599, new DTLibrary.DTColor.ctor(223, 220, 217), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(ChessCompStompWithHacksLibrary.HackExplanationDesktopFrame.HACK_EXPLANATION_PANEL_X, ChessCompStompWithHacksLibrary.HackExplanationDesktopFrame.HACK_EXPLANATION_PANEL_Y, ChessCompStompWithHacksLibrary.HackExplanationDesktopFrame.HACK_EXPLANATION_PANEL_WIDTH, ChessCompStompWithHacksLibrary.HackExplanationDesktopFrame.HACK_EXPLANATION_PANEL_HEIGHT, DTLibrary.DTColor.Black(), false);

                var translatedDisplayOutput = new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, ChessCompStompWithHacksLibrary.HackExplanationDesktopFrame.HACK_EXPLANATION_PANEL_X, ChessCompStompWithHacksLibrary.HackExplanationDesktopFrame.HACK_EXPLANATION_PANEL_Y);

                this.hackExplanation.ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$Render(translatedDisplayOutput, false);

                var crossImage = new ChessCompStompWithHacksLibrary.GameImage();

                if (this.crossIconSelected) {
                    crossImage = ChessCompStompWithHacksLibrary.GameImage.CrossSelected;
                } else {
                    if (this.crossIconHover) {
                        crossImage = ChessCompStompWithHacksLibrary.GameImage.CrossHover;
                    } else {
                        crossImage = ChessCompStompWithHacksLibrary.GameImage.Cross;
                    }
                }

                var crossImageWidth = (Bridge.Int.div(Bridge.Int.mul(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetWidth(crossImage), ChessCompStompWithHacksLibrary.HackExplanationDesktopFrame.CROSS_ICON_SCALING_FACTOR_SCALED), 128)) | 0;
                var crossImageHeight = (Bridge.Int.div(Bridge.Int.mul(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetHeight(crossImage), ChessCompStompWithHacksLibrary.HackExplanationDesktopFrame.CROSS_ICON_SCALING_FACTOR_SCALED), 128)) | 0;

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawImageRotatedClockwise$1(crossImage, ((950 - crossImageWidth) | 0), ((650 - crossImageHeight) | 0), 0, ChessCompStompWithHacksLibrary.HackExplanationDesktopFrame.CROSS_ICON_SCALING_FACTOR_SCALED);
            },
            RenderMusic: function (musicOutput) {
                this.globalState.RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackExplanationMobileFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        statics: {
            fields: {
                CROSS_ICON_SCALING_FACTOR_SCALED: 0,
                HACK_EXPLANATION_PANEL_WIDTH_LANDSCAPE: 0,
                HACK_EXPLANATION_PANEL_WIDTH_PORTRAIT: 0,
                HACK_EXPLANATION_PANEL_HEIGHT_LANDSCAPE: 0,
                HACK_EXPLANATION_PANEL_HEIGHT_PORTRAIT: 0
            },
            ctors: {
                init: function () {
                    this.CROSS_ICON_SCALING_FACTOR_SCALED = 64;
                    this.HACK_EXPLANATION_PANEL_WIDTH_LANDSCAPE = 900;
                    this.HACK_EXPLANATION_PANEL_WIDTH_PORTRAIT = 600;
                    this.HACK_EXPLANATION_PANEL_HEIGHT_LANDSCAPE = 600;
                    this.HACK_EXPLANATION_PANEL_HEIGHT_PORTRAIT = 900;
                }
            }
        },
        fields: {
            globalState: null,
            sessionState: null,
            hack: 0,
            hackExplanation: null,
            underlyingFrame: null,
            crossIconSelected: false
        },
        alias: [
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState, hack, underlyingFrame) {
                this.$initialize();
                var hasExtraPawnFirstHack = sessionState.GetResearchedHacks().contains(ChessCompStompWithHacksEngine.Hack.ExtraPawnFirst);

                this.globalState = globalState;
                this.sessionState = sessionState;
                this.hack = hack;
                this.hackExplanation = ChessCompStompWithHacksLibrary.HackExplanationFrameUtil.GetHackExplanation(hack, sessionState.GetColorTheme(), globalState.Rng, hasExtraPawnFirstHack, globalState.Timer, globalState.ElapsedMicrosPerFrame);
                this.underlyingFrame = underlyingFrame;

                this.crossIconSelected = false;
            }
        },
        methods: {
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType === DTLibrary.DisplayType.Desktop) {
                    this.underlyingFrame = this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType(displayType, displayProcessing);
                    return new ChessCompStompWithHacksLibrary.HackExplanationDesktopFrame(this.globalState, this.sessionState, this.hack, this.underlyingFrame);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                this.underlyingFrame = this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame(new DTLibrary.EmptyKeyboard(), new DTLibrary.EmptyMouse(), new DTLibrary.EmptyKeyboard(), new DTLibrary.EmptyMouse(), displayProcessing, soundOutput, musicProcessing);

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) || !mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() || !mouseInput.DTLibrary$IMouse$IsRightMouseButtonPressed() && previousMouseInput.DTLibrary$IMouse$IsRightMouseButtonPressed()) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return this.underlyingFrame;
                }

                var isLandscape = DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation(ChessCompStompWithHacksLibrary.GameImage, displayProcessing);

                var panelWidth = isLandscape ? ChessCompStompWithHacksLibrary.HackExplanationMobileFrame.HACK_EXPLANATION_PANEL_WIDTH_LANDSCAPE : ChessCompStompWithHacksLibrary.HackExplanationMobileFrame.HACK_EXPLANATION_PANEL_WIDTH_PORTRAIT;
                var panelHeight = isLandscape ? ChessCompStompWithHacksLibrary.HackExplanationMobileFrame.HACK_EXPLANATION_PANEL_HEIGHT_LANDSCAPE : ChessCompStompWithHacksLibrary.HackExplanationMobileFrame.HACK_EXPLANATION_PANEL_HEIGHT_PORTRAIT;

                var panelX = (Bridge.Int.div((((displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth() - panelWidth) | 0)), 2)) | 0;
                var panelY = (Bridge.Int.div((((displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenHeight() - panelHeight) | 0)), 2)) | 0;

                this.hackExplanation.ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$ProcessFrame(new DTLibrary.TranslatedMouse(mouseInput, ((-panelX) | 0), ((-panelY) | 0)), new DTLibrary.TranslatedMouse(previousMouseInput, ((-panelX) | 0), ((-panelY) | 0)), displayProcessing, this.globalState.ElapsedMicrosPerFrame);

                var crossImageWidth = (Bridge.Int.div(Bridge.Int.mul(displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetWidth(ChessCompStompWithHacksLibrary.GameImage.Cross), ChessCompStompWithHacksLibrary.HackExplanationMobileFrame.CROSS_ICON_SCALING_FACTOR_SCALED), 128)) | 0;
                var crossImageHeight = (Bridge.Int.div(Bridge.Int.mul(displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetHeight(ChessCompStompWithHacksLibrary.GameImage.Cross), ChessCompStompWithHacksLibrary.HackExplanationMobileFrame.CROSS_ICON_SCALING_FACTOR_SCALED), 128)) | 0;

                var mouseX = mouseInput.DTLibrary$IMouse$GetX();
                var mouseY = mouseInput.DTLibrary$IMouse$GetY();

                var crossIconHover = ((((panelX + panelWidth) | 0) - crossImageWidth) | 0) <= mouseX && mouseX <= ((panelX + panelWidth) | 0) && ((((panelY + panelHeight) | 0) - crossImageHeight) | 0) <= mouseY && mouseY <= ((panelY + panelHeight) | 0);

                if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && crossIconHover) {
                    this.crossIconSelected = true;
                }

                if (this.crossIconSelected && !mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                    this.crossIconSelected = false;
                }

                return this;
            },
            ProcessExtraTime: function (milliseconds) {
                this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime(milliseconds);
            },
            ProcessMusic: function () {
                this.globalState.ProcessMusic();
            },
            Render: function (displayOutput) {
                var isLandscape = DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput);

                var panelWidth = isLandscape ? ChessCompStompWithHacksLibrary.HackExplanationMobileFrame.HACK_EXPLANATION_PANEL_WIDTH_LANDSCAPE : ChessCompStompWithHacksLibrary.HackExplanationMobileFrame.HACK_EXPLANATION_PANEL_WIDTH_PORTRAIT;
                var panelHeight = isLandscape ? ChessCompStompWithHacksLibrary.HackExplanationMobileFrame.HACK_EXPLANATION_PANEL_HEIGHT_LANDSCAPE : ChessCompStompWithHacksLibrary.HackExplanationMobileFrame.HACK_EXPLANATION_PANEL_HEIGHT_PORTRAIT;

                var panelX = (Bridge.Int.div((((displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth() - panelWidth) | 0)), 2)) | 0;
                var panelY = (Bridge.Int.div((((displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight() - panelHeight) | 0)), 2)) | 0;

                this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render(displayOutput);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth(), displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight(), new DTLibrary.DTColor.$ctor1(0, 0, 0, 64), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(panelX, panelY, panelWidth, panelHeight, new DTLibrary.DTColor.ctor(223, 220, 217), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(panelX, panelY, panelWidth, panelHeight, DTLibrary.DTColor.Black(), false);

                var translatedDisplayOutput = new (DTLibrary.TranslatedDisplayOutput$2(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont))(displayOutput, panelX, panelY);

                this.hackExplanation.ChessCompStompWithHacksLibrary$HackExplanationFrameUtil$IHackExplanation$Render(translatedDisplayOutput, true);

                var crossImage = new ChessCompStompWithHacksLibrary.GameImage();

                if (this.crossIconSelected) {
                    crossImage = ChessCompStompWithHacksLibrary.GameImage.CrossSelected;
                } else {
                    crossImage = ChessCompStompWithHacksLibrary.GameImage.Cross;
                }

                var crossImageWidth = (Bridge.Int.div(Bridge.Int.mul(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetWidth(crossImage), ChessCompStompWithHacksLibrary.HackExplanationMobileFrame.CROSS_ICON_SCALING_FACTOR_SCALED), 128)) | 0;
                var crossImageHeight = (Bridge.Int.div(Bridge.Int.mul(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetHeight(crossImage), ChessCompStompWithHacksLibrary.HackExplanationMobileFrame.CROSS_ICON_SCALING_FACTOR_SCALED), 128)) | 0;

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawImageRotatedClockwise$1(crossImage, ((((panelX + panelWidth) | 0) - crossImageWidth) | 0), ((((panelY + panelHeight) | 0) - crossImageHeight) | 0), 0, ChessCompStompWithHacksLibrary.HackExplanationMobileFrame.CROSS_ICON_SCALING_FACTOR_SCALED);
            },
            RenderMusic: function (musicOutput) {
                this.globalState.RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackSelectionScreenDesktopFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        fields: {
            globalState: null,
            sessionState: null,
            settingsIcon: null,
            continueButton: null,
            hackSelectionScreenDisplay: null,
            numberOfHacksResearchedInPreviousFrame: 0
        },
        alias: [
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState) {
                this.$initialize();
                this.globalState = globalState;
                this.sessionState = sessionState;

                this.hackSelectionScreenDisplay = new ChessCompStompWithHacksLibrary.HackSelectionScreenDisplayDesktop(sessionState, true);

                this.settingsIcon = new ChessCompStompWithHacksLibrary.SettingsIcon(false);

                this.continueButton = new ChessCompStompWithHacksLibrary.Button(700, 50, 200, 80, new DTLibrary.DTColor.ctor(235, 235, 235), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Continue", 40, 27, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, false);

                this.numberOfHacksResearchedInPreviousFrame = sessionState.GetResearchedHacks().Count;
            }
        },
        methods: {
            ProcessExtraTime: function (milliseconds) { },
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType !== DTLibrary.DisplayType.Desktop) {
                    return new ChessCompStompWithHacksLibrary.HackSelectionScreenMobileFrame(this.globalState, this.sessionState, displayProcessing);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                if (this.globalState.DebugMode) {
                    if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.One) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.One)) {
                        this.sessionState.AddCompletedObjectives(function (_o1) {
                                _o1.add(ChessCompStompWithHacksEngine.Objective.DefeatComputer);
                                return _o1;
                            }(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.Objective)).ctor()));
                        this.sessionState.Debug_AddWin();
                        this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    }

                    if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Two) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Two)) {
                        this.sessionState.AddCompletedObjectives(function (_o2) {
                                _o2.add(ChessCompStompWithHacksEngine.Objective.DefeatComputer);
                                _o2.add(ChessCompStompWithHacksEngine.Objective.DefeatComputerByPlayingAtMost25Moves);
                                _o2.add(ChessCompStompWithHacksEngine.Objective.DefeatComputerWith5QueensOnTheBoard);
                                _o2.add(ChessCompStompWithHacksEngine.Objective.CheckmateUsingAKnight);
                                _o2.add(ChessCompStompWithHacksEngine.Objective.PromoteAPieceToABishop);
                                _o2.add(ChessCompStompWithHacksEngine.Objective.LaunchANuke);
                                return _o2;
                            }(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.Objective)).ctor()));
                        this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    }

                    if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Three) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Three)) {
                        this.sessionState.AddCompletedObjectives(function (_o3) {
                                _o3.add(ChessCompStompWithHacksEngine.Objective.DefeatComputer);
                                _o3.add(ChessCompStompWithHacksEngine.Objective.DefeatComputerByPlayingAtMost25Moves);
                                _o3.add(ChessCompStompWithHacksEngine.Objective.DefeatComputerWith5QueensOnTheBoard);
                                _o3.add(ChessCompStompWithHacksEngine.Objective.CheckmateUsingAKnight);
                                _o3.add(ChessCompStompWithHacksEngine.Objective.PromoteAPieceToABishop);
                                _o3.add(ChessCompStompWithHacksEngine.Objective.LaunchANuke);
                                _o3.add(ChessCompStompWithHacksEngine.Objective.WinFinalBattle);
                                return _o3;
                            }(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.Objective)).ctor()));
                        this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    }

                    if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Four) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Four)) {
                        this.sessionState.AddCompletedObjectives(function (_o4) {
                                _o4.add(ChessCompStompWithHacksEngine.Objective.PlayAStupidOpening);
                                _o4.add(ChessCompStompWithHacksEngine.Objective.NukeYourOwnPieces);
                                _o4.add(ChessCompStompWithHacksEngine.Objective.WinByCastlingVeryLongAndPromotingRookToQueen);
                                return _o4;
                            }(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.Objective)).ctor()));
                        this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    }
                }

                var rightClickedHack = this.hackSelectionScreenDisplay.ProcessFrame(mouseInput, previousMouseInput, displayProcessing, soundOutput);

                if (rightClickedHack != null) {
                    return new ChessCompStompWithHacksLibrary.HackExplanationDesktopFrame(this.globalState, this.sessionState, System.Nullable.getValue(rightClickedHack), this);
                }

                var clickedContinueButton = this.continueButton.ProcessFrame(mouseInput, previousMouseInput);
                if (clickedContinueButton) {
                    this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.ObjectivesScreenDesktopFrame(this.globalState, this.sessionState);
                }

                var settingsIconStatus = this.settingsIcon.ProcessFrame(mouseInput, previousMouseInput, false, displayProcessing);

                if (settingsIconStatus.HasClicked) {
                    this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.SettingsMenuDesktopFrame(this.globalState, this.sessionState, this, false, true);
                }

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc)) {
                    this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.SettingsMenuDesktopFrame(this.globalState, this.sessionState, this, false, true);
                }

                var researchedHacks = this.sessionState.GetResearchedHacks();

                if (researchedHacks.Count !== this.numberOfHacksResearchedInPreviousFrame) {
                    this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                }

                this.numberOfHacksResearchedInPreviousFrame = researchedHacks.Count;

                return this;
            },
            ProcessMusic: function () {
                this.globalState.ProcessMusic();
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT, new DTLibrary.DTColor.ctor(223, 220, 217), true);

                this.hackSelectionScreenDisplay.RenderButtons(displayOutput);

                this.settingsIcon.Render(displayOutput);

                this.continueButton.Render(displayOutput);

                this.hackSelectionScreenDisplay.RenderHoverDisplay(displayOutput);
            },
            RenderMusic: function (musicOutput) {
                this.globalState.RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.HackSelectionScreenMobileFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        fields: {
            globalState: null,
            sessionState: null,
            settingsIcon: null,
            continueButton: null,
            hackSelectionScreenDisplay: null,
            numberOfHacksResearchedInPreviousFrame: 0,
            hackSelectionScreenMobileTabInPreviousFrame: 0
        },
        alias: [
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState, display) {
                this.$initialize();
                this.globalState = globalState;
                this.sessionState = sessionState;

                this.hackSelectionScreenDisplay = new ChessCompStompWithHacksLibrary.HackSelectionScreenDisplayMobile(sessionState, true, display);

                this.settingsIcon = new ChessCompStompWithHacksLibrary.SettingsIcon(true);

                this.continueButton = new ChessCompStompWithHacksLibrary.Button(0, 0, 10, 80, new DTLibrary.DTColor.ctor(235, 235, 235), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Continue", 0, 27, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, true);

                this.numberOfHacksResearchedInPreviousFrame = sessionState.GetResearchedHacks().Count;
                this.hackSelectionScreenMobileTabInPreviousFrame = sessionState.GetHackSelectionScreenMobileTab();

                this.UpdateCoordinates(display);
            }
        },
        methods: {
            UpdateCoordinates: function (display) {
                if (DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation(ChessCompStompWithHacksLibrary.GameImage, display)) {
                    this.continueButton.SetX(((display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth() - 300) | 0));
                    this.continueButton.SetWidth(200);
                    this.continueButton.SetTextXOffset(40);
                } else {
                    this.continueButton.SetX(520);
                    this.continueButton.SetWidth(160);
                    this.continueButton.SetTextXOffset(20);
                }

                this.continueButton.SetY(50);
            },
            ProcessExtraTime: function (milliseconds) { },
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType === DTLibrary.DisplayType.Desktop) {
                    return new ChessCompStompWithHacksLibrary.HackSelectionScreenDesktopFrame(this.globalState, this.sessionState);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                this.UpdateCoordinates(displayProcessing);

                if (this.globalState.DebugMode) {
                    if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.One) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.One)) {
                        this.sessionState.AddCompletedObjectives(function (_o1) {
                                _o1.add(ChessCompStompWithHacksEngine.Objective.DefeatComputer);
                                return _o1;
                            }(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.Objective)).ctor()));
                        this.sessionState.Debug_AddWin();
                        this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    }

                    if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Two) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Two)) {
                        this.sessionState.AddCompletedObjectives(function (_o2) {
                                _o2.add(ChessCompStompWithHacksEngine.Objective.DefeatComputer);
                                _o2.add(ChessCompStompWithHacksEngine.Objective.DefeatComputerByPlayingAtMost25Moves);
                                _o2.add(ChessCompStompWithHacksEngine.Objective.DefeatComputerWith5QueensOnTheBoard);
                                _o2.add(ChessCompStompWithHacksEngine.Objective.CheckmateUsingAKnight);
                                _o2.add(ChessCompStompWithHacksEngine.Objective.PromoteAPieceToABishop);
                                _o2.add(ChessCompStompWithHacksEngine.Objective.LaunchANuke);
                                return _o2;
                            }(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.Objective)).ctor()));
                        this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    }

                    if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Three) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Three)) {
                        this.sessionState.AddCompletedObjectives(function (_o3) {
                                _o3.add(ChessCompStompWithHacksEngine.Objective.DefeatComputer);
                                _o3.add(ChessCompStompWithHacksEngine.Objective.DefeatComputerByPlayingAtMost25Moves);
                                _o3.add(ChessCompStompWithHacksEngine.Objective.DefeatComputerWith5QueensOnTheBoard);
                                _o3.add(ChessCompStompWithHacksEngine.Objective.CheckmateUsingAKnight);
                                _o3.add(ChessCompStompWithHacksEngine.Objective.PromoteAPieceToABishop);
                                _o3.add(ChessCompStompWithHacksEngine.Objective.LaunchANuke);
                                _o3.add(ChessCompStompWithHacksEngine.Objective.WinFinalBattle);
                                return _o3;
                            }(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.Objective)).ctor()));
                        this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    }

                    if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Four) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Four)) {
                        this.sessionState.AddCompletedObjectives(function (_o4) {
                                _o4.add(ChessCompStompWithHacksEngine.Objective.PlayAStupidOpening);
                                _o4.add(ChessCompStompWithHacksEngine.Objective.NukeYourOwnPieces);
                                _o4.add(ChessCompStompWithHacksEngine.Objective.WinByCastlingVeryLongAndPromotingRookToQueen);
                                return _o4;
                            }(new (System.Collections.Generic.HashSet$1(ChessCompStompWithHacksEngine.Objective)).ctor()));
                        this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    }
                }

                var clickedOnMoreDetailsHack = this.hackSelectionScreenDisplay.ProcessFrame(mouseInput, previousMouseInput, displayProcessing, soundOutput);

                if (clickedOnMoreDetailsHack != null) {
                    return new ChessCompStompWithHacksLibrary.HackExplanationMobileFrame(this.globalState, this.sessionState, System.Nullable.getValue(clickedOnMoreDetailsHack), this);
                }

                var clickedContinueButton = this.continueButton.ProcessFrame(mouseInput, previousMouseInput);
                if (clickedContinueButton) {
                    this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.ObjectivesScreenMobileFrame(this.globalState, this.sessionState, displayProcessing);
                }

                var settingsIconStatus = this.settingsIcon.ProcessFrame(mouseInput, previousMouseInput, false, displayProcessing);

                if (settingsIconStatus.HasClicked) {
                    this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.SettingsMenuMobileFrame(this.globalState, this.sessionState, this, false, displayProcessing, true);
                }

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc)) {
                    this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.SettingsMenuMobileFrame(this.globalState, this.sessionState, this, false, displayProcessing, true);
                }

                var researchedHacks = this.sessionState.GetResearchedHacks();

                if (researchedHacks.Count !== this.numberOfHacksResearchedInPreviousFrame) {
                    this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                }

                if (this.sessionState.GetHackSelectionScreenMobileTab() !== this.hackSelectionScreenMobileTabInPreviousFrame) {
                    this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                }

                this.numberOfHacksResearchedInPreviousFrame = researchedHacks.Count;
                this.hackSelectionScreenMobileTabInPreviousFrame = this.sessionState.GetHackSelectionScreenMobileTab();

                return this;
            },
            ProcessMusic: function () {
                this.globalState.ProcessMusic();
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth(), displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight(), new DTLibrary.DTColor.ctor(223, 220, 217), true);

                this.hackSelectionScreenDisplay.RenderButtons(displayOutput);

                this.settingsIcon.Render(displayOutput);

                this.continueButton.Render(displayOutput);
            },
            RenderMusic: function (musicOutput) {
                this.globalState.RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.InitialLoadingScreenFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        fields: {
            globalState: null,
            displayType: 0,
            loadingText: null
        },
        alias: [
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState) {
                this.$initialize();
                this.globalState = globalState;
                this.displayType = DTLibrary.DisplayType.Desktop;
                this.loadingText = "";
            }
        },
        methods: {
            ProcessExtraTime: function (milliseconds) { },
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessDisplayType: function (displayType, displayProcessing) {
                this.displayType = displayType;

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                var returnValue = this.GetNextFrameHelper(displayProcessing, soundOutput, musicProcessing);

                if (returnValue != null) {
                    return returnValue;
                }

                returnValue = this.GetNextFrameHelper(displayProcessing, soundOutput, musicProcessing);

                if (returnValue != null) {
                    return returnValue;
                }

                this.loadingText = "Loading...";

                if (this.globalState.DebugMode) {
                    this.loadingText = (this.loadingText || "") + "\n";
                    var numImageElementsToLoad = displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetNumTotalElementsToLoad();
                    if (System.Nullable.hasValue(numImageElementsToLoad)) {
                        this.loadingText = (this.loadingText || "") + (("Images: " + (DTLibrary.StringUtil.ToStringCultureInvariant(displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetNumElementsLoaded()) || "") + " / " + (DTLibrary.StringUtil.ToStringCultureInvariant(System.Nullable.getValue(numImageElementsToLoad)) || "") + "\n") || "");
                    } else {
                        this.loadingText = (this.loadingText || "") + "Images: pending \n";
                    }

                    var numSoundElementsToLoad = soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetNumTotalElementsToLoad();
                    if (System.Nullable.hasValue(numSoundElementsToLoad)) {
                        this.loadingText = (this.loadingText || "") + (("Sound: " + (DTLibrary.StringUtil.ToStringCultureInvariant(soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetNumElementsLoaded()) || "") + " / " + (DTLibrary.StringUtil.ToStringCultureInvariant(System.Nullable.getValue(numSoundElementsToLoad)) || "") + "\n") || "");
                    } else {
                        this.loadingText = (this.loadingText || "") + "Sound: pending \n";
                    }

                    var numMusicElementsToLoad = musicProcessing.DTLibrary$IMusicProcessing$GetNumTotalElementsToLoad();
                    if (System.Nullable.hasValue(numMusicElementsToLoad)) {
                        this.loadingText = (this.loadingText || "") + (("Music: " + (DTLibrary.StringUtil.ToStringCultureInvariant(musicProcessing.DTLibrary$IMusicProcessing$GetNumElementsLoaded()) || "") + " / " + (DTLibrary.StringUtil.ToStringCultureInvariant(System.Nullable.getValue(numMusicElementsToLoad)) || "")) || "");
                    } else {
                        this.loadingText = (this.loadingText || "") + "Music: pending";
                    }
                }

                return this;
            },
            GetNextFrameHelper: function (displayProcessing, soundOutput, musicProcessing) {
                var isDoneLoadingImages = displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$LoadImages();

                if (!isDoneLoadingImages) {
                    return null;
                }

                var isDoneLoadingSounds = soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$LoadSounds();

                if (!isDoneLoadingSounds) {
                    return null;
                }

                var isDoneLoadingMusic = musicProcessing.DTLibrary$IMusicProcessing$LoadMusic();

                if (!isDoneLoadingMusic) {
                    return null;
                }

                var sessionState = new ChessCompStompWithHacksLibrary.SessionState(this.globalState.Timer);

                this.globalState.LoadSessionState(sessionState);

                var soundVolume = this.globalState.LoadSoundVolume();
                if (System.Nullable.hasValue(soundVolume)) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$SetSoundVolumeImmediately(System.Nullable.getValue(soundVolume));
                }

                this.globalState.LoadMusicVolume();

                var music = ChessCompStompWithHacksLibrary.GameMusic.TitleScreen;
                this.globalState.MusicPlayer.SetMusic(music, 100);

                return ChessCompStompWithHacksLibrary.TitleScreenFrame.GetTitleScreenFrame(this.globalState, sessionState, this.displayType, displayProcessing);
            },
            ProcessMusic: function () { },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, this.displayType === DTLibrary.DisplayType.Desktop ? ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH : displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth(), this.displayType === DTLibrary.DisplayType.Desktop ? ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT : displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight(), new DTLibrary.DTColor.ctor(223, 220, 217), true);

                if (this.displayType === DTLibrary.DisplayType.Desktop) {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$TryDrawText(440, 400, this.loadingText, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());
                } else {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$TryDrawText(((((Bridge.Int.div(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth(), 2)) | 0) - 78) | 0), ((((Bridge.Int.div(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight(), 2)) | 0) + 100) | 0), this.loadingText, ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt, DTLibrary.DTColor.Black());
                }
            },
            RenderMusic: function (musicOutput) { }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.IntroScreenDesktopFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        statics: {
            fields: {
                TOTAL_TIME_TO_DISPLAY_TEXT: 0
            },
            ctors: {
                init: function () {
                    this.TOTAL_TIME_TO_DISPLAY_TEXT = 4000000;
                }
            }
        },
        fields: {
            globalState: null,
            sessionState: null,
            settingsIcon: null,
            continueButton: null,
            elapsedTimeMicros: 0
        },
        alias: [
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState) {
                this.$initialize();
                this.globalState = globalState;
                this.sessionState = sessionState;
                this.settingsIcon = new ChessCompStompWithHacksLibrary.SettingsIcon(false);
                this.elapsedTimeMicros = 0;

                var buttonWidth = 150;
                this.continueButton = new ChessCompStompWithHacksLibrary.Button(((Bridge.Int.div((((ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH - buttonWidth) | 0)), 2)) | 0), 300, buttonWidth, 50, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Begin", 38, 13, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, false);
            }
        },
        methods: {
            ProcessExtraTime: function (milliseconds) { },
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType !== DTLibrary.DisplayType.Desktop) {
                    return new ChessCompStompWithHacksLibrary.IntroScreenMobileFrame(this.globalState, this.sessionState, displayProcessing);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                this.elapsedTimeMicros = (this.elapsedTimeMicros + this.globalState.ElapsedMicrosPerFrame) | 0;
                if (this.elapsedTimeMicros >= ChessCompStompWithHacksLibrary.IntroScreenDesktopFrame.TOTAL_TIME_TO_DISPLAY_TEXT) {
                    this.elapsedTimeMicros = 4000001;
                }

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc)) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.SettingsMenuDesktopFrame(this.globalState, this.sessionState, this, false, true);
                }

                var settingsIconStatus = this.settingsIcon.ProcessFrame(mouseInput, previousMouseInput, false, displayProcessing);

                if (settingsIconStatus.HasClicked) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.SettingsMenuDesktopFrame(this.globalState, this.sessionState, this, false, true);
                }

                if (this.elapsedTimeMicros >= ChessCompStompWithHacksLibrary.IntroScreenDesktopFrame.TOTAL_TIME_TO_DISPLAY_TEXT) {
                    var clickedContinueButton = this.continueButton.ProcessFrame(mouseInput, previousMouseInput);
                    if (clickedContinueButton) {
                        this.sessionState.StartNewSession();
                        var music = ChessCompStompWithHacksLibrary.GameMusic.Level1;
                        this.globalState.MusicPlayer.SetMusic(music, 100);
                        this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        return new ChessCompStompWithHacksLibrary.HackSelectionScreenDesktopFrame(this.globalState, this.sessionState);
                    }
                }

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Space) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Space) || keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Enter) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Enter) || mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !settingsIconStatus.IsHover) {
                    if (this.elapsedTimeMicros <= ChessCompStompWithHacksLibrary.IntroScreenDesktopFrame.TOTAL_TIME_TO_DISPLAY_TEXT) {
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    }
                    this.elapsedTimeMicros = 4000001;
                }

                return this;
            },
            ProcessMusic: function () {
                this.globalState.ProcessMusic();
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT, new DTLibrary.DTColor.ctor(223, 220, 217), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(406, 675, "Welcome", ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt, DTLibrary.DTColor.Black());

                var text = "Today, you're playing against a Powerful Chess AI.\nYou are not a great chess player but you are an Elite Hacker.\nUse your elite hacking skills to defeat the AI.";

                var index;
                if (this.elapsedTimeMicros >= ChessCompStompWithHacksLibrary.IntroScreenDesktopFrame.TOTAL_TIME_TO_DISPLAY_TEXT) {
                    index = text.length;
                } else {
                    index = System.Int64.clip32(System.Int64(this.elapsedTimeMicros).mul(System.Int64(text.length)).div((System.Int64(4000000))));
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(100, 500, index >= text.length ? text : text.substr(0, index), ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                if (this.elapsedTimeMicros >= ChessCompStompWithHacksLibrary.IntroScreenDesktopFrame.TOTAL_TIME_TO_DISPLAY_TEXT) {
                    this.continueButton.Render(displayOutput);
                }

                this.settingsIcon.Render(displayOutput);
            },
            RenderMusic: function (musicOutput) {
                this.globalState.RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.IntroScreenMobileFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        statics: {
            fields: {
                TOTAL_TIME_TO_DISPLAY_TEXT: 0
            },
            ctors: {
                init: function () {
                    this.TOTAL_TIME_TO_DISPLAY_TEXT = 4000000;
                }
            }
        },
        fields: {
            globalState: null,
            sessionState: null,
            settingsIcon: null,
            continueButton: null,
            elapsedTimeMicros: 0
        },
        alias: [
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState, display) {
                this.$initialize();
                this.globalState = globalState;
                this.sessionState = sessionState;
                this.settingsIcon = new ChessCompStompWithHacksLibrary.SettingsIcon(true);
                this.elapsedTimeMicros = 0;

                this.continueButton = new ChessCompStompWithHacksLibrary.Button(0, 0, 10, 10, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Begin", 0, 0, ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt, true);

                this.UpdateCoordinates(display);
            }
        },
        methods: {
            UpdateCoordinates: function (display) {
                var isLandscape = DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation(ChessCompStompWithHacksLibrary.GameImage, display);

                var buttonWidth = 350;
                var buttonHeight = 100;
                this.continueButton.SetX(((((Bridge.Int.div(display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth(), 2)) | 0) - ((Bridge.Int.div(buttonWidth, 2)) | 0)) | 0));
                if (isLandscape) {
                    this.continueButton.SetY(190);
                } else {
                    this.continueButton.SetY(((display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenHeight() - 520) | 0));
                }

                this.continueButton.SetWidth(buttonWidth);
                this.continueButton.SetHeight(buttonHeight);

                this.continueButton.SetTextXOffset(118);
                this.continueButton.SetTextYOffset(29);
            },
            ProcessExtraTime: function (milliseconds) { },
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType === DTLibrary.DisplayType.Desktop) {
                    return new ChessCompStompWithHacksLibrary.IntroScreenDesktopFrame(this.globalState, this.sessionState);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                this.UpdateCoordinates(displayProcessing);

                this.elapsedTimeMicros = (this.elapsedTimeMicros + this.globalState.ElapsedMicrosPerFrame) | 0;
                if (this.elapsedTimeMicros >= ChessCompStompWithHacksLibrary.IntroScreenMobileFrame.TOTAL_TIME_TO_DISPLAY_TEXT) {
                    this.elapsedTimeMicros = 4000001;
                }

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc)) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.SettingsMenuMobileFrame(this.globalState, this.sessionState, this, false, displayProcessing, true);
                }

                var settingsIconStatus = this.settingsIcon.ProcessFrame(mouseInput, previousMouseInput, false, displayProcessing);

                if (settingsIconStatus.HasClicked) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.SettingsMenuMobileFrame(this.globalState, this.sessionState, this, false, displayProcessing, true);
                }

                if (this.elapsedTimeMicros >= ChessCompStompWithHacksLibrary.IntroScreenMobileFrame.TOTAL_TIME_TO_DISPLAY_TEXT) {
                    var clickedContinueButton = this.continueButton.ProcessFrame(mouseInput, previousMouseInput);
                    if (clickedContinueButton) {
                        this.sessionState.StartNewSession();
                        var music = ChessCompStompWithHacksLibrary.GameMusic.Level1;
                        this.globalState.MusicPlayer.SetMusic(music, 100);
                        this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        return new ChessCompStompWithHacksLibrary.HackSelectionScreenMobileFrame(this.globalState, this.sessionState, displayProcessing);
                    }
                }

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Space) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Space) || keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Enter) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Enter) || mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !settingsIconStatus.IsHover) {
                    if (this.elapsedTimeMicros <= ChessCompStompWithHacksLibrary.IntroScreenMobileFrame.TOTAL_TIME_TO_DISPLAY_TEXT) {
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    }
                    this.elapsedTimeMicros = 4000001;
                }

                return this;
            },
            ProcessMusic: function () {
                this.globalState.ProcessMusic();
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth(), displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight(), new DTLibrary.DTColor.ctor(223, 220, 217), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((((Bridge.Int.div(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth(), 2)) | 0) - 135) | 0), ((displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight() - 100) | 0), "Welcome", ChessCompStompWithHacksLibrary.GameFont.GameFont48Pt, DTLibrary.DTColor.Black());

                var text;

                var isLandscape = DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput);

                if (isLandscape) {
                    text = "Today, you're playing against a Powerful\nChess AI. You are not a great chess player\nbut you are an Elite Hacker. Use your elite\nhacking skills to defeat the AI.";
                } else {
                    text = "Today, you're playing against a Powerful\nChess AI. You are not a great chess player\nbut you are an Elite Hacker. Use your elite\nhacking skills to defeat the AI.";
                }

                var index;
                if (this.elapsedTimeMicros >= ChessCompStompWithHacksLibrary.IntroScreenMobileFrame.TOTAL_TIME_TO_DISPLAY_TEXT) {
                    index = text.length;
                } else {
                    index = System.Int64.clip32(System.Int64(this.elapsedTimeMicros).mul(System.Int64(text.length)).div((System.Int64(4000000))));
                }

                if (isLandscape) {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((Bridge.Int.div((((displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth() - 920) | 0)), 2)) | 0), 500, index >= text.length ? text : text.substr(0, index), ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt, DTLibrary.DTColor.Black());
                } else {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(50, ((displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight() - 220) | 0), index >= text.length ? text : text.substr(0, index), ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());
                }

                if (this.elapsedTimeMicros >= ChessCompStompWithHacksLibrary.IntroScreenMobileFrame.TOTAL_TIME_TO_DISPLAY_TEXT) {
                    this.continueButton.Render(displayOutput);
                }

                this.settingsIcon.Render(displayOutput);
            },
            RenderMusic: function (musicOutput) {
                this.globalState.RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ObjectivesScreenDesktopFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        fields: {
            globalState: null,
            sessionState: null,
            hasUnlockedFinalObjective: false,
            hasCompletedFinalObjective: false,
            settingsIcon: null,
            backToHackSelectionFrameButton: null,
            startNextGameButton_finalBattleNotUnlocked: null,
            startFinalBattleButton: null,
            startNonFinalBattleButton_finalBattleNotComplete: null,
            aiHackLevelSelectionButton: null,
            objectivesScreenDisplay: null
        },
        alias: [
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState) {
                this.$initialize();
                var objectiveDisplay = new ChessCompStompWithHacksLibrary.ObjectiveDisplay();

                this.objectivesScreenDisplay = new ChessCompStompWithHacksLibrary.ObjectivesScreenDisplayDesktop(sessionState);

                this.globalState = globalState;
                this.sessionState = sessionState;
                var completedObjectives = sessionState.GetCompletedObjectives();
                this.hasUnlockedFinalObjective = objectiveDisplay.HasUnlockedFinalObjective(completedObjectives);
                this.hasCompletedFinalObjective = completedObjectives.contains(ChessCompStompWithHacksEngine.Objective.WinFinalBattle);

                this.settingsIcon = new ChessCompStompWithHacksLibrary.SettingsIcon(false);

                this.backToHackSelectionFrameButton = new ChessCompStompWithHacksLibrary.Button(62, 70, 100, 40, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Back", 22, 9, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, false);

                this.startNextGameButton_finalBattleNotUnlocked = new ChessCompStompWithHacksLibrary.Button(300, 50, 400, 80, new DTLibrary.DTColor.ctor(235, 235, 235), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Start next round", 84, 27, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, false);

                this.startFinalBattleButton = new ChessCompStompWithHacksLibrary.Button(300, 80, 400, 80, new DTLibrary.DTColor.ctor(235, 235, 235), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Start the Final Battle!", 46, 27, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, false);

                this.startNonFinalBattleButton_finalBattleNotComplete = new ChessCompStompWithHacksLibrary.Button(300, 50, 400, 31, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Start a regular game", 83, 7, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, false);

                this.aiHackLevelSelectionButton = new ChessCompStompWithHacksLibrary.AIHackLevelSelectionButton(300, 50, 400, 31, "Start a regular game", 83, 7, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, sessionState.WillPlayerBeWhiteNextGame(), new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.Hack)).$ctor1(sessionState.GetResearchedHacks()), false);
            }
        },
        methods: {
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessExtraTime: function (milliseconds) { },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType !== DTLibrary.DisplayType.Desktop) {
                    return new ChessCompStompWithHacksLibrary.ObjectivesScreenMobileFrame(this.globalState, this.sessionState, displayProcessing);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                var clickedSettingsIcon = this.settingsIcon.ProcessFrame(mouseInput, previousMouseInput, false, displayProcessing).HasClicked;
                if (clickedSettingsIcon) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.SettingsMenuDesktopFrame(this.globalState, this.sessionState, this, false, true);
                }

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc)) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.SettingsMenuDesktopFrame(this.globalState, this.sessionState, this, false, true);
                }

                var clickedBackButton = this.backToHackSelectionFrameButton.ProcessFrame(mouseInput, previousMouseInput);
                if (clickedBackButton) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.HackSelectionScreenDesktopFrame(this.globalState, this.sessionState);
                }

                if (this.hasUnlockedFinalObjective) {
                    var clickedStartFinalBattleButton = this.startFinalBattleButton.ProcessFrame(mouseInput, previousMouseInput);
                    if (clickedStartFinalBattleButton) {
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        return this.sessionState.StartGame(true, this.globalState, null, displayProcessing, false);
                    }

                    if (this.hasCompletedFinalObjective) {
                        var selectedAIHackLevel = this.aiHackLevelSelectionButton.ProcessFrame(mouseInput, previousMouseInput);

                        if (System.Nullable.hasValue(selectedAIHackLevel)) {
                            soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                            return this.sessionState.StartGame(false, this.globalState, System.Nullable.getValue(selectedAIHackLevel), displayProcessing, false);
                        }
                    } else {
                        var clickedStartNonFinalBattleButton = this.startNonFinalBattleButton_finalBattleNotComplete.ProcessFrame(mouseInput, previousMouseInput);
                        if (clickedStartNonFinalBattleButton) {
                            soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                            return this.sessionState.StartGame(false, this.globalState, null, displayProcessing, false);
                        }
                    }
                } else {
                    var clickedStartGameButton = this.startNextGameButton_finalBattleNotUnlocked.ProcessFrame(mouseInput, previousMouseInput);
                    if (clickedStartGameButton) {
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        return this.sessionState.StartGame(false, this.globalState, null, displayProcessing, false);
                    }
                }

                return this;
            },
            ProcessMusic: function () {
                this.globalState.ProcessMusic();
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT, new DTLibrary.DTColor.ctor(223, 220, 217), true);

                this.settingsIcon.Render(displayOutput);

                this.backToHackSelectionFrameButton.Render(displayOutput);

                if (this.hasUnlockedFinalObjective) {
                    this.startFinalBattleButton.Render(displayOutput);
                    if (this.hasCompletedFinalObjective) {
                        this.aiHackLevelSelectionButton.RenderButton(displayOutput);
                    } else {
                        this.startNonFinalBattleButton_finalBattleNotComplete.Render(displayOutput);
                    }
                } else {
                    this.startNextGameButton_finalBattleNotUnlocked.Render(displayOutput);
                }

                this.objectivesScreenDisplay.Render(displayOutput);

                if (this.hasUnlockedFinalObjective && this.hasCompletedFinalObjective) {
                    this.aiHackLevelSelectionButton.RenderBoardPreview(displayOutput);
                }
            },
            RenderMusic: function (musicOutput) {
                this.globalState.RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ObjectivesScreenMobileFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        fields: {
            globalState: null,
            sessionState: null,
            hasUnlockedFinalObjective: false,
            hasCompletedFinalObjective: false,
            settingsIcon: null,
            backToHackSelectionFrameButton: null,
            startNextGameButton_finalBattleNotUnlocked: null,
            startFinalBattleButton: null,
            startNonFinalBattleButton_finalBattleNotComplete: null,
            aiHackLevelSelectionButton: null,
            objectivesScreenDisplay: null
        },
        alias: [
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState, display) {
                this.$initialize();
                var objectiveDisplay = new ChessCompStompWithHacksLibrary.ObjectiveDisplay();

                this.objectivesScreenDisplay = new ChessCompStompWithHacksLibrary.ObjectivesScreenDisplayMobile(sessionState);

                this.globalState = globalState;
                this.sessionState = sessionState;
                var completedObjectives = sessionState.GetCompletedObjectives();
                this.hasUnlockedFinalObjective = objectiveDisplay.HasUnlockedFinalObjective(completedObjectives);
                this.hasCompletedFinalObjective = completedObjectives.contains(ChessCompStompWithHacksEngine.Objective.WinFinalBattle);

                this.settingsIcon = new ChessCompStompWithHacksLibrary.SettingsIcon(true);

                this.backToHackSelectionFrameButton = new ChessCompStompWithHacksLibrary.Button(62, 70, 150, 60, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Back", 47, 19, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, true);

                this.startNextGameButton_finalBattleNotUnlocked = new ChessCompStompWithHacksLibrary.Button(0, 0, 400, 80, new DTLibrary.DTColor.ctor(235, 235, 235), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Start next round", 84, 27, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, true);

                this.startFinalBattleButton = new ChessCompStompWithHacksLibrary.Button(0, 0, 400, 80, new DTLibrary.DTColor.ctor(235, 235, 235), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Start the Final Battle!", 46, 27, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, true);

                this.startNonFinalBattleButton_finalBattleNotComplete = new ChessCompStompWithHacksLibrary.Button(0, 0, 400, 51, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Start a regular game", 83, 17, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, true);

                this.aiHackLevelSelectionButton = new ChessCompStompWithHacksLibrary.AIHackLevelSelectionButton(0, 0, 400, 51, "Start a regular game", 83, 17, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, sessionState.WillPlayerBeWhiteNextGame(), new (DTLibrary.DTImmutableList$1(ChessCompStompWithHacksEngine.Hack)).$ctor1(sessionState.GetResearchedHacks()), true);

                this.UpdateCoordinates(display);
            }
        },
        methods: {
            UpdateCoordinates: function (display) {
                var x = DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation(ChessCompStompWithHacksLibrary.GameImage, display) ? ((((Bridge.Int.div(display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth(), 2)) | 0) - 200) | 0) : 250;

                this.startNextGameButton_finalBattleNotUnlocked.SetX(x);
                this.startNextGameButton_finalBattleNotUnlocked.SetY(50);

                this.startFinalBattleButton.SetX(x);
                this.startFinalBattleButton.SetY(80);

                this.startNonFinalBattleButton_finalBattleNotComplete.SetX(x);
                this.startNonFinalBattleButton_finalBattleNotComplete.SetY(30);

                this.aiHackLevelSelectionButton.SetX(x);
                this.aiHackLevelSelectionButton.SetY(30);
            },
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessExtraTime: function (milliseconds) { },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType === DTLibrary.DisplayType.Desktop) {
                    return new ChessCompStompWithHacksLibrary.ObjectivesScreenDesktopFrame(this.globalState, this.sessionState);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                this.UpdateCoordinates(displayProcessing);

                var clickedSettingsIcon = this.settingsIcon.ProcessFrame(mouseInput, previousMouseInput, false, displayProcessing).HasClicked;
                if (clickedSettingsIcon) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.SettingsMenuMobileFrame(this.globalState, this.sessionState, this, false, displayProcessing, true);
                }

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc)) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.SettingsMenuMobileFrame(this.globalState, this.sessionState, this, false, displayProcessing, true);
                }

                var clickedBackButton = this.backToHackSelectionFrameButton.ProcessFrame(mouseInput, previousMouseInput);
                if (clickedBackButton) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.HackSelectionScreenMobileFrame(this.globalState, this.sessionState, displayProcessing);
                }

                if (this.hasUnlockedFinalObjective) {
                    var clickedStartFinalBattleButton = this.startFinalBattleButton.ProcessFrame(mouseInput, previousMouseInput);
                    if (clickedStartFinalBattleButton) {
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        return this.sessionState.StartGame(true, this.globalState, null, displayProcessing, true);
                    }

                    if (this.hasCompletedFinalObjective) {
                        var selectedAIHackLevel = this.aiHackLevelSelectionButton.ProcessFrame(mouseInput, previousMouseInput);

                        if (System.Nullable.hasValue(selectedAIHackLevel)) {
                            soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                            return this.sessionState.StartGame(false, this.globalState, System.Nullable.getValue(selectedAIHackLevel), displayProcessing, true);
                        }
                    } else {
                        var clickedStartNonFinalBattleButton = this.startNonFinalBattleButton_finalBattleNotComplete.ProcessFrame(mouseInput, previousMouseInput);
                        if (clickedStartNonFinalBattleButton) {
                            soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                            return this.sessionState.StartGame(false, this.globalState, null, displayProcessing, true);
                        }
                    }
                } else {
                    var clickedStartGameButton = this.startNextGameButton_finalBattleNotUnlocked.ProcessFrame(mouseInput, previousMouseInput);
                    if (clickedStartGameButton) {
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        return this.sessionState.StartGame(false, this.globalState, null, displayProcessing, true);
                    }
                }

                return this;
            },
            ProcessMusic: function () {
                this.globalState.ProcessMusic();
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth(), displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight(), new DTLibrary.DTColor.ctor(223, 220, 217), true);

                this.settingsIcon.Render(displayOutput);

                this.backToHackSelectionFrameButton.Render(displayOutput);

                if (this.hasUnlockedFinalObjective) {
                    this.startFinalBattleButton.Render(displayOutput);
                    if (this.hasCompletedFinalObjective) {
                        this.aiHackLevelSelectionButton.RenderButton(displayOutput);
                    } else {
                        this.startNonFinalBattleButton_finalBattleNotComplete.Render(displayOutput);
                    }
                } else {
                    this.startNextGameButton_finalBattleNotUnlocked.Render(displayOutput);
                }

                this.objectivesScreenDisplay.Render(displayOutput);

                if (this.hasUnlockedFinalObjective && this.hasCompletedFinalObjective) {
                    this.aiHackLevelSelectionButton.RenderBoardPreview(displayOutput);
                }
            },
            RenderMusic: function (musicOutput) {
                this.globalState.RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ResignConfirmationDesktopFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        statics: {
            fields: {
                PANEL_WIDTH: 0,
                PANEL_HEIGHT: 0,
                PANEL_X: 0,
                PANEL_Y: 0
            },
            ctors: {
                init: function () {
                    this.PANEL_WIDTH = 480;
                    this.PANEL_HEIGHT = 150;
                    this.PANEL_X = 260;
                    this.PANEL_Y = 275;
                }
            }
        },
        fields: {
            globalState: null,
            sessionState: null,
            underlyingFrame: null,
            confirmButton: null,
            cancelButton: null,
            renderUnderlyingFrame: false
        },
        alias: [
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState, underlyingFrame, shouldRenderUnderlyingFrame) {
                this.$initialize();
                this.globalState = globalState;
                this.sessionState = sessionState;
                this.underlyingFrame = underlyingFrame;

                this.renderUnderlyingFrame = shouldRenderUnderlyingFrame;

                var buttonWidth = 150;
                var buttonHeight = 40;

                this.confirmButton = new ChessCompStompWithHacksLibrary.Button(340, 295, buttonWidth, buttonHeight, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Yes", 47, 8, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, false);

                this.cancelButton = new ChessCompStompWithHacksLibrary.Button(510, 295, buttonWidth, buttonHeight, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "No", 55, 8, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, false);
            }
        },
        methods: {
            ProcessExtraTime: function (milliseconds) {
                var gameLogic = this.sessionState.GetGameLogic();
                if (gameLogic != null) {
                    gameLogic.ProcessExtraTime(milliseconds);
                }
            },
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType !== DTLibrary.DisplayType.Desktop) {
                    this.underlyingFrame = this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType(displayType, displayProcessing);

                    return new ChessCompStompWithHacksLibrary.ResignConfirmationMobileFrame(this.globalState, this.sessionState, this.underlyingFrame, displayProcessing, false);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc)) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return this.underlyingFrame;
                }

                var isConfirmClicked = this.confirmButton.ProcessFrame(mouseInput, previousMouseInput);

                var isCancelClicked = this.cancelButton.ProcessFrame(mouseInput, previousMouseInput);

                if (isConfirmClicked) {
                    this.sessionState.CompleteGame(false);
                    this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.HackSelectionScreenDesktopFrame(this.globalState, this.sessionState);
                }

                if (isCancelClicked) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return this.underlyingFrame;
                }

                return this;
            },
            ProcessMusic: function () {
                this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic();
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT, new DTLibrary.DTColor.ctor(223, 220, 217), true);

                if (this.renderUnderlyingFrame) {
                    this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render(displayOutput);
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT, new DTLibrary.DTColor.$ctor1(0, 0, 0, 64), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(ChessCompStompWithHacksLibrary.ResignConfirmationDesktopFrame.PANEL_X, ChessCompStompWithHacksLibrary.ResignConfirmationDesktopFrame.PANEL_Y, ChessCompStompWithHacksLibrary.ResignConfirmationDesktopFrame.PANEL_WIDTH, ChessCompStompWithHacksLibrary.ResignConfirmationDesktopFrame.PANEL_HEIGHT, DTLibrary.DTColor.White(), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(ChessCompStompWithHacksLibrary.ResignConfirmationDesktopFrame.PANEL_X, ChessCompStompWithHacksLibrary.ResignConfirmationDesktopFrame.PANEL_Y, ChessCompStompWithHacksLibrary.ResignConfirmationDesktopFrame.PANEL_WIDTH, ChessCompStompWithHacksLibrary.ResignConfirmationDesktopFrame.PANEL_HEIGHT, DTLibrary.DTColor.Black(), false);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(276, 397, "Are you sure you want to resign?", ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());

                this.confirmButton.Render(displayOutput);
                this.cancelButton.Render(displayOutput);
            },
            RenderMusic: function (musicOutput) {
                this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ResignConfirmationMobileFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        fields: {
            globalState: null,
            sessionState: null,
            underlyingFrame: null,
            confirmButton: null,
            cancelButton: null,
            panelX: 0,
            panelY: 0,
            panelWidth: 0,
            panelHeight: 0,
            widthOfUnderlyingFrame: 0,
            heightOfUnderlyingFrame: 0,
            renderUnderlyingFrame: false
        },
        alias: [
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState, underlyingFrame, display, shouldRenderUnderlyingFrameInitially) {
                this.$initialize();
                this.widthOfUnderlyingFrame = display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth();
                this.heightOfUnderlyingFrame = display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenHeight();
                this.renderUnderlyingFrame = shouldRenderUnderlyingFrameInitially;

                this.globalState = globalState;
                this.sessionState = sessionState;
                this.underlyingFrame = underlyingFrame;

                this.confirmButton = new ChessCompStompWithHacksLibrary.Button(0, 0, 10, 10, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Yes", 0, 0, ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt, true);

                this.cancelButton = new ChessCompStompWithHacksLibrary.Button(0, 0, 10, 10, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "No", 0, 0, ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt, true);

                this.UpdateCoordinates(display);
            }
        },
        methods: {
            UpdateCoordinates: function (display) {
                var isLandscape = DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation(ChessCompStompWithHacksLibrary.GameImage, display);

                this.panelWidth = isLandscape ? 800 : 600;
                this.panelHeight = isLandscape ? 500 : 400;
                this.panelX = (Bridge.Int.div((((display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth() - this.panelWidth) | 0)), 2)) | 0;
                this.panelY = (Bridge.Int.div((((display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenHeight() - this.panelHeight) | 0)), 2)) | 0;

                this.confirmButton.SetX(((this.panelX + 50) | 0));
                this.confirmButton.SetY(((this.panelY + 50) | 0));

                var buttonWidth = (Bridge.Int.div((((((((this.panelWidth - 50) | 0) - 50) | 0) - 50) | 0)), 2)) | 0;
                var buttonHeight = 100;

                this.confirmButton.SetWidth(buttonWidth);
                this.confirmButton.SetHeight(buttonHeight);

                this.confirmButton.SetTextXOffset(((((Bridge.Int.div(buttonWidth, 2)) | 0) - 38) | 0));
                this.confirmButton.SetTextYOffset(30);

                this.cancelButton.SetX(((((((this.panelX + 50) | 0) + buttonWidth) | 0) + 50) | 0));
                this.cancelButton.SetY(((this.panelY + 50) | 0));

                this.cancelButton.SetWidth(buttonWidth);
                this.cancelButton.SetHeight(buttonHeight);

                this.cancelButton.SetTextXOffset(((((Bridge.Int.div(buttonWidth, 2)) | 0) - 26) | 0));
                this.cancelButton.SetTextYOffset(30);
            },
            ProcessExtraTime: function (milliseconds) {
                var gameLogic = this.sessionState.GetGameLogic();
                if (gameLogic != null) {
                    gameLogic.ProcessExtraTime(milliseconds);
                }
            },
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType === DTLibrary.DisplayType.Desktop) {
                    this.underlyingFrame = this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType(displayType, displayProcessing);

                    return new ChessCompStompWithHacksLibrary.ResignConfirmationDesktopFrame(this.globalState, this.sessionState, this.underlyingFrame, false);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                this.UpdateCoordinates(displayProcessing);

                if (displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth() !== this.widthOfUnderlyingFrame) {
                    this.renderUnderlyingFrame = false;
                }
                if (displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenHeight() !== this.heightOfUnderlyingFrame) {
                    this.renderUnderlyingFrame = false;
                }

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc)) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return this.underlyingFrame;
                }

                var isConfirmClicked = this.confirmButton.ProcessFrame(mouseInput, previousMouseInput);

                var isCancelClicked = this.cancelButton.ProcessFrame(mouseInput, previousMouseInput);

                if (isConfirmClicked) {
                    this.sessionState.CompleteGame(false);
                    this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.HackSelectionScreenMobileFrame(this.globalState, this.sessionState, displayProcessing);
                }

                if (isCancelClicked) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return this.underlyingFrame;
                }

                return this;
            },
            ProcessMusic: function () {
                this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic();
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth(), displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight(), new DTLibrary.DTColor.ctor(223, 220, 217), true);

                if (this.renderUnderlyingFrame) {
                    this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render(displayOutput);
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth(), displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight(), new DTLibrary.DTColor.$ctor1(0, 0, 0, 64), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(this.panelX, this.panelY, this.panelWidth, this.panelHeight, DTLibrary.DTColor.White(), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(this.panelX, this.panelY, this.panelWidth, this.panelHeight, DTLibrary.DTColor.Black(), false);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((this.panelX + 27) | 0), ((((this.panelY + this.panelHeight) | 0) - 27) | 0), DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput) ? "Are you sure you want to resign?" : "Are you sure you want to \nresign?", ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt, DTLibrary.DTColor.Black());

                this.confirmButton.Render(displayOutput);
                this.cancelButton.Render(displayOutput);
            },
            RenderMusic: function (musicOutput) {
                this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.SettingsMenuDesktopFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        statics: {
            fields: {
                PANEL_WIDTH: 0,
                PANEL_HEIGHT_WITH_PAUSE: 0,
                PANEL_HEIGHT_WITHOUT_PAUSE: 0,
                PANEL_X: 0,
                PANEL_Y_WITH_PAUSE: 0,
                PANEL_Y_WITHOUT_PAUSE: 0,
                BUTTON_WIDTH: 0,
                BUTTON_HEIGHT: 0
            },
            ctors: {
                init: function () {
                    this.PANEL_WIDTH = 300;
                    this.PANEL_HEIGHT_WITH_PAUSE = 380;
                    this.PANEL_HEIGHT_WITHOUT_PAUSE = 263;
                    this.PANEL_X = 350;
                    this.PANEL_Y_WITH_PAUSE = 160;
                    this.PANEL_Y_WITHOUT_PAUSE = 218;
                    this.BUTTON_WIDTH = 240;
                    this.BUTTON_HEIGHT = 40;
                }
            }
        },
        fields: {
            globalState: null,
            sessionState: null,
            soundAndMusicVolumePicker: null,
            underlyingFrame: null,
            continueButton: null,
            backToTitleScreenButton: null,
            showPausedText: false,
            panelY: 0,
            panelHeight: 0,
            renderUnderlyingFrame: false
        },
        alias: [
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState, underlyingFrame, showPausedText, shouldRenderUnderlyingFrame) {
                this.$initialize();
                this.globalState = globalState;
                this.sessionState = sessionState;
                this.soundAndMusicVolumePicker = null;
                this.underlyingFrame = underlyingFrame;

                this.renderUnderlyingFrame = shouldRenderUnderlyingFrame;

                this.showPausedText = showPausedText;

                this.panelY = showPausedText ? ChessCompStompWithHacksLibrary.SettingsMenuDesktopFrame.PANEL_Y_WITH_PAUSE : ChessCompStompWithHacksLibrary.SettingsMenuDesktopFrame.PANEL_Y_WITHOUT_PAUSE;
                this.panelHeight = showPausedText ? ChessCompStompWithHacksLibrary.SettingsMenuDesktopFrame.PANEL_HEIGHT_WITH_PAUSE : ChessCompStompWithHacksLibrary.SettingsMenuDesktopFrame.PANEL_HEIGHT_WITHOUT_PAUSE;

                this.continueButton = new ChessCompStompWithHacksLibrary.Button(380, ((this.panelY + 80) | 0), ChessCompStompWithHacksLibrary.SettingsMenuDesktopFrame.BUTTON_WIDTH, ChessCompStompWithHacksLibrary.SettingsMenuDesktopFrame.BUTTON_HEIGHT, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Continue", 76, 12, ChessCompStompWithHacksLibrary.GameFont.GameFont14Pt, false);

                this.backToTitleScreenButton = new ChessCompStompWithHacksLibrary.Button(380, ((this.panelY + 20) | 0), ChessCompStompWithHacksLibrary.SettingsMenuDesktopFrame.BUTTON_WIDTH, ChessCompStompWithHacksLibrary.SettingsMenuDesktopFrame.BUTTON_HEIGHT, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Return to title screen", 11, 12, ChessCompStompWithHacksLibrary.GameFont.GameFont14Pt, false);
            }
        },
        methods: {
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessExtraTime: function (milliseconds) {
                this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime(milliseconds);
            },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType !== DTLibrary.DisplayType.Desktop) {
                    this.underlyingFrame = this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType(displayType, displayProcessing);

                    return new ChessCompStompWithHacksLibrary.SettingsMenuMobileFrame(this.globalState, this.sessionState, this.underlyingFrame, this.showPausedText, displayProcessing, false);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                if (this.soundAndMusicVolumePicker == null) {
                    this.soundAndMusicVolumePicker = new ChessCompStompWithHacksLibrary.SoundAndMusicVolumePicker(380, ((this.panelY + (this.showPausedText ? 170 : 140)) | 0), soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume(), this.globalState.MusicVolume, this.globalState.ElapsedMicrosPerFrame, 1);
                }

                this.soundAndMusicVolumePicker.ProcessFrame(mouseInput, previousMouseInput);
                soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$SetSoundVolume(this.soundAndMusicVolumePicker.GetCurrentSoundVolume());
                this.globalState.MusicVolume = this.soundAndMusicVolumePicker.GetCurrentMusicVolume();

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc)) {
                    this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return this.underlyingFrame;
                }

                var clickedContinueButton = this.continueButton.ProcessFrame(mouseInput, previousMouseInput);

                if (clickedContinueButton) {
                    this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return this.underlyingFrame;
                }

                var clickedBackToTitleScreenButton = this.backToTitleScreenButton.ProcessFrame(mouseInput, previousMouseInput);

                if (clickedBackToTitleScreenButton) {
                    this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.TitleScreenDesktopFrame(this.globalState, this.sessionState);
                }

                if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                    var mouseX = mouseInput.DTLibrary$IMouse$GetX();
                    var mouseY = mouseInput.DTLibrary$IMouse$GetY();

                    if (mouseX < ChessCompStompWithHacksLibrary.SettingsMenuDesktopFrame.PANEL_X || mouseX > 650 || mouseY < this.panelY || mouseY > ((this.panelY + this.panelHeight) | 0)) {
                        this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        return this.underlyingFrame;
                    }
                }

                return this;
            },
            ProcessMusic: function () {
                this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic();
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT, new DTLibrary.DTColor.ctor(223, 220, 217), true);

                if (this.renderUnderlyingFrame) {
                    this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render(displayOutput);
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT, new DTLibrary.DTColor.$ctor1(0, 0, 0, 64), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(ChessCompStompWithHacksLibrary.SettingsMenuDesktopFrame.PANEL_X, this.panelY, 299, ((this.panelHeight - 1) | 0), DTLibrary.DTColor.White(), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(ChessCompStompWithHacksLibrary.SettingsMenuDesktopFrame.PANEL_X, this.panelY, ChessCompStompWithHacksLibrary.SettingsMenuDesktopFrame.PANEL_WIDTH, this.panelHeight, DTLibrary.DTColor.Black(), false);

                if (this.soundAndMusicVolumePicker != null) {
                    this.soundAndMusicVolumePicker.Render(displayOutput);
                }

                if (this.showPausedText) {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(422, ((this.panelY + 362) | 0), "Paused", ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt, DTLibrary.DTColor.Black());
                }

                this.continueButton.Render(displayOutput);
                this.backToTitleScreenButton.Render(displayOutput);
            },
            RenderMusic: function (musicOutput) {
                this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.SettingsMenuMobileFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        statics: {
            fields: {
                BUTTON_WIDTH: 0,
                BUTTON_HEIGHT: 0
            },
            ctors: {
                init: function () {
                    this.BUTTON_WIDTH = 400;
                    this.BUTTON_HEIGHT = 120;
                }
            }
        },
        fields: {
            globalState: null,
            sessionState: null,
            soundAndMusicVolumePicker: null,
            underlyingFrame: null,
            continueButton: null,
            backToTitleScreenButton: null,
            showPausedText: false,
            panelX: 0,
            panelY: 0,
            panelWidth: 0,
            panelHeight: 0,
            widthOfUnderlyingFrame: 0,
            heightOfUnderlyingFrame: 0,
            renderUnderlyingFrame: false
        },
        alias: [
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState, underlyingFrame, showPausedText, display, shouldRenderUnderlyingFrameInitially) {
                this.$initialize();
                this.widthOfUnderlyingFrame = display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth();
                this.heightOfUnderlyingFrame = display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenHeight();
                this.renderUnderlyingFrame = shouldRenderUnderlyingFrameInitially;

                this.globalState = globalState;
                this.sessionState = sessionState;
                this.soundAndMusicVolumePicker = null;
                this.underlyingFrame = underlyingFrame;

                this.showPausedText = showPausedText;

                this.continueButton = new ChessCompStompWithHacksLibrary.Button(0, 0, ChessCompStompWithHacksLibrary.SettingsMenuMobileFrame.BUTTON_WIDTH, ChessCompStompWithHacksLibrary.SettingsMenuMobileFrame.BUTTON_HEIGHT, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Continue", 140, 48, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, true);

                this.backToTitleScreenButton = new ChessCompStompWithHacksLibrary.Button(0, 0, ChessCompStompWithHacksLibrary.SettingsMenuMobileFrame.BUTTON_WIDTH, ChessCompStompWithHacksLibrary.SettingsMenuMobileFrame.BUTTON_HEIGHT, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Return to title screen", 48, 48, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, true);

                this.UpdateCoordinates(display);
            }
        },
        methods: {
            UpdateCoordinates: function (display) {
                if (DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation(ChessCompStompWithHacksLibrary.GameImage, display)) {
                    this.panelWidth = 600;
                    this.panelHeight = this.showPausedText ? 582 : 520;

                    this.panelX = (Bridge.Int.div((((display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth() - this.panelWidth) | 0)), 2)) | 0;

                    this.panelY = (Bridge.Int.div((((display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenHeight() - this.panelHeight) | 0)), 2)) | 0;

                    this.continueButton.SetX(((Bridge.Int.div((((display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth() - ChessCompStompWithHacksLibrary.SettingsMenuMobileFrame.BUTTON_WIDTH) | 0)), 2)) | 0));
                    this.continueButton.SetY(((this.panelY + 160) | 0));

                    this.backToTitleScreenButton.SetX(((Bridge.Int.div((((display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth() - ChessCompStompWithHacksLibrary.SettingsMenuMobileFrame.BUTTON_WIDTH) | 0)), 2)) | 0));
                    this.backToTitleScreenButton.SetY(((this.panelY + 20) | 0));

                    if (this.soundAndMusicVolumePicker != null) {
                        this.soundAndMusicVolumePicker.SetX(((((Bridge.Int.div(display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth(), 2)) | 0) - 180) | 0));
                        this.soundAndMusicVolumePicker.SetY(((this.panelY + 300) | 0));
                    }
                } else {
                    this.panelWidth = 600;
                    this.panelHeight = this.showPausedText ? 732 : 640;

                    this.panelX = (Bridge.Int.div((((display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth() - this.panelWidth) | 0)), 2)) | 0;

                    this.panelY = (Bridge.Int.div((((display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenHeight() - this.panelHeight) | 0)), 2)) | 0;

                    this.continueButton.SetX(((Bridge.Int.div((((display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth() - ChessCompStompWithHacksLibrary.SettingsMenuMobileFrame.BUTTON_WIDTH) | 0)), 2)) | 0));
                    this.continueButton.SetY(((this.panelY + 220) | 0));

                    this.backToTitleScreenButton.SetX(((Bridge.Int.div((((display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth() - ChessCompStompWithHacksLibrary.SettingsMenuMobileFrame.BUTTON_WIDTH) | 0)), 2)) | 0));
                    this.backToTitleScreenButton.SetY(((this.panelY + 50) | 0));

                    if (this.soundAndMusicVolumePicker != null) {
                        this.soundAndMusicVolumePicker.SetX(((((Bridge.Int.div(display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth(), 2)) | 0) - 180) | 0));
                        this.soundAndMusicVolumePicker.SetY(((this.panelY + 390) | 0));
                    }
                }
            },
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessExtraTime: function (milliseconds) {
                this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime(milliseconds);
            },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType === DTLibrary.DisplayType.Desktop) {
                    this.underlyingFrame = this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType(displayType, displayProcessing);

                    return new ChessCompStompWithHacksLibrary.SettingsMenuDesktopFrame(this.globalState, this.sessionState, this.underlyingFrame, this.showPausedText, false);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                if (this.soundAndMusicVolumePicker == null) {
                    this.soundAndMusicVolumePicker = new ChessCompStompWithHacksLibrary.SoundAndMusicVolumePicker(0, 0, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume(), this.globalState.MusicVolume, this.globalState.ElapsedMicrosPerFrame, 2);
                }

                this.UpdateCoordinates(displayProcessing);

                if (displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth() !== this.widthOfUnderlyingFrame) {
                    this.renderUnderlyingFrame = false;
                }
                if (displayProcessing.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenHeight() !== this.heightOfUnderlyingFrame) {
                    this.renderUnderlyingFrame = false;
                }

                this.soundAndMusicVolumePicker.ProcessFrame(mouseInput, previousMouseInput);
                soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$SetSoundVolume(this.soundAndMusicVolumePicker.GetCurrentSoundVolume());
                this.globalState.MusicVolume = this.soundAndMusicVolumePicker.GetCurrentMusicVolume();

                var clickedContinueButton = this.continueButton.ProcessFrame(mouseInput, previousMouseInput);

                if (clickedContinueButton || keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc)) {
                    this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);

                    return this.underlyingFrame;
                }

                var clickedBackToTitleScreenButton = this.backToTitleScreenButton.ProcessFrame(mouseInput, previousMouseInput);

                if (clickedBackToTitleScreenButton) {
                    this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.TitleScreenMobileFrame(this.globalState, this.sessionState, displayProcessing);
                }

                return this;
            },
            ProcessMusic: function () {
                this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic();
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth(), displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight(), new DTLibrary.DTColor.ctor(223, 220, 217), true);

                if (this.renderUnderlyingFrame) {
                    this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render(displayOutput);
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth(), displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight(), new DTLibrary.DTColor.$ctor1(0, 0, 0, 64), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(this.panelX, this.panelY, ((this.panelWidth - 1) | 0), ((this.panelHeight - 1) | 0), DTLibrary.DTColor.White(), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(this.panelX, this.panelY, this.panelWidth, this.panelHeight, DTLibrary.DTColor.Black(), false);

                if (this.soundAndMusicVolumePicker != null) {
                    this.soundAndMusicVolumePicker.Render(displayOutput);
                }

                if (this.showPausedText) {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((((Bridge.Int.div(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth(), 2)) | 0) - 116) | 0), DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput) ? (((this.panelY + 562) | 0)) : (((this.panelY + 682) | 0)), "Paused", ChessCompStompWithHacksLibrary.GameFont.GameFont48Pt, DTLibrary.DTColor.Black());
                }

                this.continueButton.Render(displayOutput);
                this.backToTitleScreenButton.Render(displayOutput);
            },
            RenderMusic: function (musicOutput) {
                this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.TestingDesktopFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        fields: {
            globalState: null,
            sessionState: null
        },
        alias: [
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState) {
                this.$initialize();
                this.globalState = globalState;
                this.sessionState = sessionState;
            }
        },
        methods: {
            ProcessExtraTime: function (milliseconds) { },
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType !== DTLibrary.DisplayType.Desktop) {
                    return ChessCompStompWithHacksLibrary.TitleScreenFrame.GetTitleScreenFrame(this.globalState, this.sessionState, displayType, displayProcessing);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc)) {
                    return new ChessCompStompWithHacksLibrary.TitleScreenDesktopFrame(this.globalState, this.sessionState);
                }

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.One) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.One)) {
                    return new ChessCompStompWithHacksLibrary.TestingKeyboardDesktopFrame(this.globalState, this.sessionState);
                }

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Two) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Two)) {
                    return new ChessCompStompWithHacksLibrary.TestingMouseDesktopFrame(this.globalState, this.sessionState);
                }

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Three) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Three)) {
                    return new ChessCompStompWithHacksLibrary.TestingFontDesktopFrame(this.globalState, this.sessionState);
                }

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Four) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Four)) {
                    return new ChessCompStompWithHacksLibrary.TestingSoundDesktopFrame(this.globalState, this.sessionState);
                }

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Five) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Five)) {
                    return new ChessCompStompWithHacksLibrary.TestingMusicDesktopFrame(this.globalState, this.sessionState);
                }

                return this;
            },
            ProcessMusic: function () {
                this.globalState.ProcessMusic();
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT, new DTLibrary.DTColor.ctor(223, 220, 217), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(50, 650, "1) Test keyboard\n2) Test mouse\n3) Test font\n4) Test sound\n5) Test music", ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, DTLibrary.DTColor.Black());
            },
            RenderMusic: function (musicOutput) {
                this.globalState.RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.TestingFontDesktopFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        fields: {
            globalState: null,
            sessionState: null
        },
        alias: [
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState) {
                this.$initialize();
                this.globalState = globalState;
                this.sessionState = sessionState;
            }
        },
        methods: {
            ProcessExtraTime: function (milliseconds) { },
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType !== DTLibrary.DisplayType.Desktop) {
                    return ChessCompStompWithHacksLibrary.TitleScreenFrame.GetTitleScreenFrame(this.globalState, this.sessionState, displayType, displayProcessing);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc)) {
                    return new ChessCompStompWithHacksLibrary.TestingDesktopFrame(this.globalState, this.sessionState);
                }

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Enter) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Enter)) {
                    return new ChessCompStompWithHacksLibrary.TestingFontDesktopFrame2(this.globalState, this.sessionState);
                }

                return this;
            },
            ProcessMusic: function () {
                this.globalState.ProcessMusic();
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT, new DTLibrary.DTColor.ctor(223, 220, 217), true);

                var red = new DTLibrary.DTColor.ctor(255, 0, 0);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(51, 590, 836, 60, red, false);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(50, 650, "Line 1 ABCDEFGHIJKLMNOPQRSTUVWXYZ ABCDEFGHIJKLMNOPQRSTUVWXYZ ABCDEFGHIJKLMNOPQRSTUVWXYZ\nLine 2\nLine 3\nLine 4", ChessCompStompWithHacksLibrary.GameFont.GameFont12Pt, DTLibrary.DTColor.Black());

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(51, 479, 632, 71, red, false);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(50, 550, "Line 1 abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz\nLine 2\nLine 3\nLine 4", ChessCompStompWithHacksLibrary.GameFont.GameFont14Pt, DTLibrary.DTColor.Black());

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(51, 364, 714, 85, red, false);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(50, 450, "Line 1 Chess Comp Stomp with Hacks Chess Comp Stomp with Hacks\nLine 2\nLine 3\nLine 4", ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, DTLibrary.DTColor.Black());

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(51, 259, 790, 90, red, false);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(50, 350, "Line 1 Chess Comp Stomp with Hacks Chess Comp Stomp with Hacks\nLine 2\nLine 3\nLine 4", ChessCompStompWithHacksLibrary.GameFont.GameFont18Pt, DTLibrary.DTColor.Black());

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(51, 144, 874, 104, red, false);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(50, 250, "Line 1 Chess Comp Stomp with Hacks Chess Comp Stomp with Hacks\nLine 2\nLine 3\nLine 4", ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, DTLibrary.DTColor.Black());
            },
            RenderMusic: function (musicOutput) {
                this.globalState.RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.TestingFontDesktopFrame2", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        fields: {
            globalState: null,
            sessionState: null
        },
        alias: [
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState) {
                this.$initialize();
                this.globalState = globalState;
                this.sessionState = sessionState;
            }
        },
        methods: {
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessExtraTime: function (milliseconds) { },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType !== DTLibrary.DisplayType.Desktop) {
                    return ChessCompStompWithHacksLibrary.TitleScreenFrame.GetTitleScreenFrame(this.globalState, this.sessionState, displayType, displayProcessing);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc)) {
                    return new ChessCompStompWithHacksLibrary.TestingDesktopFrame(this.globalState, this.sessionState);
                }

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Enter) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Enter)) {
                    return new ChessCompStompWithHacksLibrary.TestingFontDesktopFrame(this.globalState, this.sessionState);
                }

                return this;
            },
            ProcessMusic: function () {
                this.globalState.ProcessMusic();
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT, new DTLibrary.DTColor.ctor(223, 220, 217), true);

                var red = new DTLibrary.DTColor.ctor(255, 0, 0);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(53, 483, 895, 162, red, false);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(50, 650, "Line 1 Chess Comp Stomp with Hacks Chess\nLine 2\nLine 3\nLine 4", ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt, DTLibrary.DTColor.Black());
            },
            RenderMusic: function (musicOutput) {
                this.globalState.RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.TestingKeyboardDesktopFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        fields: {
            globalState: null,
            sessionState: null,
            x: 0,
            y: 0
        },
        alias: [
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState) {
                this.$initialize();
                this.globalState = globalState;
                this.sessionState = sessionState;

                this.x = 50;
                this.y = 50;
            }
        },
        methods: {
            ProcessExtraTime: function (milliseconds) { },
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType !== DTLibrary.DisplayType.Desktop) {
                    return ChessCompStompWithHacksLibrary.TitleScreenFrame.GetTitleScreenFrame(this.globalState, this.sessionState, displayType, displayProcessing);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc)) {
                    return new ChessCompStompWithHacksLibrary.TestingDesktopFrame(this.globalState, this.sessionState);
                }

                var delta = (Bridge.Int.div(this.globalState.ElapsedMicrosPerFrame, 2000)) | 0;

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.LeftArrow)) {
                    this.x = (this.x - delta) | 0;
                }
                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.RightArrow)) {
                    this.x = (this.x + delta) | 0;
                }
                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.DownArrow)) {
                    this.y = (this.y - delta) | 0;
                }
                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.UpArrow)) {
                    this.y = (this.y + delta) | 0;
                }

                if (this.x < 0) {
                    this.x = 0;
                }
                if (this.x > ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH) {
                    this.x = ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH;
                }
                if (this.y < 0) {
                    this.y = 0;
                }
                if (this.y > ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT) {
                    this.y = ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT;
                }

                return this;
            },
            ProcessMusic: function () {
                this.globalState.ProcessMusic();
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT, new DTLibrary.DTColor.ctor(223, 220, 217), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(((this.x - 5) | 0), ((this.y - 5) | 0), 11, 11, DTLibrary.DTColor.Black(), true);
            },
            RenderMusic: function (musicOutput) {
                this.globalState.RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.TestingMouseDesktopFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        fields: {
            globalState: null,
            sessionState: null,
            x: 0,
            y: 0,
            color: 0,
            shouldFill: false
        },
        alias: [
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState) {
                this.$initialize();
                this.globalState = globalState;
                this.sessionState = sessionState;

                this.x = 0;
                this.y = 0;
                this.color = 0;
                this.shouldFill = true;
            }
        },
        methods: {
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessExtraTime: function (milliseconds) { },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType !== DTLibrary.DisplayType.Desktop) {
                    return ChessCompStompWithHacksLibrary.TitleScreenFrame.GetTitleScreenFrame(this.globalState, this.sessionState, displayType, displayProcessing);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc)) {
                    return new ChessCompStompWithHacksLibrary.TestingDesktopFrame(this.globalState, this.sessionState);
                }

                this.x = mouseInput.DTLibrary$IMouse$GetX();
                this.y = mouseInput.DTLibrary$IMouse$GetY();

                if (mouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsLeftMouseButtonPressed()) {
                    this.color = (this.color + 1) | 0;
                    if (this.color === 4) {
                        this.color = 0;
                    }
                }

                if (mouseInput.DTLibrary$IMouse$IsRightMouseButtonPressed() && !previousMouseInput.DTLibrary$IMouse$IsRightMouseButtonPressed()) {
                    this.shouldFill = !this.shouldFill;
                }

                return this;
            },
            ProcessMusic: function () {
                this.globalState.ProcessMusic();
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT, new DTLibrary.DTColor.ctor(223, 220, 217), true);

                var dtColor;

                switch (this.color) {
                    case 0: 
                        dtColor = DTLibrary.DTColor.Black();
                        break;
                    case 1: 
                        dtColor = new DTLibrary.DTColor.ctor(255, 0, 0);
                        break;
                    case 2: 
                        dtColor = new DTLibrary.DTColor.ctor(0, 255, 0);
                        break;
                    case 3: 
                        dtColor = new DTLibrary.DTColor.ctor(0, 0, 255);
                        break;
                    default: 
                        throw new System.Exception();
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(((this.x - 5) | 0), ((this.y - 5) | 0), 11, 11, dtColor, this.shouldFill);
            },
            RenderMusic: function (musicOutput) {
                this.globalState.RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.TestingMusicDesktopFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        fields: {
            globalState: null,
            sessionState: null,
            volumePicker: null
        },
        alias: [
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState) {
                this.$initialize();
                this.globalState = globalState;
                this.sessionState = sessionState;

                this.volumePicker = null;
            }
        },
        methods: {
            ProcessExtraTime: function (milliseconds) { },
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType !== DTLibrary.DisplayType.Desktop) {
                    return ChessCompStompWithHacksLibrary.TitleScreenFrame.GetTitleScreenFrame(this.globalState, this.sessionState, displayType, displayProcessing);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc)) {
                    return new ChessCompStompWithHacksLibrary.TestingDesktopFrame(this.globalState, this.sessionState);
                }

                if (this.volumePicker == null) {
                    this.volumePicker = new ChessCompStompWithHacksLibrary.SoundAndMusicVolumePicker(0, 0, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume(), this.globalState.MusicVolume, this.globalState.ElapsedMicrosPerFrame, 1);
                }

                this.volumePicker.ProcessFrame(mouseInput, previousMouseInput);
                soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$SetSoundVolume(this.volumePicker.GetCurrentSoundVolume());
                this.globalState.MusicVolume = this.volumePicker.GetCurrentMusicVolume();

                var music = null;
                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.One) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.One)) {
                    music = ChessCompStompWithHacksLibrary.GameMusic.TitleScreen;
                }
                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Two) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Two)) {
                    music = ChessCompStompWithHacksLibrary.GameMusic.Level1;
                }
                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Three) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Three)) {
                    music = ChessCompStompWithHacksLibrary.GameMusic.Level2;
                }
                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Four) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Four)) {
                    music = ChessCompStompWithHacksLibrary.GameMusic.Level3;
                }
                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Five) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Five)) {
                    music = ChessCompStompWithHacksLibrary.GameMusic.Ending;
                }

                if (music != null) {
                    this.globalState.MusicPlayer.SetMusic(System.Nullable.getValue(music), 100);
                }

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Six) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Six)) {
                    this.globalState.MusicPlayer.StopMusic();
                }

                return this;
            },
            ProcessMusic: function () {
                this.globalState.ProcessMusic();
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT, new DTLibrary.DTColor.ctor(223, 220, 217), true);

                if (this.volumePicker != null) {
                    this.volumePicker.Render(displayOutput);
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(50, 650, "Press 1/2/3/4/5 to switch music tracks.\nPress 6 to stop music.", ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, DTLibrary.DTColor.Black());
            },
            RenderMusic: function (musicOutput) {
                this.globalState.RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.TestingSoundDesktopFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        fields: {
            globalState: null,
            sessionState: null,
            volumePicker: null,
            cooldownInMicroseconds: 0
        },
        alias: [
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState) {
                this.$initialize();
                this.globalState = globalState;
                this.sessionState = sessionState;

                this.volumePicker = null;

                this.cooldownInMicroseconds = 0;
            }
        },
        methods: {
            ProcessExtraTime: function (milliseconds) { },
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType !== DTLibrary.DisplayType.Desktop) {
                    return ChessCompStompWithHacksLibrary.TitleScreenFrame.GetTitleScreenFrame(this.globalState, this.sessionState, displayType, displayProcessing);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc)) {
                    return new ChessCompStompWithHacksLibrary.TestingDesktopFrame(this.globalState, this.sessionState);
                }

                if (this.volumePicker == null) {
                    this.volumePicker = new ChessCompStompWithHacksLibrary.SoundAndMusicVolumePicker(0, 0, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume(), this.globalState.MusicVolume, this.globalState.ElapsedMicrosPerFrame, 1);
                }

                this.volumePicker.ProcessFrame(mouseInput, previousMouseInput);
                soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$SetSoundVolume(this.volumePicker.GetCurrentSoundVolume());
                this.globalState.MusicVolume = this.volumePicker.GetCurrentMusicVolume();

                this.cooldownInMicroseconds = (this.cooldownInMicroseconds - this.globalState.ElapsedMicrosPerFrame) | 0;

                if (this.cooldownInMicroseconds <= 0) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.AIMove);

                    this.cooldownInMicroseconds = (this.cooldownInMicroseconds + (1000000)) | 0;

                    if (this.cooldownInMicroseconds < 0) {
                        this.cooldownInMicroseconds = 0;
                    }
                }

                return this;
            },
            ProcessMusic: function () {
                this.globalState.ProcessMusic();
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT, new DTLibrary.DTColor.ctor(223, 220, 217), true);

                if (this.volumePicker != null) {
                    this.volumePicker.Render(displayOutput);
                }
            },
            RenderMusic: function (musicOutput) {
                this.globalState.RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.TitleScreenDesktopFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        fields: {
            globalState: null,
            sessionState: null,
            volumePicker: null,
            startButton: null,
            continueButton: null,
            clearDataButton: null,
            creditsButton: null,
            versionString: null
        },
        alias: [
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState) {
                this.$initialize();
                this.globalState = globalState;
                this.sessionState = sessionState;
                this.volumePicker = null;

                var buttonWidth = 150;

                this.versionString = ChessCompStompWithHacksLibrary.VersionHistory.GetVersionInfo().Version;

                this.startButton = new ChessCompStompWithHacksLibrary.Button(((Bridge.Int.div((((ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH - buttonWidth) | 0)), 2)) | 0), 300, buttonWidth, 50, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Start", 35, 13, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, false);

                this.continueButton = new ChessCompStompWithHacksLibrary.Button(((Bridge.Int.div((((ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH - buttonWidth) | 0)), 2)) | 0), 300, buttonWidth, 50, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Continue", 15, 13, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, false);

                this.clearDataButton = new ChessCompStompWithHacksLibrary.Button(160, 10, 200, 31, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Reset data", 40, 6, ChessCompStompWithHacksLibrary.GameFont.GameFont16Pt, false);

                this.creditsButton = new ChessCompStompWithHacksLibrary.Button(895, 5, 100, 35, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Credits", 13, 10, ChessCompStompWithHacksLibrary.GameFont.GameFont14Pt, false);
            }
        },
        methods: {
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return this.sessionState.GetCompletedAchievements();
            },
            ProcessExtraTime: function (milliseconds) { },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType !== DTLibrary.DisplayType.Desktop) {
                    return new ChessCompStompWithHacksLibrary.TitleScreenMobileFrame(this.globalState, this.sessionState, displayProcessing);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                if (this.volumePicker == null) {
                    this.volumePicker = new ChessCompStompWithHacksLibrary.SoundAndMusicVolumePicker(0, 0, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume(), this.globalState.MusicVolume, this.globalState.ElapsedMicrosPerFrame, 1);
                }

                this.volumePicker.ProcessFrame(mouseInput, previousMouseInput);
                soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$SetSoundVolume(this.volumePicker.GetCurrentSoundVolume());
                this.globalState.MusicVolume = this.volumePicker.GetCurrentMusicVolume();

                if (this.sessionState.HasStarted) {
                    var clickedContinueButton = this.continueButton.ProcessFrame(mouseInput, previousMouseInput);
                    if (clickedContinueButton) {
                        this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);

                        if (this.sessionState.GetGameLogic() == null) {
                            return new ChessCompStompWithHacksLibrary.HackSelectionScreenDesktopFrame(this.globalState, this.sessionState);
                        } else {
                            return new ChessCompStompWithHacksLibrary.ChessDesktopFrame.ctor(this.globalState, this.sessionState);
                        }
                    }
                } else {
                    var clickedStartButton = this.startButton.ProcessFrame(mouseInput, previousMouseInput);
                    if (clickedStartButton) {
                        this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        return new ChessCompStompWithHacksLibrary.IntroScreenDesktopFrame(this.globalState, this.sessionState);
                    }
                }

                if (this.sessionState.HasStarted) {
                    var clickedClearDataButton = this.clearDataButton.ProcessFrame(mouseInput, previousMouseInput);
                    if (clickedClearDataButton) {
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        return new ChessCompStompWithHacksLibrary.ClearDataConfirmationDesktopFrame(this.globalState, this.sessionState, this);
                    }
                }

                var clickedCreditsButton = this.creditsButton.ProcessFrame(mouseInput, previousMouseInput);
                if (clickedCreditsButton) {
                    this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.CreditsDesktopFrame(this.globalState, this.sessionState);
                }

                if (this.globalState.DebugMode) {
                    if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.T) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.T)) {
                        return new ChessCompStompWithHacksLibrary.TestingDesktopFrame(this.globalState, this.sessionState);
                    }

                    if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Two) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Two)) {
                        return new ChessCompStompWithHacksLibrary.DebugInfoFrame(this.globalState, this.sessionState, displayProcessing, false);
                    }
                }

                return this;
            },
            ProcessMusic: function () {
                this.globalState.ProcessMusic();
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT, new DTLibrary.DTColor.ctor(223, 220, 217), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(182, 510, "Chess Comp Stomp With Hacks", ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt, DTLibrary.DTColor.Black());

                if (this.sessionState.HasStarted) {
                    this.clearDataButton.Render(displayOutput);
                }

                if (this.sessionState.HasStarted) {
                    this.continueButton.Render(displayOutput);
                } else {
                    this.startButton.Render(displayOutput);
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(958, 55, "v" + (this.versionString || ""), ChessCompStompWithHacksLibrary.GameFont.GameFont12Pt, DTLibrary.DTColor.Black());

                this.creditsButton.Render(displayOutput);

                if (this.volumePicker != null) {
                    this.volumePicker.Render(displayOutput);
                }
            },
            RenderMusic: function (musicOutput) {
                this.globalState.RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.TitleScreenMobileFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        fields: {
            globalState: null,
            sessionState: null,
            volumePicker: null,
            startButton: null,
            continueButton: null,
            clearDataButton: null,
            creditsButton: null,
            versionString: null
        },
        alias: [
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState, display) {
                this.$initialize();
                this.globalState = globalState;
                this.sessionState = sessionState;
                this.volumePicker = null;

                this.versionString = ChessCompStompWithHacksLibrary.VersionHistory.GetVersionInfo().Version;

                this.startButton = new ChessCompStompWithHacksLibrary.Button(0, 0, 400, 125, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Start", 137, 41, ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt, true);

                this.continueButton = new ChessCompStompWithHacksLibrary.Button(0, 0, 400, 125, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Continue", 106, 41, ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt, true);

                this.clearDataButton = new ChessCompStompWithHacksLibrary.Button(0, 0, 200, 50, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Reset data", 34, 12, ChessCompStompWithHacksLibrary.GameFont.GameFont18Pt, true);

                this.creditsButton = new ChessCompStompWithHacksLibrary.Button(0, 0, 100, 50, new DTLibrary.DTColor.ctor(200, 200, 200), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Credits", 6, 12, ChessCompStompWithHacksLibrary.GameFont.GameFont18Pt, true);

                this.UpdateButtonPositions(display);
            }
        },
        methods: {
            UpdateButtonPositions: function (display) {
                this.startButton.SetX(((Bridge.Int.div((((display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth() - 400) | 0)), 2)) | 0));
                this.startButton.SetY(((((Bridge.Int.div(display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenHeight(), 2)) | 0) - 100) | 0));

                this.continueButton.SetX(((Bridge.Int.div((((display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth() - 400) | 0)), 2)) | 0));
                this.continueButton.SetY(((((Bridge.Int.div(display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenHeight(), 2)) | 0) - 100) | 0));

                this.clearDataButton.SetX(320);
                this.clearDataButton.SetY(5);

                this.creditsButton.SetX(((display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth() - 105) | 0));
                this.creditsButton.SetY(5);
            },
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return this.sessionState.GetCompletedAchievements();
            },
            ProcessExtraTime: function (milliseconds) { },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType === DTLibrary.DisplayType.Desktop) {
                    return new ChessCompStompWithHacksLibrary.TitleScreenDesktopFrame(this.globalState, this.sessionState);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                this.UpdateButtonPositions(displayProcessing);

                if (this.volumePicker == null) {
                    this.volumePicker = new ChessCompStompWithHacksLibrary.SoundAndMusicVolumePicker(0, 0, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume(), this.globalState.MusicVolume, this.globalState.ElapsedMicrosPerFrame, 2);
                }

                this.volumePicker.ProcessFrame(mouseInput, previousMouseInput);
                soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$SetSoundVolume(this.volumePicker.GetCurrentSoundVolume());
                this.globalState.MusicVolume = this.volumePicker.GetCurrentMusicVolume();

                if (this.sessionState.HasStarted) {
                    var clickedContinueButton = this.continueButton.ProcessFrame(mouseInput, previousMouseInput);
                    if (clickedContinueButton) {
                        this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);

                        if (this.sessionState.GetGameLogic() == null) {
                            return new ChessCompStompWithHacksLibrary.HackSelectionScreenMobileFrame(this.globalState, this.sessionState, displayProcessing);
                        } else {
                            return new ChessCompStompWithHacksLibrary.ChessMobileFrame.ctor(this.globalState, this.sessionState, displayProcessing);
                        }
                    }
                } else {
                    var clickedStartButton = this.startButton.ProcessFrame(mouseInput, previousMouseInput);
                    if (clickedStartButton) {
                        this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        return new ChessCompStompWithHacksLibrary.IntroScreenMobileFrame(this.globalState, this.sessionState, displayProcessing);
                    }
                }

                if (this.sessionState.HasStarted) {
                    var clickedClearDataButton = this.clearDataButton.ProcessFrame(mouseInput, previousMouseInput);
                    if (clickedClearDataButton) {
                        soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                        return new ChessCompStompWithHacksLibrary.ClearDataConfirmationMobileFrame(this.globalState, this.sessionState, this, displayProcessing);
                    }
                }

                var clickedCreditsButton = this.creditsButton.ProcessFrame(mouseInput, previousMouseInput);
                if (clickedCreditsButton) {
                    this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.CreditsMobileFrame(this.globalState, this.sessionState, displayProcessing);
                }

                if (this.globalState.DebugMode) {
                    if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Two) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Two)) {
                        return new ChessCompStompWithHacksLibrary.DebugInfoFrame(this.globalState, this.sessionState, displayProcessing, true);
                    }
                }

                return this;
            },
            ProcessMusic: function () {
                this.globalState.ProcessMusic();
            },
            Render: function (displayOutput) {
                var isLandscape = DTLibrary.DisplayExtensions.IsMobileInLandscapeOrientation$1(ChessCompStompWithHacksLibrary.GameImage, ChessCompStompWithHacksLibrary.GameFont, displayOutput);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth(), displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight(), new DTLibrary.DTColor.ctor(223, 220, 217), true);

                if (isLandscape) {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((((Bridge.Int.div(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth(), 2)) | 0) - 474) | 0), ((((Bridge.Int.div(Bridge.Int.mul(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight(), 3), 4)) | 0) + 32) | 0), "Chess Comp Stomp With Hacks", ChessCompStompWithHacksLibrary.GameFont.GameFont48Pt, DTLibrary.DTColor.Black());
                } else {
                    displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((((Bridge.Int.div(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth(), 2)) | 0) - 319) | 0), ((((Bridge.Int.div(Bridge.Int.mul(displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight(), 3), 4)) | 0) + 32) | 0), "Chess Comp Stomp With Hacks", ChessCompStompWithHacksLibrary.GameFont.GameFont32Pt, DTLibrary.DTColor.Black());
                }

                if (this.sessionState.HasStarted) {
                    this.clearDataButton.Render(displayOutput);
                }

                if (this.sessionState.HasStarted) {
                    this.continueButton.Render(displayOutput);
                } else {
                    this.startButton.Render(displayOutput);
                }

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawText(((displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth() - 52) | 0), 74, "v" + (this.versionString || ""), ChessCompStompWithHacksLibrary.GameFont.GameFont14Pt, DTLibrary.DTColor.Black());

                this.creditsButton.Render(displayOutput);

                if (this.volumePicker != null) {
                    this.volumePicker.Render(displayOutput);
                }
            },
            RenderMusic: function (musicOutput) {
                this.globalState.RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ViewHacksDesktopFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        fields: {
            globalState: null,
            sessionState: null,
            settingsIcon: null,
            backToGameButton: null,
            hackSelectionScreenDisplay: null
        },
        alias: [
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState) {
                this.$initialize();
                this.globalState = globalState;
                this.sessionState = sessionState;

                this.hackSelectionScreenDisplay = new ChessCompStompWithHacksLibrary.HackSelectionScreenDisplayDesktop(sessionState, false);

                this.settingsIcon = new ChessCompStompWithHacksLibrary.SettingsIcon(false);

                this.backToGameButton = new ChessCompStompWithHacksLibrary.Button(300, 55, 400, 80, new DTLibrary.DTColor.ctor(235, 235, 235), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Back to game", 113, 27, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, false);
            }
        },
        methods: {
            ProcessExtraTime: function (milliseconds) {
                var gameLogic = this.sessionState.GetGameLogic();
                if (gameLogic != null) {
                    gameLogic.ProcessExtraTime(milliseconds);
                }
            },
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType !== DTLibrary.DisplayType.Desktop) {
                    return new ChessCompStompWithHacksLibrary.ViewHacksMobileFrame(this.globalState, this.sessionState, displayProcessing);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                var rightClickedHack = this.hackSelectionScreenDisplay.ProcessFrame(mouseInput, previousMouseInput, displayProcessing, soundOutput);

                if (rightClickedHack != null) {
                    return new ChessCompStompWithHacksLibrary.HackExplanationDesktopFrame(this.globalState, this.sessionState, System.Nullable.getValue(rightClickedHack), this);
                }

                var clickedBackToGameButton = this.backToGameButton.ProcessFrame(mouseInput, previousMouseInput);
                if (clickedBackToGameButton) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.ChessDesktopFrame.ctor(this.globalState, this.sessionState);
                }

                var settingsIconStatus = this.settingsIcon.ProcessFrame(mouseInput, previousMouseInput, false, displayProcessing);

                if (settingsIconStatus.HasClicked) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.SettingsMenuDesktopFrame(this.globalState, this.sessionState, this, false, true);
                }

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc)) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.ChessDesktopFrame.ctor(this.globalState, this.sessionState);
                }

                return this;
            },
            ProcessMusic: function () {
                this.globalState.ProcessMusic();
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT, new DTLibrary.DTColor.ctor(223, 220, 217), true);

                this.hackSelectionScreenDisplay.RenderButtons(displayOutput);

                this.settingsIcon.Render(displayOutput);

                this.backToGameButton.Render(displayOutput);

                this.hackSelectionScreenDisplay.RenderHoverDisplay(displayOutput);
            },
            RenderMusic: function (musicOutput) {
                this.globalState.RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ViewHacksMobileFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        fields: {
            globalState: null,
            sessionState: null,
            settingsIcon: null,
            backToGameButton: null,
            hackSelectionScreenDisplay: null,
            hackSelectionScreenMobileTabInPreviousFrame: 0
        },
        alias: [
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState, display) {
                this.$initialize();
                this.globalState = globalState;
                this.sessionState = sessionState;

                this.hackSelectionScreenDisplay = new ChessCompStompWithHacksLibrary.HackSelectionScreenDisplayMobile(sessionState, false, display);

                this.settingsIcon = new ChessCompStompWithHacksLibrary.SettingsIcon(true);

                this.backToGameButton = new ChessCompStompWithHacksLibrary.Button(0, 0, 400, 80, new DTLibrary.DTColor.ctor(235, 235, 235), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Back to game", 113, 27, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, true);

                this.hackSelectionScreenMobileTabInPreviousFrame = sessionState.GetHackSelectionScreenMobileTab();

                this.UpdateCoordinates(display);
            }
        },
        methods: {
            UpdateCoordinates: function (display) {
                this.backToGameButton.SetX(((((Bridge.Int.div(display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth(), 2)) | 0) - 200) | 0));
                this.backToGameButton.SetY(55);
            },
            ProcessExtraTime: function (milliseconds) {
                var gameLogic = this.sessionState.GetGameLogic();
                if (gameLogic != null) {
                    gameLogic.ProcessExtraTime(milliseconds);
                }
            },
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType === DTLibrary.DisplayType.Desktop) {
                    return new ChessCompStompWithHacksLibrary.ViewHacksDesktopFrame(this.globalState, this.sessionState);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                this.UpdateCoordinates(displayProcessing);

                var clickedOnMoreDetailsHack = this.hackSelectionScreenDisplay.ProcessFrame(mouseInput, previousMouseInput, displayProcessing, soundOutput);

                if (clickedOnMoreDetailsHack != null) {
                    return new ChessCompStompWithHacksLibrary.HackExplanationMobileFrame(this.globalState, this.sessionState, System.Nullable.getValue(clickedOnMoreDetailsHack), this);
                }

                var clickedBackToGameButton = this.backToGameButton.ProcessFrame(mouseInput, previousMouseInput);
                if (clickedBackToGameButton) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.ChessMobileFrame.ctor(this.globalState, this.sessionState, displayProcessing);
                }

                var settingsIconStatus = this.settingsIcon.ProcessFrame(mouseInput, previousMouseInput, false, displayProcessing);

                if (settingsIconStatus.HasClicked) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.SettingsMenuMobileFrame(this.globalState, this.sessionState, this, false, displayProcessing, true);
                }

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc)) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.ChessMobileFrame.ctor(this.globalState, this.sessionState, displayProcessing);
                }

                if (this.sessionState.GetHackSelectionScreenMobileTab() !== this.hackSelectionScreenMobileTabInPreviousFrame) {
                    this.globalState.SaveData(this.sessionState, soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$GetSoundVolume());
                }

                this.hackSelectionScreenMobileTabInPreviousFrame = this.sessionState.GetHackSelectionScreenMobileTab();

                return this;
            },
            ProcessMusic: function () {
                this.globalState.ProcessMusic();
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth(), displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight(), new DTLibrary.DTColor.ctor(223, 220, 217), true);

                this.hackSelectionScreenDisplay.RenderButtons(displayOutput);

                this.settingsIcon.Render(displayOutput);

                this.backToGameButton.Render(displayOutput);
            },
            RenderMusic: function (musicOutput) {
                this.globalState.RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ViewLicenseTextDesktopFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        fields: {
            globalState: null,
            sessionState: null,
            scrollableTextDisplay: null,
            backButton: null,
            underlyingFrame: null
        },
        alias: [
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState, text, underlyingFrame) {
                this.$initialize();
                this.globalState = globalState;
                this.sessionState = sessionState;
                this.underlyingFrame = underlyingFrame;

                this.scrollableTextDisplay = new ChessCompStompWithHacksLibrary.ScrollableTextDisplay(23, 123, 952, 554, 16, 34, ChessCompStompWithHacksLibrary.GameFont.GameFont12Pt, DTLibrary.DTColor.Black(), text);

                this.backButton = new ChessCompStompWithHacksLibrary.Button(400, 50, 200, 60, new DTLibrary.DTColor.ctor(235, 235, 235), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Back", 67, 16, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, false);
            }
        },
        methods: {
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType !== DTLibrary.DisplayType.Desktop) {
                    this.underlyingFrame = this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType(displayType, displayProcessing);

                    return this.underlyingFrame;
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                this.scrollableTextDisplay.ProcessFrame(keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput);

                var clickedBackButton = this.backButton.ProcessFrame(mouseInput, previousMouseInput);

                if (clickedBackButton) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return this.underlyingFrame;
                }

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc)) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return this.underlyingFrame;
                }

                return this;
            },
            ProcessExtraTime: function (milliseconds) {
                this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime(milliseconds);
            },
            ProcessMusic: function () {
                this.globalState.ProcessMusic();
            },
            Render: function (displayOutput) {
                this.underlyingFrame.DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render(displayOutput);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT, new DTLibrary.DTColor.$ctor1(0, 0, 0, 64), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(20, 20, 959, 659, DTLibrary.DTColor.White(), true);

                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(20, 20, 960, 660, DTLibrary.DTColor.Black(), false);

                this.scrollableTextDisplay.Render(displayOutput);

                this.backButton.Render(displayOutput);
            },
            RenderMusic: function (musicOutput) {
                this.globalState.RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ViewObjectivesDesktopFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        fields: {
            globalState: null,
            sessionState: null,
            settingsIcon: null,
            backToGameButton: null,
            objectivesScreenDisplay: null
        },
        alias: [
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState) {
                this.$initialize();
                this.objectivesScreenDisplay = new ChessCompStompWithHacksLibrary.ObjectivesScreenDisplayDesktop(sessionState);

                this.globalState = globalState;
                this.sessionState = sessionState;

                this.settingsIcon = new ChessCompStompWithHacksLibrary.SettingsIcon(false);

                this.backToGameButton = new ChessCompStompWithHacksLibrary.Button(300, 55, 400, 80, new DTLibrary.DTColor.ctor(235, 235, 235), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Back to game", 113, 27, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, false);
            }
        },
        methods: {
            ProcessExtraTime: function (milliseconds) {
                var gameLogic = this.sessionState.GetGameLogic();
                if (gameLogic != null) {
                    gameLogic.ProcessExtraTime(milliseconds);
                }
            },
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType !== DTLibrary.DisplayType.Desktop) {
                    return new ChessCompStompWithHacksLibrary.ViewObjectivesMobileFrame(this.globalState, this.sessionState, displayProcessing);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                var clickedSettingsIcon = this.settingsIcon.ProcessFrame(mouseInput, previousMouseInput, false, displayProcessing).HasClicked;
                if (clickedSettingsIcon) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.SettingsMenuDesktopFrame(this.globalState, this.sessionState, this, false, true);
                }

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc)) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.ChessDesktopFrame.ctor(this.globalState, this.sessionState);
                }

                var clickedBackToGameButton = this.backToGameButton.ProcessFrame(mouseInput, previousMouseInput);
                if (clickedBackToGameButton) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.ChessDesktopFrame.ctor(this.globalState, this.sessionState);
                }

                return this;
            },
            ProcessMusic: function () {
                this.globalState.ProcessMusic();
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_WIDTH, ChessCompStompWithHacksLibrary.GlobalConstants.DESKTOP_WINDOW_HEIGHT, new DTLibrary.DTColor.ctor(223, 220, 217), true);

                this.settingsIcon.Render(displayOutput);

                this.backToGameButton.Render(displayOutput);

                this.objectivesScreenDisplay.Render(displayOutput);
            },
            RenderMusic: function (musicOutput) {
                this.globalState.RenderMusic(musicOutput);
            }
        }
    });

    Bridge.define("ChessCompStompWithHacksLibrary.ViewObjectivesMobileFrame", {
        inherits: [DTLibrary.IFrame$4(ChessCompStompWithHacksLibrary.GameImage,ChessCompStompWithHacksLibrary.GameFont,ChessCompStompWithHacksLibrary.GameSound,ChessCompStompWithHacksLibrary.GameMusic)],
        fields: {
            globalState: null,
            sessionState: null,
            settingsIcon: null,
            backToGameButton: null,
            objectivesScreenDisplay: null
        },
        alias: [
            "ProcessExtraTime", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessExtraTime",
            "GetClickUrl", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetClickUrl",
            "GetCompletedAchievements", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetCompletedAchievements",
            "ProcessDisplayType", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessDisplayType",
            "GetNextFrame", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$GetNextFrame",
            "ProcessMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$ProcessMusic",
            "Render", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$Render",
            "RenderMusic", "DTLibrary$IFrame$4$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$ChessCompStompWithHacksLibrary$GameSound$ChessCompStompWithHacksLibrary$GameMusic$RenderMusic"
        ],
        ctors: {
            ctor: function (globalState, sessionState, display) {
                this.$initialize();
                this.objectivesScreenDisplay = new ChessCompStompWithHacksLibrary.ObjectivesScreenDisplayMobile(sessionState);

                this.globalState = globalState;
                this.sessionState = sessionState;

                this.settingsIcon = new ChessCompStompWithHacksLibrary.SettingsIcon(true);

                this.backToGameButton = new ChessCompStompWithHacksLibrary.Button(0, 0, 400, 80, new DTLibrary.DTColor.ctor(235, 235, 235), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetHoverColor(sessionState.GetColorTheme()), ChessCompStompWithHacksLibrary.ColorThemeUtil.GetClickColor(sessionState.GetColorTheme()), "Back to game", 113, 27, ChessCompStompWithHacksLibrary.GameFont.GameFont20Pt, true);

                this.UpdateCoordinates(display);
            }
        },
        methods: {
            UpdateCoordinates: function (display) {
                this.backToGameButton.SetX(((((Bridge.Int.div(display.DTLibrary$IDisplayProcessing$1$ChessCompStompWithHacksLibrary$GameImage$GetMobileScreenWidth(), 2)) | 0) - 200) | 0));
                this.backToGameButton.SetY(55);
            },
            ProcessExtraTime: function (milliseconds) {
                var gameLogic = this.sessionState.GetGameLogic();
                if (gameLogic != null) {
                    gameLogic.ProcessExtraTime(milliseconds);
                }
            },
            GetClickUrl: function () {
                return null;
            },
            GetCompletedAchievements: function () {
                return new (System.Collections.Generic.HashSet$1(System.String)).ctor();
            },
            ProcessDisplayType: function (displayType, displayProcessing) {
                if (displayType === DTLibrary.DisplayType.Desktop) {
                    return new ChessCompStompWithHacksLibrary.ViewObjectivesDesktopFrame(this.globalState, this.sessionState);
                }

                return this;
            },
            GetNextFrame: function (keyboardInput, mouseInput, previousKeyboardInput, previousMouseInput, displayProcessing, soundOutput, musicProcessing) {
                this.UpdateCoordinates(displayProcessing);

                var clickedSettingsIcon = this.settingsIcon.ProcessFrame(mouseInput, previousMouseInput, false, displayProcessing).HasClicked;
                if (clickedSettingsIcon) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.SettingsMenuMobileFrame(this.globalState, this.sessionState, this, false, displayProcessing, true);
                }

                if (keyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc) && !previousKeyboardInput.DTLibrary$IKeyboard$IsPressed(DTLibrary.Key.Esc)) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.ChessMobileFrame.ctor(this.globalState, this.sessionState, displayProcessing);
                }

                var clickedBackToGameButton = this.backToGameButton.ProcessFrame(mouseInput, previousMouseInput);
                if (clickedBackToGameButton) {
                    soundOutput.DTLibrary$ISoundOutput$1$ChessCompStompWithHacksLibrary$GameSound$PlaySound(ChessCompStompWithHacksLibrary.GameSound.Click);
                    return new ChessCompStompWithHacksLibrary.ChessMobileFrame.ctor(this.globalState, this.sessionState, displayProcessing);
                }

                return this;
            },
            ProcessMusic: function () {
                this.globalState.ProcessMusic();
            },
            Render: function (displayOutput) {
                displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$DrawRectangle(0, 0, displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenWidth(), displayOutput.DTLibrary$IDisplayOutput$2$ChessCompStompWithHacksLibrary$GameImage$ChessCompStompWithHacksLibrary$GameFont$GetMobileScreenHeight(), new DTLibrary.DTColor.ctor(223, 220, 217), true);

                this.settingsIcon.Render(displayOutput);

                this.backToGameButton.Render(displayOutput);

                this.objectivesScreenDisplay.Render(displayOutput);
            },
            RenderMusic: function (musicOutput) {
                this.globalState.RenderMusic(musicOutput);
            }
        }
    });
});
